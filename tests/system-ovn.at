AT_BANNER([system-ovn])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switches foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.1)'])

# 'alice1' should be able to ping 'foo1' directly.
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice1' should also be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=172.16.1.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Add static routes to handle east-west NAT.
check ovn-nbctl lr-route-add R1 30.0.0.0/24 20.0.0.2

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-west DNAT and SNAT: 'bar1' pings 30.0.0.2. 'foo1' receives it.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# As we have a static route that sends all packets with destination
# 30.0.0.2 to R2, it hits the DNAT rule and converts 30.0.0.2 to 192.168.1.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# As we have a SNAT rule that converts 192.168.2.2 to 30.0.0.1, the source is
# SNATted and 'foo1' receives it.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd00::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd21::/64) connected
# to it.  R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd21::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd00::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd00::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 fd21::/64 fd00::2
check ovn-nbctl lr-route-add R2 fd11::/64 fd00::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd00::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd21::2/64", "f0:00:00:01:02:04", \
         "fd21::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd21::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
         "fd12::1", "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=\"fd11::2\" \
    external_ip=\"fd30::2\" -- add logical_router R2 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd12::2\" \
    external_ip=\"fd30::1\" -- add logical_router R2 nat @nat

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])

# 'alice1' should be able to ping 'foo1' directly.
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice1' should also be able to ping 'foo1' via fd30::2
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd21::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd21::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd21::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from fd30::1
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd21::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd21::2,id=<cleared>,type=128,code=0),reply=(src=fd21::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

# Add static routes to handle east-west NAT.
check ovn-nbctl lr-route-add R1 fd30::/64 fd00::2

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-west DNAT and SNAT: 'bar1' pings fd30::2. 'foo1' receives it.
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# As we have a static route that sends all packets with destination
# fd30::2 to R2, it hits the DNAT rule and converts fd30::2 to fd11::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd12::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# As we have a SNAT rule that converts fd12::2 to fd30::1, the source is
# SNATted and 'foo1' receives it.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, easy SNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) connected
# to it.  R2 has alice (172.16.1.0/24) connected to it.
# R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice

check ovn-nbctl lr-add R1
check ovn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=172.16.1.1 -- add logical_router R2 nat @nat

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, easy SNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd10::/64) connected
# to it.  R2 has alice (fd30::/64) connected to it.
# R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice

check ovn-nbctl lr-add R1
check ovn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd10::1/64
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 fd30::/64 fd20::2
check ovn-nbctl lr-route-add R2 fd10::/64 fd20::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd10::2/64", "f0:00:00:01:02:03", \
         "fd10::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd10::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd30::2/64", "f0:00:00:01:02:04", \
         "fd30::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd30::2"

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd10::2\" \
    external_ip=\"fd30::1\" -- add logical_router R2 nat @nat

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from fd30::1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd10::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd30::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
check ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:dnat_force_snat_ip=20.0.0.2
check ovn-nbctl set logical_router R3 options:dnat_force_snat_ip=20.0.0.3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Router R2
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.3 -- add logical_router R3 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.4 -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from 30.0.0.4
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd30::/64) connected
# to it.  R3 has bob (fd30::/64) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd30::2/64
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
check ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:dnat_force_snat_ip=fd20::2
check ovn-nbctl set logical_router R3 options:dnat_force_snat_ip=fd20::3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd30::3/64", "f0:00:00:01:02:04", \
         "fd30::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd30::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
         "fd12::1", "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "fd30::4/64", "f0:00:00:01:02:06", \
         "fd30::2", "nodad")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd30::4"

# External IPs -- 30.0.0.N --> fd40::N (from IPv4 version of test case)

# Router R2
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::2"' -- add logical_router R2 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd11::2"' \
    external_ip='"fd40::1"' -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::3"' -- add logical_router R3 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd12::2"' \
    external_ip='"fd40::4"' -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via fd30::2
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from fd20::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via fd40::3
NS_CHECK_EXEC([bob1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from fd20::3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from fd40::4
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from fd40::1
NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT - Dual Stack])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24
# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2
# has alice (172.16.1.0/24 and fd30::/64) connected to it.  R3 has bob
# (172.16.1.0/24 andfd30::/64) connected to it. Note how both alice and bob
# have the same subnets behind them.  We are trying to simulate external network
# via those 2 switches. In real world the switch ports of these switches will
# have addresses set as "unknown" to make them learning switches. Or those
# switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd30::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd30::2/64
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
check ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
check ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd12::/64 fd20::1
check ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:dnat_force_snat_ip="20.0.0.2 fd20::2"
check ovn-nbctl set logical_router R3 options:dnat_force_snat_ip="20.0.0.3 fd20::3"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(foo16)
ADD_VETH(foo16, foo16, br-int, "fd11::2/64", "f0:00:00:02:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo16 \
-- lsp-set-addresses foo16 "f0:00:00:02:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

ADD_NAMESPACES(alice16)
ADD_VETH(alice16, alice16, br-int, "fd30::3/64", "f0:00:00:02:02:04", \
         "fd30::1", "nodad")
check ovn-nbctl lsp-add alice alice16 \
-- lsp-set-addresses alice16 "f0:00:00:02:02:04 fd30::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

ADD_NAMESPACES(bar16)
ADD_VETH(bar16, bar16, br-int, "fd12::2/64", "f0:00:00:02:02:05", \
         "fd12::1", "nodad")
check ovn-nbctl lsp-add bar bar16 \
-- lsp-set-addresses bar16 "f0:00:00:02:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

ADD_NAMESPACES(bob16)
ADD_VETH(bob16, bob16, br-int, "fd30::4/64", "f0:00:00:02:02:06", \
         "fd30::2", "nodad")
check ovn-nbctl lsp-add bob bob16 \
-- lsp-set-addresses bob16 "f0:00:00:02:02:06 fd30::4"

# Router R2
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::2"' -- add logical_router R2 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd11::2"' \
    external_ip='"fd40::1"' -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.3 -- add logical_router R3 nat @nat
check_uuid ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::3"' -- add logical_router R3 nat @nat

# Add a SNAT rule
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.4 -- add logical_router R3 nat @nat
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd12::2"' \
    external_ip='"fd40::4"' -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice16' should be able to ping 'foo16' via fd30::2
NS_CHECK_EXEC([alice16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])
# But foo16 should receive traffic from fd20::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'bob16' should be able to ping 'foo16' via fd40::3
NS_CHECK_EXEC([bob16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo16 should receive traffic from fd20::3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from 30.0.0.4
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
# South-North SNAT: 'bar16' pings 'bob16'. But 'bob16' receives traffic
# from fd40::4
NS_CHECK_EXEC([bar16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# South-North SNAT: 'foo16' pings 'alice16'. But 'alice16' receives traffic
# from fd40::1
NS_CHECK_EXEC([foo16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 2 logical switches "foo" (192.168.1.0/24) and "bar" (172.16.1.0/24)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.
#
# Loadbalancer VIPs in 30.0.0.0/24 network.

check_uuid ovn-nbctl create Logical_Router name=R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "172.16.1.2/24", "f0:00:0f:01:02:03", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 172.16.1.2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "172.16.1.3/24", "f0:00:0f:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 172.16.1.3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "172.16.1.4/24", "f0:00:0f:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 172.16.1.4"

# Config OVN load-balancer with a VIP.
check ovn-nbctl lb-add lb1 30.0.0.1 "172.16.1.2,172.16.1.3,172.16.1.4"
check ovn-nbctl ls-lb-add foo lb1

# Create another load-balancer with another VIP.
lb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3="172.16.1.2,172.16.1.3,172.16.1.4"`
check ovn-nbctl ls-lb-add foo lb2

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $lb2_uuid vips:'"30.0.0.2:8000"'='"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=172.16.1.4:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3'.
OVS_START_L7([bar1], [http])
OVS_START_L7([bar2], [http])
OVS_START_L7([bar3], [http])

# Add ACLs (after lb) to drop the traffic if destined to backend  ips.
check ovn-nbctl --apply-after-lb acl-add foo from-lport 1002 "ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new" drop
check ovn-nbctl --wait=hv sync

AT_CHECK([ip netns exec foo1 curl 30.0.0.1 --retry 3 --max-time 1], [28], [ignore], [ignore])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Clear the apply-after-lb option.  The traffic will be allowed.
check ovn-nbctl clear acl . options
check ovn-nbctl --wait=hv sync

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

check ovn-nbctl acl-del foo from-lport 1002 "ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new"
check ovn-nbctl --wait=hv sync

dnl Should work with the virtual IP 30.0.0.1 address through NAT
dnl Each server should have at least one connection.
dnl With 20 requests, one server might not receive any connection
dnl in 0.3% of cases, so run a few times.

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Should work with the virtual IP 30.0.0.3 address through NAT
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Configure selection_fields.
check ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

dnl Test load-balancing that includes L4 ports in NAT.
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

echo "foo" > foo
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -p 30000 30.0.0.2 8000 < foo
done

dnl Only one backend should be chosen.
AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 -c) -eq 1])

check ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields=ip_src" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc 30.0.0.2 8000 < foo
done

dnl Only one backend should be chosen as eth_src and ip_src is fixed.
bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.4 -c)

AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1 -c) -ne 0])

if [[ "$bar1_ct" == "20" ]]; then
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar1_ct -eq 0])
fi

if [[ "$bar2_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar2_ct -eq 0])
fi

if [[ "$bar3_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 0])
    AT_CHECK([test $bar2_ct -eq 0])
else
    AT_CHECK([test $bar3_ct -eq 0])
fi

# Change the protocol of lb2 to udp and set tp_src and tp_dst.
check ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

check ovn-nbctl set load_balancer $lb2_uuid protocol=udp

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 2
])

# Change the protocol of lb2 to sctp.
check ovn-nbctl set load_balancer $lb2_uuid protocol=sctp

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 2
])

check ovn-nbctl --reject lb-add lb3 30.0.0.10:80 ""
check ovn-nbctl ls-lb-add foo lb3
# Filter reset segments
NETNS_START_TCPDUMP([foo1], [-c 1 -neei foo1 ip[[33:1]]=0x14], [rst])
NS_CHECK_EXEC([foo1], [curl 30.0.0.10 -s --retry 3 --max-time 1], [7])

OVS_WAIT_UNTIL([
    n_reset=$(cat rst.tcpdump | wc -l)
    test "${n_reset}" = "1"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 2 logical switches "foo" (fd01::/64) and "bar" (fd02::/64)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.
#
# Loadbalancer VIPs in fd03::/64 network.

check_uuid ovn-nbctl create Logical_Router name=R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd01::2/64", "f0:00:00:01:02:03", \
         "fd01::1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd01::2"

# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd02::2/64", "f0:00:0f:01:02:03", \
         "fd02::1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 fd02::2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "fd02::3/64", "f0:00:0f:01:02:04", \
         "fd02::1")
check ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 fd02::3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "fd02::4/64", "f0:00:0f:01:02:05", \
         "fd02::1")
check ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 fd02::4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd03::1\"=\"fd02::2,fd02::3,fd02::4\"`
check ovn-nbctl set logical_switch foo load_balancer=$uuid

# Create another load-balancer with another VIP.
lb2_uuid=`ovn-nbctl create load_balancer vips:\"fd03::3\"=\"fd02::2,fd02::3,fd02::4\"`
check ovn-nbctl add logical_switch foo load_balancer $lb2_uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $lb2_uuid vips:'"[[fd03::2]]:8000"'='"@<:@fd02::2@:>@:80,@<:@fd02::3@:>@:80,@<:@fd02::4@:>@:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd02::4\]]:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3'.
OVS_START_L7([bar1], [http6])
OVS_START_L7([bar2], [http6])
OVS_START_L7([bar3], [http6])

dnl Should work with the virtual IP fd03::1 address through NAT
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log || (ovs-ofctl -O OpenFlow13 dump-flows br-int && false)])
done
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Should work with the virtual IP fd03::3 address through NAT
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::3]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done
dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::3) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_WAIT_FOR_OUTPUT([
dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done
dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Configure selection_fields.
check ovn-nbctl set load_balancer $lb2_uuid selection_fields="ipv6_src,ipv6_dst,tp_src,tp_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ipv6_src,ipv6_dst,tcp_src,tcp_dst)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

OVS_WAIT_FOR_OUTPUT([
dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

echo "foo" > foo
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -6 -p 30000 fd03::2 8000 < foo
done

# Only one backend should be chosen. Since the source port is fixed,
# there should be only one conntrack entry.
AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 -c) -eq 1])

check ovn-nbctl set load_balancer $lb2_uuid selection_fields="eth_src,ipv6_src"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(eth_src,ipv6_src)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -6 fd03::2 8000 < foo
done

dnl Only one backend should be chosen as eth_src and ip_src is fixed.
bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02::2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::4 -c)

AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02 -c) -ne 0])

if [[ "$bar1_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar1_ct -eq 0])
fi

if [[ "$bar2_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar2_ct -eq 0])
fi

if [[ "$bar3_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar3_ct -eq 0])
fi
OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - Dual Stack])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller.
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

check_uuid ovn-nbctl create Logical_Router name=R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1.
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd01::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1.
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24 fd02::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
NS_EXEC([foo1],[ip addr add fd01::2/64 dev foo1 nodad])
NS_EXEC([foo1],[ip -6 route add default via fd01::1])
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2 fd01::2"

# Create logical ports 'bar1', 'bar2', 'bar3', 'bar6', 'bar7', 'bar8' in
# switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "172.16.1.2/24", "f0:00:0f:01:02:03", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 172.16.1.2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "172.16.1.3/24", "f0:00:0f:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 172.16.1.3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "172.16.1.4/24", "f0:00:0f:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 172.16.1.4"

ADD_NAMESPACES(bar6)
ADD_VETH(bar6, bar6, br-int, "fd02::2/64", "f0:00:0f:02:02:03", \
         "fd02::1", "nodad")
check ovn-nbctl lsp-add bar bar6 \
-- lsp-set-addresses bar6 "f0:00:0f:02:02:03 fd02::2"

ADD_NAMESPACES(bar7)
ADD_VETH(bar7, bar7, br-int, "fd02::3/64", "f0:00:0f:02:02:04", \
         "fd02::1", "nodad")
check ovn-nbctl lsp-add bar bar7 \
-- lsp-set-addresses bar7 "f0:00:0f:02:02:04 fd02::3"

ADD_NAMESPACES(bar8)
ADD_VETH(bar8, bar8, br-int, "fd02::4/64", "f0:00:0f:02:02:05", \
         "fd02::1", "nodad")
check ovn-nbctl lsp-add bar bar8 \
-- lsp-set-addresses bar8 "f0:00:0f:02:02:05 fd02::4"

# Config OVN load-balancer with a VIP.
check ovn-nbctl lb-add lb1 30.0.0.1:8080 "172.16.1.2:80,172.16.1.3:80,172.16.1.4:80"
lb1_uuid=$(fetch_column nb:load_balancer _uuid name="lb1")
check ovn-nbctl set load_balancer $lb1_uuid vips:'"[[fd03::2]]:8090"'='"@<:@fd02::2@:>@:80,@<:@fd02::3@:>@:80,@<:@fd02::4@:>@:80"'

check ovn-nbctl ls-lb-add foo lb1

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=172.16.1.4:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3' for IPv4 connections.
OVS_START_L7([bar1], [http])
OVS_START_L7([bar2], [http])
OVS_START_L7([bar3], [http])
# Start webservers in 'bar6', 'bar7' and 'bar8' for IPv6 connections.
OVS_START_L7([bar6], [http6])
OVS_START_L7([bar7], [http6])
OVS_START_L7([bar8], [http6])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

dnl Test load-balancing that includes L4 ports in NAT.
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in $(seq 1 20); do
        NS_EXEC([foo1], [wget 30.0.0.1:8080 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_WAIT_FOR_OUTPUT([
# Test load-balancing that includes L4 ports in NAT.
for i in $(seq 1 10); do
    NS_EXEC([foo1], [wget http://[[fd03::2]]:8090 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done
# Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Configure selection_fields.
check ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,ipv6_src,ipv6_dst,tp_src,tp_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,ipv6_src,ipv6_dst,tcp_src,tcp_dst)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Test load-balancing that includes L4 ports in NAT.
# Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in $(seq 1 20); do
        NS_EXEC([foo1], [wget 30.0.0.1:8080 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_WAIT_FOR_OUTPUT([
# Test load-balancing that includes L4 ports in NAT.
for i in $(seq 1 10); do
    NS_EXEC([foo1], [wget http://[[fd03::2]]:8090 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done
# Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

echo "foo" > foo
for i in $(seq 1 20); do
    echo Request $i
    NS_EXEC([foo1], [nc -p 30000 30.0.0.1 8080 < foo])
done

# Only one backend should be chosen.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

for i in $(seq 1 20); do
    echo Request $i
    NS_EXEC([foo1], [nc -6 -p 30000 fd03::2 8090 < foo])
done

# Only one backend should be chosen.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Test load-balancing using IP src and IP dst.
check ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,ipv6_src,ipv6_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,ipv6_src,ipv6_dst)" -c) -eq 2
])

for p in $(seq 3 20); do
    h=$(printf '%02x' $p)
    NS_EXEC([foo1],[ip addr add 192.168.1.$p/24 dev foo1])
    NS_EXEC([foo1],[ip addr add fd01::$h/64 dev foo1 nodad])
done

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
for p in $(seq 3 20); do
    NS_EXEC([foo1], [nc -s 192.168.1.$p 30.0.0.1 8080 < foo])
done

bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep 172.16.1.2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 172.16.1.3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 172.16.1.4 -c)

AT_CHECK([test $bar1_ct -gt 0])
AT_CHECK([test $bar2_ct -gt 0])
AT_CHECK([test $bar3_ct -gt 0])

for p in $(seq 3 20); do
    h=$(printf '%02x' $p)
    NS_EXEC([foo1], [nc -6 -s fd01::$h fd03::2 8090 < foo])
done

bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd02::2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd02::3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd02::4 -c)

AT_CHECK([test $bar1_ct -gt 0])
AT_CHECK([test $bar2_ct -gt 0])
AT_CHECK([test $bar3_ct -gt 0])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - same subnet.])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch "foo" (192.168.1.0/24) connected to router R1.
# foo has foo1, foo2, foo3, foo4 as logical ports.
#
# Loadbalancer VIPs in 30.0.0.0/24 network. Router is needed for default
# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and
# foo4 as servers.

check_uuid ovn-nbctl create Logical_Router name=R1
check ovn-nbctl ls-add foo

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.
ADD_NAMESPACES(foo1, foo2, foo3, foo4)
for i in `seq 1 4`; do
    j=`expr $i + 1`
    ADD_VETH(foo$i, foo$i, br-int, "192.168.1.$j/24", "f0:00:00:01:02:0$j", \
             "192.168.1.1")
    check ovn-nbctl lsp-add foo foo$i \
        -- lsp-set-addresses foo$i "f0:00:00:01:02:0$j 192.168.1.$j"
done

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.3,192.168.1.4,192.168.1.5"`
check ovn-nbctl set logical_switch foo load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.3:80,192.168.1.4:80,192.168.1.5:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.1.5:80)'])

# Start webservers in 'foo2', 'foo3' and 'foo4'.
OVS_START_L7([foo2], [http])
OVS_START_L7([foo3], [http])
OVS_START_L7([foo4], [http])

dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - same subnet. - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch "foo" (fd01::/64) connected to router R1.
# foo has foo1, foo2, foo3, foo4 as logical ports.
#
# Loadbalancer VIPs in fd03::/64 network. Router is needed for default
# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and
# foo4 as servers.

check_uuid ovn-nbctl create Logical_Router name=R1
check ovn-nbctl ls-add foo

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.
ADD_NAMESPACES(foo1, foo2, foo3, foo4)
for i in `seq 1 4`; do
    j=`expr $i + 1`
    ADD_VETH(foo$i, foo$i, br-int, "fd01::$j/64", "f0:00:00:01:02:0$j", \
             "fd01::1")
    check ovn-nbctl lsp-add foo foo$i \
        -- lsp-set-addresses foo$i "f0:00:00:01:02:0$j fd01::$j"
done

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd03::1\"=\"fd01::3,fd01::4,fd01::5\"`
check ovn-nbctl set logical_switch foo load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"[[fd03::2]]:8000"'='"@<:@fd01::3@:>@:80,@<:@fd01::4@:>@:80,@<:@fd01::5@:>@:80"'

ovn-nbctl list load_balancer

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd01::5\]]:80)'])

# Start webservers in 'foo2', 'foo3' and 'foo4'.
OVS_START_L7([foo2], [http6])
OVS_START_L7([foo3], [http6])
OVS_START_L7([foo4], [http6])

dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Get the OF table numbers
snat=$(ovn-debug lflow-stage-to-oftable lr_out_snat)

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

check ovs-appctl dpctl/flush-conntrack
dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

check ovs-appctl dpctl/flush-conntrack
OVS_WAIT_FOR_OUTPUT([
dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

check_est_flows () {
    n=$(ovs-ofctl dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable lr_in_defrag) | grep \
"priority=100,tcp,metadata=0x2,nw_dst=30.0.0.2" | grep nat |
sed -n 's/.*n_packets=\([[0-9]]\{1,\}\).*/\1/p')

    echo "n_packets=$n"
    test ! -z $n
    test "$n" != 0
}

OVS_WAIT_UNTIL([check_est_flows], [check established flows])


check ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.2"

# Destroy the load balancer and create again. ovn-controller will
# clear the OF flows and re add again and clears the n_packets
# for these flows.
check ovn-nbctl destroy load_balancer $uuid
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

ovn-nbctl list load_balancer
ovn-sbctl dump-flows R2
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=$snat | \
grep 'nat(src=20.0.0.2)'])

check ovs-appctl dpctl/flush-conntrack
exp_ct1="tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)"
exp_ct2="tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
ct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')

test "x$ct1 = x$exp_ct1" && test "x$ct2 = x$exp_ct2"
], [0], [dnl
])

OVS_WAIT_UNTIL([check_est_flows], [check established flows])

check ovn-nbctl set logical_router R2 options:lb_force_snat_ip=router_ip

# Destroy the load balancer and create again. ovn-controller will
# clear the OF flows and re add again and clears the n_packets
# for these flows.
check ovn-nbctl destroy load_balancer $uuid
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

ovn-nbctl list load_balancer
ovn-sbctl dump-flows R2
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=$snat | \
grep 'nat(src=20.0.0.2)'])

rm -f wget*.log

check ovs-appctl dpctl/flush-conntrack
dnl Test load-balancing that includes L4 ports in NAT.
exp_ct1="tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)"
exp_ct2="tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"

OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
ct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
test "x$ct1 = x$exp_ct1" && test "x$ct2 = x$exp_ct2"
], [0], [dnl
])

OVS_WAIT_UNTIL([check_est_flows], [check established flows])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router hairpin scenario])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24

check ovn-nbctl set logical_router R1 options:chassis=hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "172.16.1.100/24", "1a:00:00:00:00:01", \
         "172.16.1.1")

ADD_NAMESPACES(client)
ADD_VETH(c1, client, br-ext, "172.16.1.110/24", "1a:00:00:00:00:02", \
         "172.16.1.1")

# Start webservers in 'server'.
OVS_START_L7([server], [http])

# Create a load balancer and associate to R1
check ovn-nbctl lb-add lb1 172.16.1.150:80 172.16.1.100:80
check ovn-nbctl lr-lb-add R1 lb1

check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([client], [wget 172.16.1.100 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

# Now send the traffic from client to the VIP - 172.16.1.150
check ovn-nbctl set logical_router R1 options:lb_force_snat_ip=router_ip
check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([client], [wget 172.16.1.150 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 fd72::/64 fd20::2
check ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd20::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::2/64", "f0:00:00:01:02:04", \
         "fd72::1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd72::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
"fd12::1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd30::1\"=\"fd11::2,fd12::2\"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"[[fd30::2]]:8000"'='"@<:@fd11::2@:>@:80,@<:@fd12::2@:>@:80"'

ovn-nbctl list load_balancer

# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd12::2\" \
    external_ip=\"fd30::2\" -- add logical_router R2 nat @nat


# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd12::2\]]:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget http://[[fd30::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
check ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:lb_force_snat_ip=20.0.0.2
check ovn-nbctl set logical_router R3 options:lb_force_snat_ip=20.0.0.3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid
check ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

dnl Should work with the virtual IP address through NAT
exp_ct1="tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)"
exp_ct2="tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"

OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
dnl Force SNAT should have worked.
ct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
test "x$ct1 = x$exp_ct1" && test "x$ct2 = x$exp_ct2"
], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected
# to it.  R3 has bob (fd72::/64) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd72::2/64
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
check ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:lb_force_snat_ip=fd20::2
check ovn-nbctl set logical_router R3 options:lb_force_snat_ip=fd20::3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::3/64", "f0:00:00:01:02:04", \
         "fd72::1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd72::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
"fd12::1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "fd72::4/64", "f0:00:00:01:02:06", \
         "fd72::2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd72::4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl create load_balancer vips:\"fd30::1\"=\"fd11::2,fd12::2\"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid
check ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=fd12::2)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
exp_ct1="tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
exp_ct2=tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"

OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
dnl Force SNAT should have worked.
ct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
test "x$ct1 = x$exp_ct1" && test "x$ct2 = x$exp_ct2"
], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing - Dual Stack])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24
# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2
# has alice (172.16.1.0/24 and fd72::/64) connected to it.  R3 has bob
# (172.16.1.0/24 and fd72::/64) connected to it. Note how both alice and
# bob have the same subnets behind them.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd72::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
check ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd72::2/64
check ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
check ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64
check ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
check ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
check ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
check ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1
check ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
check ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
check ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.2 fd20::2"
check ovn-nbctl set logical_router R3 options:lb_force_snat_ip="20.0.0.3 fd20::3"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo16' in switch 'foo'.
ADD_NAMESPACES(foo16)
ADD_VETH(foo16, foo16, br-int, "fd11::2/64", "f0:00:06:01:02:03", \
         "fd11::1")
check ovn-nbctl lsp-add foo foo16 \
-- lsp-set-addresses foo16 "f0:00:06:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'alice16' in switch 'alice'.
ADD_NAMESPACES(alice16)
ADD_VETH(alice16, alice16, br-int, "fd72::3/64", "f0:00:06:01:02:04", \
         "fd72::1")
check ovn-nbctl lsp-add alice alice16 \
-- lsp-set-addresses alice16 "f0:00:06:01:02:04 fd72::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bar16' in switch 'bar'.
ADD_NAMESPACES(bar16)
ADD_VETH(bar16, bar16, br-int, "fd12::2/64", "f0:00:06:01:02:05", \
"fd12::1")
check ovn-nbctl lsp-add bar bar16 \
-- lsp-set-addresses bar16 "f0:00:06:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Logical port 'bob16' in switch 'bob'.
ADD_NAMESPACES(bob16)
ADD_VETH(bob16, bob16, br-int, "fd72::4/64", "f0:00:06:01:02:06", \
         "fd72::2")
check ovn-nbctl lsp-add bob bob16 \
-- lsp-set-addresses bob16 "f0:00:06:01:02:06 fd72::4"

# Config OVN load-balancer with a VIP.
# In addition add client VIP to force premature unDNAT.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2" \
vips:172.16.1.3="192.168.1.2,192.168.2.2" vips:\"fd30::1\"=\"fd11::2,fd12::2\" \
vips:\"fd72::3\"=\"fd11::2,fd12::2\"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid
check ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2)'])
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=fd12::2)'])

# Start webservers in 'foo1', 'foo16, 'bar1', and 'bar16'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])
OVS_START_L7([foo16], [http6])
OVS_START_L7([bar16], [http6])

dnl Should work with the virtual IP address through NAT
exp_ct1="tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)"
exp_ct2="tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)"
exp_ct3="tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"
exp_ct4="tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)"

OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
    NS_EXEC([alice16], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget${i}_6.log])
done

dnl Each server should have at least one connection.
ct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
ct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')

dnl Force SNAT should have worked.
ct3=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
ct4=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')
test "x$ct1 = x$exp_ct1" && test "x$ct2 = x$exp_ct2" && test "x$ct3 = x$exp_ct3" && test "x$ct4 = x$exp_ct4"
], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in router with gateway router port])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 LB rules are applied.
#
#    foo -- R1 -- bar
#           |
#    alice ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:172.16.1.10="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R1 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"172.16.1.11:8000"'='"192.168.1.2:80,192.168.2.2:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 172.16.1.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.10) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget 172.16.1.11:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.11) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in router with gateway router port - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd01::/64), bar (fd02::/64),
# and alice (fd72::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 LB rules are applied.
#
#    foo -- R1 -- bar
#           |
#    alice ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd72::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd01::2/64", "f0:00:00:01:02:03", \
         "fd01::1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd01::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd01::3/64", "f0:00:00:01:02:06", \
         "fd01::1")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd01::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd02::2/64", "f0:00:00:01:02:04", \
         "fd02::1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd02::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::2/64", "f0:00:00:01:02:05", \
         "fd72::1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd72::2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd72::10\"=\"fd01::2,fd02::2\"`
check ovn-nbctl set logical_router R1 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"[[fd72::11]]:8000"'='"@<:@fd01::2@:>@:80,@<:@fd02::2@:>@:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd02::2\]]:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget http://[[fd72::10]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::10) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
OVS_WAIT_FOR_OUTPUT_UNQUOTED([
for i in `seq 1 10`; do
    NS_EXEC([alice1], [wget http://[[fd72::11]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::11) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - N/S])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Add external network
ADD_NAMESPACES(ext-net)
AT_CHECK([ip link add alice-ext netns alice1 type veth peer name ext-veth netns ext-net])
NS_CHECK_EXEC([ext-net], [ip link set dev ext-veth up], [0], [])
NS_CHECK_EXEC([ext-net], [ip addr add 10.0.0.1/24 dev ext-veth], [0], [])
NS_CHECK_EXEC([ext-net], [ip route add default via 10.0.0.2], [0], [])

NS_CHECK_EXEC([alice1], [ip link set dev alice-ext up], [0], [])
NS_CHECK_EXEC([alice1], [ip addr add 10.0.0.2/24 dev alice-ext], [0], [])
NS_CHECK_EXEC([alice1], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl
net.ipv4.conf.all.forwarding = 1
])

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.1.3 foo2 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 0.0.0.0/0])

# Add default route to ext-net
AT_CHECK([ovn-nbctl lr-route-add R1 10.0.0.0/24 172.16.1.2])

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

# North-South DNAT: 'alice1' pings 'foo1' using 172.16.1.3.
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that DNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.4
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.3,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.1
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Try to ping external network
NETNS_START_TCPDUMP([ext-net], [-n -c 3 -i ext-veth dst 172.16.1.3 and icmp], [ext-net])
AT_CHECK([ovn-nbctl lr-nat-del R1 snat])
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# test_connectivity_from_ext takes parameters 'vm' and 'ip'. It tests
# icmp, udp and tcp connectivity from external network to the 'vm' on
# the specified 'ip'.
test_connectivity_from_ext() {
    local vm=$1; shift
    local ip=$1; shift

    # Start listening daemon TCP connections.
    NETNS_DAEMONIZE($vm, [nc -l -k 1235], [nc-$vm-$ip-tcp.pid])

    # Ensure that vm can be pinged on the specified IP
    NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 $ip | FORMAT_PING], \
    [0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

    # Perform two consecutive UDP connections to the specified IP
    NETNS_DAEMONIZE($vm, [nc -l -u 1234], [nc-$vm-$ip-udp.pid])
    NS_CHECK_EXEC([alice1], [nc -u $ip 1234 -p 2000 -z])
    kill $(cat nc-$vm-$ip-udp.pid)

    NETNS_DAEMONIZE($vm, [nc -l -u 1234], [nc-$vm-$ip-udp.pid])
    NS_CHECK_EXEC([alice1], [nc -u $ip 1234 -p 2000 -z])
    kill $(cat nc-$vm-$ip-udp.pid)

    # Send data over TCP connection to the specified IP
    NS_CHECK_EXEC([alice1], [echo "TCP test" | nc --send-only $ip 1235])
}

# Test access from external network to the internal IP of a VM that
# has also configured DNAT
test_connectivity_from_ext foo1 192.168.1.2

# Test access from external network to the internal IP of a VM that
# does not have DNAT
test_connectivity_from_ext bar1 192.168.2.2

OVS_WAIT_UNTIL([
    total_pkts=$(cat ext-net.tcpdump | wc -l)
    test "${total_pkts}" = "3"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - N/S - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),
# and alice (fd20::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd11::3/64", "f0:00:00:01:02:06", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd11::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:04", \
         "fd12::1", "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd12::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd20::2/64", "f0:00:00:01:02:05", \
         "fd20::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd20::2"

check ovn-nbctl --wait=hv sync

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd11::3 foo2 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 ::/0])

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])

# North-South DNAT: 'alice1' pings 'foo1' using fd20::3
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that DNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd20::2,dst=fd20::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic
# from fd20::4
NS_CHECK_EXEC([foo2], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-conntrack | grep icmpv6
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::3,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from fd20::1
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

# test_connectivity_from_ext takes parameters 'vm' and 'ip'. It tests
# icmp, udp and tcp connectivity from external network to the 'vm' on
# the specified 'ip'.
test_connectivity_from_ext() {
    local vm=$1; shift
    local ip=$1; shift

    # Start listening daemon for TCP connections.
    NETNS_DAEMONIZE($vm, [nc -6 -l -k 1235], [nc-$vm-$ip-tcp.pid])

    # Ensure that vm can be pinged on the specified IP
    NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 $ip | FORMAT_PING], \
    [0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

    # Perform two consecutive UDP connections to the specified IP
    NETNS_DAEMONIZE($vm, [nc -6 -l -u 1234], [nc-$vm-$ip-udp.pid])
    NS_CHECK_EXEC([alice1], [nc -u $ip 1234 -p 2000 -z])
    kill $(cat nc-$vm-$ip-udp.pid)

    NETNS_DAEMONIZE($vm, [nc -6 -l -u 1234], [nc-$vm-$ip-udp.pid])
    NS_CHECK_EXEC([alice1], [nc -u $ip 1234 -p 2000 -z])
    kill $(cat nc-$vm-$ip-udp.pid)

    # Send data over TCP connection to the specified IP
    NS_CHECK_EXEC([alice1], [echo "TCP test" | nc --send-only $ip 1235])
}

# Test access from external network to the internal IP of a VM that
# has also configured DNAT
test_connectivity_from_ext foo1 fd11::2

# Test access from external network to the internal IP of a VM that
# does not have DNAT
test_connectivity_from_ext bar1 fd12::2

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - E/W])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.2.2 bar1 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 0.0.0.0/0])

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

echo "------ hv dump ------"
ovs-ofctl show br-int
ovs-ofctl dump-flows br-int
echo "---------------------"

# East-West No NAT: 'foo1' pings 'bar1' using 192.168.2.2.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'foo2' pings 'bar1' using 192.168.2.2.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'bar1' pings 'foo2' using 192.168.1.3.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo1' pings 'bar1' using 172.16.1.4.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo1' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo2' pings 'bar1' using 172.16.1.4.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo2' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.1,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=172.16.1.1,dst=192.168.2.2,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=192.168.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - E/W - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),
# and alice (fd20::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd11::3/64", "f0:00:00:01:02:06", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd11::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:04", \
         "fd12::1", "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd12::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd20::2/64", "f0:00:00:01:02:05", \
         "fd20::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd20::2"

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd12::2 bar1 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 ::/0])

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])

echo "------ hv dump ------"
ovs-ofctl show br-int
ovs-ofctl dump-flows br-int
echo "---------------------"

# East-West No NAT: 'foo1' pings 'bar1' using fd12::2.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'foo2' pings 'bar1' using fd12::2.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'bar1' pings 'foo2' using fd11::3.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 fd11::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West NAT: 'foo1' pings 'bar1' using fd20::4.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo1' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd20::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo2' pings 'bar1' using fd20::4.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo2' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd20::1,dst=fd12::2,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd20::1,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([conntrack zone flush after port binding release])

CHECK_CONNTRACK()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LS ls1 with two lports p1 and p2.
# Stateful ACL is added to ls1.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl ls-add ls1
check ovn-nbctl acl-add ls1 from-lport 1 1 allow-related

# Logical port 'p1' in switch 'ls1'.
ADD_NAMESPACES(p1)
ADD_VETH(p1, p1, br-int, "192.168.1.10/24", "00:00:00:00:00:10")
check ovn-nbctl lsp-add ls1 p1 \
-- lsp-set-addresses p1 "00:00:00:00:00:10 192.168.1.10"

# Logical port 'p2' in switch 'ls1'.
check ovn-nbctl lsp-add ls1 p2 \
-- lsp-set-addresses p2 "00:00:00:00:00:20 192.168.1.20"

check ovn-nbctl --wait=hv sync

zone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep p1 | cut -d ' ' -f2)

# ping from p1 to p2
NS_CHECK_EXEC([p1], [ping -q -c 1 -w1 192.168.1.20 > /dev/null], [1])

# check conntrack zone has icmp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(192.168.1.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.10,dst=192.168.1.20,id=<cleared>,type=8,code=0),reply=(src=192.168.1.20,dst=192.168.1.10,id=<cleared>,type=0,code=0),zone=<cleared>
])

# release port binding
check ovs-vsctl clear interface ovs-p1 external_ids

# check conntrack zone is flushed
OVS_WAIT_WHILE([ovs-appctl dpctl/dump-conntrack zone=$zone_id | grep .])

# ls1 should not be a local datapath anymore since ovs-p1 binding removed
OVN_CLEANUP_CONTROLLER([hv1], [], [], [ls1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LSs IGMP and MLD])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovnigmp IP-multicast])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two independent logical switches (sw1 and sw2).
# sw1:
#   - subnet 10.0.0.0/8
#   - 2 ports (sw1-p1 - sw1-p2)
# sw2:
#   - subnet 20.0.0.0/8
#   - 2 port (sw2-p1 - sw2-p2)
#   - IGMP Querier from 20.0.0.254
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add sw2

for i in `seq 1 2`
do
    ADD_NAMESPACES(sw1-p$i)
# Only send 1 membership report as second one might be received after flushing IGMP groups
# causing test to fail
    NS_CHECK_EXEC([sw1-p$i], [sysctl -w net.ipv4.igmp_qrv=1], [0], [dnl
net.ipv4.igmp_qrv = 1
])
    ADD_VETH(sw1-p$i, sw1-p$i, br-int, "10.0.0.$i/24", "00:00:00:00:01:0$i", \
            "10.0.0.254")
    check ovn-nbctl lsp-add sw1 sw1-p$i \
        -- lsp-set-addresses sw1-p$i "00:00:00:00:01:0$i 10.0.0.$i"
done

for i in `seq 1 2`
do
    ADD_NAMESPACES(sw2-p$i)
    ADD_VETH(sw2-p$i, sw2-p$i, br-int, "20.0.0.$i/24", "00:00:00:00:02:0$i", \
            "20.0.0.254")
    check ovn-nbctl lsp-add sw2 sw2-p$i \
        -- lsp-set-addresses sw2-p$i "00:00:00:00:02:0$i 20.0.0.$i"
done

# Enable IGMP snooping on sw1.
check ovn-nbctl set Logical_Switch sw1 other_config:mcast_querier="false"
check ovn-nbctl set Logical_Switch sw1 other_config:mcast_snoop="true"
check ovn-nbctl --wait=hv sync

group_v4="239.0.1.68"
# Inject IGMP Join for v4 group on sw1-p1.
NS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v4}/32 autojoin], [0])

# Inject IGMP Join for v4 group on sw1-p2
NS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v4}/32 autojoin], [0])

# Check that the IGMP Group is learned.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "2"
])

# Inject IGMP Leave for v4 group on sw1-p2.
NS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v4}/32], [0])

# Check that only one port is left in the group.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "1"
])

# Flush IGMP groups.
check ovn-sbctl ip-multicast-flush sw1
check ovn-nbctl --wait=hv -t 3 sync
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    test "${total_entries}" = "0"
])

group_v6="ff0a:dead:beef::1"
group_v6_str="ff0a\:dead\:beef\:\:1"
# Inject MLD Join for ff0a:dead:beef::1 on sw1-p1
NS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v6}/64 autojoin], [0])

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p2
NS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v6}/64 autojoin], [0])

# Check that the MLD Group is learned.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "2"
])

# Inject IGMP Leave for v6 group on sw1-p2.
NS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v6}/64 autojoin], [0])

# Check that only one port is left in the group.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "1"
])

# Enable IGMP & MLD snooping and querier on sw2 and set query interval to
# minimum.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip4_src="20.0.0.254" \
    other_config:mcast_ip6_src="2000::fe"

# Check that v4 queries are generated.
NETNS_START_TCPDUMP([sw2-p1], [-n -c 2 -i sw2-p1 igmp], [sw2-p1-v4])

OVS_WAIT_UNTIL([
    total_queries=`grep "igmp query" -c sw2-p1-v4.tcpdump`
    test "${total_queries}" = "2"
])

# Check that v6 queries are generated (ip6 next header == Hop-By-Hop and
# icmpv6 type == MLD Query).
NETNS_START_TCPDUMP([sw2-p1], [-n -c 2 -i sw2-p1 ip6[[6]]==0 and ip6[[48]]==0x82], [sw2-p1-v6])

OVS_WAIT_UNTIL([
    total_queries=`grep "multicast listener query" -c sw2-p1-v6.tcpdump`
    test "${total_queries}" = "2"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer health checks - IPv4])
AT_KEYWORDS([lb])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

check ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1_drop sw1-p1
check ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
check ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl --reject lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

check_uuid ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw1-p1)
ADD_VETH(sw1-p1, sw1-p1, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Wait until all the services are set to offline.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep offline | wc -l`])

# Start webservers in 'sw0-p1' and 'sw1-p1'.
OVS_START_L7([sw0-p1], [http])
sw0_p1_pid_file=`cat l7_pid_file`
OVS_START_L7([sw1-p1], [http])

# Wait until the services are set to online.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep online | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip4.dst == 10.0.0.10" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80)" | wc -l`]
)
# From sw0-p2 send traffic to vip - 10.0.0.10
#dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 10`; do
        NS_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
    done

    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Stop webserver in sw0-p1
kill `cat $sw0_p1_pid_file`

# Wait until service_monitor for sw0-p1 is set to offline
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \
service_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip4.dst == 10.0.0.10" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=20.0.0.3:80)" | wc -l`]
)

ovs-appctl dpctl/flush-conntrack
# From sw0-p2 send traffic to vip - 10.0.0.10
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# trigger port binding release and check if status changed to offline
ovs-vsctl remove interface ovs-sw1-p1 external_ids iface-id
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 2 status=offline

ovs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 1 status=online

# Create udp load balancer.
check ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp
lb_udp=`ovn-nbctl lb-list | grep udp | awk '{print $1}'`

echo "lb udp uuid = $lb_udp"

ovn-nbctl list load_balancer

check ovn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

check_uuid ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer $lb_udp \
health_check @hc

check ovn-nbctl --wait=sb ls-lb-add sw0 lb2
check ovn-nbctl --wait=sb ls-lb-add sw1 lb2
check ovn-nbctl --wait=sb lr-lb-add lr0 lb2

sleep 10

ovn-nbctl list load_balancer
echo "*******Next is health check*******"
ovn-nbctl list Load_Balancer_Health_Check
echo "********************"
ovn-sbctl list service_monitor

# Wait until udp service_monitor are set to offline
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor protocol=udp | sed '/^$/d' | grep offline | wc -l`])

# Stop webserver in sw1-p1
pid_file=$(cat l7_pid_file)
NS_CHECK_EXEC([sw1-p1], [kill $(cat $pid_file)])

NETNS_START_TCPDUMP([sw0-p2], [-c 1 -neei sw0-p2 ip[[33:1]]=0x14], [rst])
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor protocol=tcp | sed '/^$/d' | grep offline | wc -l`])
NS_CHECK_EXEC([sw0-p2], [curl 10.0.0.10 -v > curl$i.log 2>&1],[7])

OVS_WAIT_UNTIL([
    n_reset=$(cat rst.tcpdump | wc -l)
    test "${n_reset}" = "1"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/Service monitor not found.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer health checks - IPv6])
AT_KEYWORDS([lb])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 2001::3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 2001::3"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 2001::4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 2001::4"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

check ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip6" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip6 && ip6.src == ::/0 && icmp6" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80" allow-related

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 2002::3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 2002::3"

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1_drop sw1-p1
check ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
check ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip6" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && icmp6" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 2001::1/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 2002::1/64
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl --reject lb-add lb1 [[2001::a]]:80 [[2001::3]]:80,[[2002::3]]:80

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\"[[2001::3]]\"=\"sw0-p1:[[2001::2]]\"
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\"[[2002::3]]\"=\"sw1-p1:[[2002::2]]\"

check_uuid ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="\[\[2001\:\:a\]\]\:80" -- add Load_Balancer . \
health_check @hc

check ovn-nbctl ls-lb-add sw0 lb1
check ovn-nbctl ls-lb-add sw1 lb1
check ovn-nbctl lr-lb-add lr0 lb1

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "2001::3/64", "50:54:00:00:00:03", \
         "2001::1")

ADD_NAMESPACES(sw1-p1)
ADD_VETH(sw1-p1, sw1-p1, br-int, "2002::3/64", "40:54:00:00:00:03", \
         "2002::1")

ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "2001::4/64", "50:54:00:00:00:04", \
         "2001::1")

# Wait until all the services are set to offline.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep offline | wc -l`])

# Start webservers in 'sw0-p1' and 'sw1-p1'.
OVS_START_L7([sw0-p1], [http6])
sw0_p1_pid_file=$(cat l7_pid_file)
OVS_START_L7([sw1-p1], [http6])

# Wait until the services are set to online.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep online | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip6.dst == 2001::a" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=[\[2001::3\]]:80,[\[2002::3\]]:80)" | wc -l`]
)

# From sw0-p2 send traffic to vip - 2001::a
for i in `seq 1 20`; do
    echo Request $i
    ovn-sbctl list service_monitor
    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2001::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Stop webserver in sw0-p1
kill `cat $sw0_p1_pid_file`

# Wait until service_monitor for sw0-p1 is set to offline
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \
service_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip6.dst == 2001::a" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=[\[2002::3\]]:80)" | wc -l`]
)

ovs-appctl dpctl/flush-conntrack
# From sw0-p2 send traffic to vip - 2001::a
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# trigger port binding release and check if status changed to offline
ovs-vsctl remove interface ovs-sw1-p1 external_ids iface-id
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 2 status=offline

ovs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 1 status=online

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/Service monitor not found.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin IPv4])
AT_SKIP_IF([test $HAVE_NC = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One logical switch with IPv4 load balancers that hairpin the traffic.
check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
check ovn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp
check ovn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp
check ovn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp
check ovn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp
check ovn-nbctl lb-add lb-ipv4 88.88.88.90 42.42.42.1
check ovn-nbctl ls-lb-add sw lb-ipv4-tcp
check ovn-nbctl ls-lb-add sw lb-ipv4-tcp-dup
check ovn-nbctl ls-lb-add sw lb-ipv4-udp
check ovn-nbctl ls-lb-add sw lb-ipv4-udp-dup
check ovn-nbctl ls-lb-add sw lb-ipv4

check ovn-nbctl lr-add rtr
check ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24
check ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ADD_NAMESPACES(lsp)
ADD_VETH(lsp, lsp, br-int, "42.42.42.1/24", "00:00:00:00:00:01", \
         "42.42.42.254")

check ovn-nbctl --wait=hv -t 3 sync

# Start IPv4 TCP server on lsp.
NETNS_DAEMONIZE([lsp], [nc -l -k 42.42.42.1 4041], [lsp0.pid])

# Check that IPv4 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 88.88.88.90 4041 -z], [0], [ignore], [ignore])

# Capture IPv4 UDP hairpinned packets.
filter="dst 42.42.42.1 and dst port 2021 and udp"
NETNS_START_TCPDUMP([lsp], [-nn -c 3 -i lsp ${filter}], [lsp])

# Generate IPv4 UDP hairpin traffic.
NS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.88 4040], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.89 4040], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.90 2021], [ignore], [ignore], [ignore])

# Check hairpin traffic.
OVS_WAIT_UNTIL([
    total_pkts=$(cat lsp.tcpdump | wc -l)
    test "${total_pkts}" = "3"
])

check ovn-nbctl pg-add pg0 lsp
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 "ip4 && ip4.dst == 10.0.0.2" drop
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "ip4 && tcp" allow-related
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "ip4 && udp" allow
check ovn-nbctl --wait=hv sync

## Check that IPv4 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin IPv6])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One logical switch with IPv6 load balancers that hairpin the traffic.
check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
check ovn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp
check ovn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp
check ovn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp
check ovn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp
check ovn-nbctl lb-add lb-ipv6 8800::0090 4200::1
check ovn-nbctl ls-lb-add sw lb-ipv6-tcp
check ovn-nbctl ls-lb-add sw lb-ipv6-tcp-dup
check ovn-nbctl ls-lb-add sw lb-ipv6-udp
check ovn-nbctl ls-lb-add sw lb-ipv6-udp-dup
check ovn-nbctl ls-lb-add sw lb-ipv6

check ovn-nbctl lr-add rtr
check ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 4200::00ff/64
check ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ADD_NAMESPACES(lsp)
ADD_VETH(lsp, lsp, br-int, "4200::1/64", "00:00:00:00:00:01", "4200::00ff", "nodad")
check ovn-nbctl --wait=hv -t 3 sync

# Start IPv6 TCP server on lsp.
NETNS_DAEMONIZE([lsp], [nc -l -k 4200::1 4041], [lsp0.pid])

# Check that IPv6 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 8800::0090 4041 -z], [0], [ignore], [ignore])

# Capture IPv6 UDP hairpinned packets.
filter="dst 4200::1 and dst port 2021 and udp"
NETNS_START_TCPDUMP([lsp], [-nn -c 3 -i lsp $filter], [lsp])

# Generate IPv6 UDP hairpin traffic.
NS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0088 4040], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0089 4040], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0090 2021], [ignore], [ignore], [ignore])

# Check hairpin traffic.
OVS_WAIT_UNTIL([
    total_pkts=$(cat lsp.tcpdump | wc -l)
    test "${total_pkts}" = "3"
])

check ovn-nbctl pg-add pg0 lsp
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "ip6 && tcp" allow-related
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "ip6 && udp" allow
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1000 "ip6" drop
check ovn-nbctl --wait=hv sync

# Check that IPv6 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL reject])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1-rej
check ovn-nbctl lsp-set-addresses sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"
check ovn-nbctl lsp-set-port-security sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"

check ovn-nbctl lsp-add sw0 sw0-p2-rej
check ovn-nbctl lsp-set-addresses sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"
check ovn-nbctl lsp-set-port-security sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

check ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip" allow-related
check ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 80" reject
check ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 90" reject

check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82" allow-related
check ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 84" reject
check ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 94" reject

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1-rej
check ovn-nbctl lsp-set-addresses sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"
check ovn-nbctl lsp-set-port-security sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1-rej)
ADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-rej)
ADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej nodad], [0])
NS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej nodad], [0])

ADD_NAMESPACES(sw1-p1-rej)
ADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

# Capture packets in sw0-p1-rej.
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej tcp], [sw0-p1-rej-ip4])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

# Now send traffic to port 84
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    n_pkt=$(ovs-ofctl dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable ls_out_acl_eval) | grep -v n_packets=0 | \
grep controller | grep tp_dst=84 -c)
    test $n_pkt -eq 1
])

OVS_WAIT_UNTIL([
    total=`cat sw0-p1-rej-ip4.tcpdump |  grep "10\.0\.0\.3" | wc -l`
    echo "total = $total"
    test "${total}" = "4"
])

NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej tcp port 80], [sw0-p2-rej-ip6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])


OVS_WAIT_UNTIL([
    total=`cat sw0-p2-rej-ip6.tcpdump |  grep "aef0::3\.80" |wc -l`
    echo "total = $total"
    test "${total}" = "2"
])
check ovn-nbctl acl-add sw1 from-lport 1004 "ip" allow-related
check ovn-nbctl acl-add sw1 to-lport 1004 "ip" allow-related
check ovn-nbctl --log acl-add pg0 to-lport 1004 "outport == @pg0 && ip && tcp && tcp.dst == 84" reject

OVS_WAIT_UNTIL([
    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])


# Now test for IPv4 UDP.
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej udp port 90], [sw0-p1-rej-udp])
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej udp port 94], [sw0-p1-rej-udp])
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable" | uniq | wc -l)
    test $c -ge 1
])

# Now test for IPv6 UDP.
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej udp port 90], [sw0-p2-rej-ip6-udp])
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej udp port 94], [sw0-p2-rej-ip6-udp])
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 94" | uniq | wc -l)
    test $c -ge 1
])

# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.
check ovn-nbctl pg-del pg0
check ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
check ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && (tcp || udp)" reject

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])

rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump
# Now test for IPv6 UDP.
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -ge 1
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL after lb - reject])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1-rej
check ovn-nbctl lsp-set-addresses sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"
check ovn-nbctl lsp-set-port-security sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"

check ovn-nbctl lsp-add sw0 sw0-p2-rej
check ovn-nbctl lsp-set-addresses sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"
check ovn-nbctl lsp-set-port-security sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej
check ovn-nbctl --apply-after-lb acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

check ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "inport == @pg0 && ip" allow-related
check ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 80" reject
check ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 90" reject

check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82" allow-related
check ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 84" reject
check ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 94" reject

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1-rej
check ovn-nbctl lsp-set-addresses sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"
check ovn-nbctl lsp-set-port-security sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1-rej)
ADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-rej)
ADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej nodad], [0])
NS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej nodad], [0])

ADD_NAMESPACES(sw1-p1-rej)
ADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

# Capture packets in sw0-p1-rej.
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej tcp], [sw0-p1-rej-ip4])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

# Now send traffic to port 84
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    n_pkt=$(ovs-ofctl dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable ls_out_acl_eval) | grep -v n_packets=0 | \
grep controller | grep tp_dst=84 -c)
    test $n_pkt -eq 1
])

OVS_WAIT_UNTIL([
    total=`cat sw0-p1-rej-ip4.tcpdump |  grep "10\.0\.0\.4" | wc -l`
    echo "total = $total"
    test "${total}" = "4"
])

NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej tcp port 80], [sw0-p2-rej-ip6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])


OVS_WAIT_UNTIL([
    total=`cat sw0-p2-rej-ip6.tcpdump | grep "aef0::3\.80" | wc -l`
    echo "total = $total"
    test "${total}" = "2"
])

kill $(pidof tcpdump)

check ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1004 "ip" allow-related
check ovn-nbctl acl-add sw1 to-lport 1004 "ip" allow-related
check ovn-nbctl --log acl-add pg0 to-lport 1004 "outport == @pg0 && ip && tcp && tcp.dst == 84" reject

OVS_WAIT_UNTIL([
    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

# Now test for IPv4 UDP.
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej udp port 90], [sw0-p1-rej-udp])
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej udp port 94], [sw0-p1-rej-udp])
NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable" | uniq | wc -l)
    test $c -ge 1
])

# Now test for IPv6 UDP.
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej udp port 90], [sw0-p2-rej-ip6-udp])
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej udp port 94], [sw0-p2-rej-ip6-udp])
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 94" | uniq | wc -l)
    test $c -ge 1
])

# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.
check ovn-nbctl pg-del pg0
check ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
check ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && (tcp || udp)" reject

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])

kill $(pidof tcpdump)
rm -f *.tcpdump

NETNS_START_TCPDUMP([sw0-p1-rej], [-nn -i sw0-p1-rej icmp], [sw0-p1-rej-icmp])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.tcpdump | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)
rm -f *.tcpdump
# Now test for IPv6 UDP.
NETNS_START_TCPDUMP([sw0-p2-rej], [-nn -i sw0-p2-rej icmp6], [sw0-p2-rej-icmp6])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.tcpdump | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -ge 1
])

kill $(pidof tcpdump)

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 prefix delegation - distributed router])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-ipv6-prefix_d])

OVN_TEST_IPV6_PREFIX_DELEGATION(DGP)
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 prefix delegation - gw router])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-ipv6-prefix_d])

OVN_TEST_IPV6_PREFIX_DELEGATION(GR)
AT_CLEANUP
])

# Tests that when an established connection sends TCP reset,
# the conntrack entry is not in established state.
OVN_FOR_EACH_NORTHD([
AT_SETUP([conntrack TCP reset])
AT_KEYWORDS([conntrack])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 rst-p1
check ovn-nbctl lsp-set-addresses rst-p1 "50:54:00:00:00:03"
check ovn-nbctl lsp-set-port-security rst-p1 "50:54:00:00:00:03"

check ovn-nbctl lsp-add sw0 rst-p2
check ovn-nbctl lsp-set-addresses rst-p2 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security rst-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop rst-p1 rst-p2
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

check ovn-nbctl pg-add pg0 rst-p1 rst-p2
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach to logical switch.
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80
check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(rst-p1)
ADD_VETH(rst-p1, rst-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(rst-p2)
ADD_VETH(rst-p2, rst-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p2) = xup])

# Start webservers in 'rst-p1'.
OVS_START_L7([rst-p1], [http])

NS_CHECK_EXEC([rst-p2], [$PYTHON $srcdir/test-tcp-rst.py --dst-port 80 --dst-ip 10.0.0.10])

# When tcp reset is sent, conntrack entry should be in the state - CLOSED or CLOSING.
# But there is a bug where tcp reset packet was not sent to the conntrack.
# This test case checks that the tcp reset packet is sent to conntrack
# and the state is not in established state.
AT_CHECK([
    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state=ESTABLISHED -c)
    test $ct_est_count -eq 0

    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state='CLOS\|TIME_WAIT' -c)
    test $ct_est_count -eq 1
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/Service monitor not found.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer for container ports])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1-lbc
check ovn-nbctl lsp-set-addresses sw0-p1-lbc "10:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p2-lbc
check ovn-nbctl lsp-set-addresses sw0-p2-lbc "10:54:00:00:00:04 10.0.0.4"

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-port1 sw0-p1-lbc 10
check ovn-nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3"

check ovn-nbctl lsp-add sw1 sw1-port2 sw0-p2-lbc 20
check ovn-nbctl lsp-set-addresses sw1-port2 "40:54:00:00:00:04 20.0.0.4"


check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1


check ovn-nbctl ls-add sw2
check ovn-nbctl lsp-add sw2 sw2-port1
check ovn-nbctl lsp-set-addresses sw2-port1 "50:54:00:00:00:03 30.0.0.3"

check ovn-nbctl lrp-add lr0 lr0-sw2 00:00:00:00:ff:03 30.0.0.1/24
check ovn-nbctl lsp-add sw2 sw2-lr0
check ovn-nbctl lsp-set-type sw2-lr0 router
check ovn-nbctl lsp-set-addresses sw2-lr0 router
check ovn-nbctl lsp-set-options sw2-lr0 router-port=lr0-sw2


check ovn-nbctl lb-add lb0 "30.0.0.10:80" "20.0.0.4:80"

check ovn-nbctl ls-lb-add sw1 lb0
check ovn-nbctl ls-lb-add sw2 lb0

ADD_NAMESPACES(sw0-p1-lbc)
ADD_VETH(sw0-p1-lbc, sw0-p1-lbc, br-int, "10.0.0.3/24", "10:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-lbc)
ADD_VETH(sw0-p2-lbc, sw0-p2-lbc, br-int, "10.0.0.4/24", "10:54:00:00:00:04", \
         "10.0.0.1")

# Create the interface for lport sw1-port1
NS_CHECK_EXEC([sw0-p1-lbc], [ip link add link sw0-p1-lbc name sw1p1 type vlan id 10], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 address 40:54:00:00:00:03], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 up], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip addr add 20.0.0.3/24 dev sw1p1], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip route delete default via 10.0.0.1 dev sw0-p1-lbc], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip route add default via 20.0.0.1 dev sw1p1], [0])

# Create the interface for lport sw1-port2
NS_CHECK_EXEC([sw0-p2-lbc], [ip link add link sw0-p2-lbc name sw1p2 type vlan id 20], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 address 40:54:00:00:00:04], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 up], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip addr add 20.0.0.4/24 dev sw1p2], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip route delete default via 10.0.0.1 dev sw0-p2-lbc], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip route add default via 20.0.0.1 dev sw1p2], [0])

# Start nc server on sw1p2 (sw0-p2-lbc is the parent)
NETNS_DAEMONIZE([sw0-p2-lbc], [nc -l -k 20.0.0.4 80], [nc0.pid])

# Send the packet to backend
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])

# Send the packet to VIP.
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])

# Now add an ACL in sw1.
check ovn-nbctl --wait=hv acl-add sw1 to-lport 2002 "ip" allow-related
# Send the packet to backend
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])

# Send the packet to VIP.
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer and firewall tuple conflict IPv4])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch connetected to one logical router.
# 2 VMs, one used as backend for a load balancer.

check ovn-nbctl                                                  \
    -- lr-add rtr                                                \
    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24        \
    -- ls-add ls                                                 \
    -- lsp-add ls ls-rtr                                         \
    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls-rtr router                                \
    -- lsp-set-options ls-rtr router-port=rtr-ls                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- lb-add lb-test 66.66.66.66:666 42.42.42.2:4242 tcp        \
    -- ls-lb-add ls lb-test

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Start IPv4 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])

# Make sure connecting to the VIP works.
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2000 -z], [0], [ignore], [ignore])

# Start IPv4 TCP connection to VIP from vm2.
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect two entries:
# - one in vm1's zone (firewall)
# - one in vm2's zone (dnat)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=42\.42\.42\.3" |                                    \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Start IPv4 TCP connection to backend IP from vm2 which would require
# additional source port translation to avoid a tuple conflict.
NS_CHECK_EXEC([vm2], [nc 42.42.42.2 4242 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect three entries:
# - one in vm1's zone (firewall) - reused from the previous connection.
# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.
# - one in vm2's zone (firewall + additional all-zero SNAT)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=42\.42\.42\.3" |                                    \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer and firewall tuple conflict IPv6])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch connetected to one logical router.
# 2 VMs, one used as backend for a load balancer.

check ovn-nbctl                                                  \
    -- lr-add rtr                                                \
    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 4242::1/64           \
    -- ls-add ls                                                 \
    -- lsp-add ls ls-rtr                                         \
    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls-rtr router                                \
    -- lsp-set-options ls-rtr router-port=rtr-ls                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- lb-add lb-test [[6666::1]]:666 [[4242::2]]:4242 tcp       \
    -- ls-lb-add ls lb-test

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "4242::2/64", "00:00:00:00:00:01", "4242::1", "nodad")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "4242::3/64", "00:00:00:00:00:02", "4242::1", "nodad")

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Start IPv6 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])

# Make sure connecting to the VIP works.
NS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2000 -z], [0], [ignore], [ignore])

# Start IPv6 TCP connection to VIP from vm2.
NS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect two entries:
# - one in vm1's zone (firewall)
# - one in vm2's zone (dnat)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=4242::3" |                                         \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Start IPv6 TCP connection to backend IP from vm2 which would require
# additional source port translation to avoid a tuple conflict.
NS_CHECK_EXEC([vm2], [nc 4242::2 4242 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect three entries:
# - one in vm1's zone (firewall) - reused from the previous connection.
# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.
# - one in vm2's zone (firewall + additional all-zero SNAT)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=4242::3" |                                          \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

# When a lport is released on a chassis, ovn-controller was
# not clearing some of the flowss in the table 33 leading
# to packet drops if ct() is hit.
# Make sure that those flows are cleared properly.
OVN_FOR_EACH_NORTHD([
AT_SETUP([Test packet drops due to incorrect flows in physical table 33])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1-f
check ovn-nbctl lsp-set-addresses sw0-p1-f "10:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p2-f
check ovn-nbctl lsp-set-addresses sw0-p2-f "10:54:00:00:00:04 10.0.0.4"

check ovn-nbctl lsp-add sw0 sw0-p3-f
check ovn-nbctl lsp-set-addresses sw0-p3-f "10:54:00:00:00:05 10.0.0.5"

# Add ACL with allow-ralated so that conntrack is hit.

check ovn-nbctl acl-add sw0 from-lport 1002 "ip" allow-related
check ovn-nbctl acl-add sw0 to-lport 1002 "ip" allow-related

ADD_NAMESPACES(sw0-p1-f)
ADD_VETH(sw0-p1-f, sw0-p1-f, br-int, "10.0.0.3/24", "10:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-f)
ADD_VETH(sw0-p2-f, sw0-p2-f, br-int, "10.0.0.4/24", "10:54:00:00:00:04", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p3-f)
ADD_VETH(sw0-p3-f, sw0-p3-f, br-int, "10.0.0.5/24", "10:54:00:00:00:05", \
         "10.0.0.1")

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1-f) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])

# Send ping from sw0-p1-f to sw0-p3-f
NS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-vsctl remove interface ovs-sw0-p2-f external_ids iface-id
ovs-vsctl remove interface ovs-sw0-p3-f external_ids iface-id

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xdown])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xdown])

ovs-vsctl set interface ovs-sw0-p3-f external_ids:iface-id=sw0-p3-f
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])

# Send ping from sw0-p1-f to sw0-p3-f again and it should work.
NS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP symmetric reply])
AT_KEYWORDS([ecmp])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Alice is connected to gateway router R1. R1 is connected to two "external"
# routers, R2 and R3 via an "ext" switch.
# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2
# and one through R3, to Bob.
#
#     alice -- R1 -- ext ---- R2
#                     |         \
#                     |           bob
#                     |         /
#                     + ----- R3
#
# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that
# all response traffic from Alice is routed through R2 as well.

check_uuid ovn-nbctl create Logical_Router name=R1 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R2
check_uuid ovn-nbctl create Logical_Router name=R3

check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add ext

# connect alice to R1
check ovn-nbctl lrp-add R1 alice 00:00:01:01:02:03 10.0.0.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses='"00:00:01:01:02:03"'

# connect bob to R2
check ovn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 172.16.0.2/16
check ovn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \
    type=router options:router-port=R2_bob addresses='"00:00:02:01:02:03"'

# connect bob to R3
check ovn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 172.16.0.3/16
check ovn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \
    type=router options:router-port=R3_bob addresses='"00:00:02:01:02:04"'

# Connect R1 to ext
check ovn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \
    type=router options:router-port=R1_ext addresses='"00:00:04:01:02:03"'

# Connect R2 to ext
check ovn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \
    type=router options:router-port=R2_ext addresses='"00:00:04:01:02:04"'

# Connect R3 to ext
check ovn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 20.0.0.3/24
check ovn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \
    type=router options:router-port=R3_ext addresses='"00:00:04:01:02:05"'

# Install ECMP routes for alice.
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 10.0.0.0/24 20.0.0.2
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 10.0.0.0/24 20.0.0.3

# Static Routes
check ovn-nbctl lr-route-add R2 10.0.0.0/24 20.0.0.1
check ovn-nbctl lr-route-add R3 10.0.0.0/24 20.0.0.1

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "10.0.0.2/24", "f0:00:00:01:02:04", \
         "10.0.0.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 10.0.0.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.0.1/16", "f0:00:00:01:02:06", \
         "172.16.0.2")
check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.0.1"

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovs-ofctl dump-flows br-int'

NETNS_DAEMONIZE([alice1], [nc -l -k 80], [alice1.pid])
NS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present. We should not try to predict
# the tunnel key for the output port, so we strip it from the labels
# and just ensure that the known ethernet address is present.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.0.1,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=172.16.0.1,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0x401020400000000
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)
])

# Ensure datapaths show conntrack states as expected
# Like with conntrack entries, we shouldn't try to predict
# port binding tunnel keys. So omit them from expected labels.
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl
2
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+trk).*ct_label(0x401020400000000)' -c], [0], [dnl
2
])

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# Change bob1 L2 address anche check the reply is properly updated.
check ovn-nbctl set Logical_Router_Port R2_ext mac='"00:00:10:01:02:04"'
check ovn-nbctl set Logical_Switch_Port r2-ext \
     type=router options:router-port=R2_ext addresses='"00:00:10:01:02:04"'

# Wait for ovn-controller before sending traffic
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl
2
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl
2
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.0.1,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=172.16.0.1,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])
# Check entries in table 76 and 77 expires w/o traffic
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=OFTABLE_ECMP_NH_MAC, n_packets') -eq 0
])
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=OFTABLE_ECMP_NH, n_packets') -eq 0
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

NS_CHECK_EXEC([bob1], [ip r d default via 172.16.0.2 dev bob1], [0])
NS_CHECK_EXEC([bob1], [ip r a default via 172.16.0.3 dev bob1], [0])

NETNS_DAEMONIZE([bob1], [nc -l -k 8080], [bob1.pid])
NS_CHECK_EXEC([alice1], [nc -z 172.16.0.1 8080], [0])
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.0.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x401020500000000 | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020500000000,protoinfo=(state=<cleared>)
])

# Now remove one ECMP route and check that traffic is still being conntracked.
check ovn-nbctl --policy="src-ip" lr-route-del R1 10.0.0.0/24 20.0.0.3
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-appctl dpctl/flush-conntrack])
NETNS_DAEMONIZE([bob1], [nc -l -k 8081], [bob2.pid])
NS_CHECK_EXEC([alice1], [nc -z 172.16.0.1 8081], [0])
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.0.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x401020500000000 | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020500000000,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP IPv6 symmetric reply])
AT_KEYWORDS([ecmp])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Alice is connected to gateway router R1. R1 is connected to two "external"
# routers, R2 and R3 via an "ext" switch.
# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2
# and one through R3, to Bob.
#
#     alice -- R1 -- ext ---- R2
#                     |         \
#                     |           bob
#                     |         /
#                     + ----- R3
#
# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that
# all response traffic from Alice is routed through R2 as well.

check_uuid ovn-nbctl create Logical_Router name=R1 options:chassis=hv1
check_uuid ovn-nbctl create Logical_Router name=R2
check_uuid ovn-nbctl create Logical_Router name=R3

check ovn-nbctl ls-add alice
check ovn-nbctl ls-add bob
check ovn-nbctl ls-add ext

# connect alice to R1
check ovn-nbctl lrp-add R1 alice 00:00:01:01:02:03 fd01::1/64
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses='"00:00:01:01:02:03"'

# connect bob to R2
check ovn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 fd07::2/64
check ovn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \
    type=router options:router-port=R2_bob addresses='"00:00:02:01:02:03"'

# connect bob to R3
check ovn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 fd07::3/64
check ovn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \
    type=router options:router-port=R3_bob addresses='"00:00:02:01:02:04"'

# Connect R1 to ext
check ovn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 fd02::1/64
check ovn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \
    type=router options:router-port=R1_ext addresses='"00:00:04:01:02:03"'

# Connect R2 to ext
check ovn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 fd02::2/64
check ovn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \
    type=router options:router-port=R2_ext addresses='"00:00:04:01:02:04"'

# Connect R3 to ext
check ovn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 fd02::3/64
check ovn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \
    type=router options:router-port=R3_ext addresses='"00:00:04:01:02:05"'

# Install ECMP routes for alice.
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 fd01::/126 fd02::2
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 fd01::/126 fd02::3

# Static Routes
check ovn-nbctl lr-route-add R2 fd01::/64 fd02::1
check ovn-nbctl lr-route-add R3 fd01::/64 fd02::1

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
# Only send 1 router solicitation as any additional ones can cause datapath
# flows to get evicted, causing unexpected failures below.
NS_CHECK_EXEC([alice1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl
net.ipv6.conf.default.router_solicitations = 1
])
ADD_VETH(alice1, alice1, br-int, "fd01::2/64", "f0:00:00:01:02:04", \
         "fd01::1", "nodad")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd01::2"
# Add neighbour MAC address to avoid sending IPv6 NS messages which could
# cause datapath flows to be evicted
NS_CHECK_EXEC([alice1], [ip -6 neigh add fd01::1 lladdr 00:00:01:01:02:03 dev alice1], [0])

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
# Only send 1 router solicitation as any additional ones can cause datapath
# flows to get evicted, causing unexpected failures below.
NS_CHECK_EXEC([bob1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl
net.ipv6.conf.default.router_solicitations = 1
])
ADD_VETH(bob1, bob1, br-int, "fd07::1/64", "f0:00:00:01:02:06", \
         "fd07::2", "nodad")
# Add neighbour MAC addresses to avoid sending IPv6 NS messages which could
# cause datapath flows to be evicted
NS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::2 lladdr 00:00:02:01:02:03 dev bob1], [0])
NS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::3 lladdr 00:00:01:01:02:04 dev bob1], [0])

check ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd07::1"

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovs-ofctl dump-flows br-int'

NETNS_DAEMONIZE([alice1], [nc -6 -l -k 80], [alice1.pid])
NS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 fd01::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Ensure datapaths show conntrack states as expected
# Like with conntrack entries, we shouldn't try to predict
# port binding tunnel keys. So omit them from expected labels.
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl
2
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+trk).*ct_label(0x401020400000000)' -c], [0], [dnl
2
])

# Ensure conntrack entry is present. We should not try to predict
# the tunnel key for the output port, so we strip it from the labels
# and just ensure that the known ethernet address is present.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd01::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd07::1,dst=fd01::2,id=<cleared>,type=128,code=0),reply=(src=fd01::2,dst=fd07::1,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0x401020400000000
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)
])

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Change bob1 L2 address anche check the reply is properly updated.
check ovn-nbctl set Logical_Router_Port R2_ext mac='"00:00:10:01:02:04"'
check ovn-nbctl --wait=hv set Logical_Switch_Port r2-ext \
     type=router options:router-port=R2_ext addresses='"00:00:10:01:02:04"'

NS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 fd01::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl
2
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl
2
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd01::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd07::1,dst=fd01::2,id=<cleared>,type=128,code=0),reply=(src=fd01::2,dst=fd07::1,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])

# Check entries in table 76 and 77 expires w/o traffic
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=OFTABLE_ECMP_NH_MAC, n_packets') -eq 0
])
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=OFTABLE_ECMP_NH, n_packets') -eq 0
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

NETNS_DAEMONIZE([bob1], [nc -6 -l -k 8080], [bob1.pid])
NS_CHECK_EXEC([alice1], [nc -6 -z fd07::1 8080], [0])
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 fd07::1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd07::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])

# Now remove one ECMP route and check that traffic is still being conntracked.
check ovn-nbctl --policy="src-ip" lr-route-del R1 fd01::/126 fd02::3
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-appctl dpctl/flush-conntrack])
NETNS_DAEMONIZE([bob1], [nc -6 -l -k 8081], [bob2.pid])
NS_CHECK_EXEC([alice1], [nc -6 -z fd07::1 8081], [0])
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 fd07::1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd07::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controller I-P handling when ovs iface ofport is -1])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "10:54:00:00:00:03 10.0.0.3"

ovs-vsctl add-port br-int p1 -- \
    set Interface p1 external_ids:iface-id=sw0-port1 -- \
    set Interface p1 type=internal

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xup])
ovs-vsctl set interface p1 type=\"\"
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xdown])

OVN_CLEANUP_CONTROLLER([hv1], [], [], [sw0])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/could not open network device p1*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ARP resolution for SNAT IP])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis rp-public hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.1.0/24
check ovn-nbctl lr-nat-add R1 snat 172.16.1.20 192.168.1.2

ADD_NAMESPACES(sw01-x)
ADD_VETH(sw01-x, sw01-x, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01-x \
    -- lsp-set-addresses sw01-x "f0:00:00:01:02:03 192.168.1.2"

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw01-x) = xup])

ADD_NAMESPACES(ext-foo)
ADD_VETH(ext-foo, ext-foo, br-ext, "172.16.1.100/24", "00:10:10:01:02:13", \
         "172.16.1.1")

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

check ovn-nbctl --wait=hv sync

# Send ping from sw01-x to ext-foo.
NS_CHECK_EXEC([sw01-x], [ping -q -c 3 -i 0.3 -w 2 172.16.1.100 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.100,id=<cleared>,type=8,code=0),reply=(src=172.16.1.100,dst=172.16.1.20,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([egress qos])
AT_KEYWORDS([ovn-egress-qos])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-public])
ADD_BR([br-ext])

ovs-ofctl add-flow br-public action=normal
ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(sw02)
ADD_VETH(sw02, sw02, br-int, "192.168.1.3/24", "f0:00:00:01:02:44")
check ovn-nbctl lsp-add sw0 sw02 \
    -- lsp-set-addresses sw02 "f0:00:00:01:02:44 192.168.1.3"

check ovn-nbctl ls-add sw1

ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.4.2/24", "f0:00:00:01:04:03")
check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:01:04:03 192.168.4.2"

ADD_NAMESPACES(sw12)
ADD_VETH(sw12, sw12, br-int, "192.168.4.3/24", "f0:00:00:03:04:03")
check ovn-nbctl lsp-add sw1 sw12 \
    -- lsp-set-addresses sw11 "f0:00:00:03:04:03 192.168.4.3"

ADD_NAMESPACES(public)
ADD_VETH(public, public, br-public, "192.168.2.2/24", "f0:00:00:01:02:05")
AT_CHECK([ovs-vsctl remove interface ovs-public external-ids iface-id=public])

# Skip this test if the datapath interface does not support linux-htb
AT_SKIP_IF([! ovs-appctl qos/show-types ovs-public | grep -q linux-htb])

ADD_NAMESPACES(ext)
ADD_VETH(ext, ext, br-ext, "192.168.3.2/24", "f0:00:00:01:02:06")
AT_CHECK([ovs-vsctl remove interface ovs-ext external-ids iface-id=ext])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=public:br-public,ext:br-ext])
check ovn-nbctl lsp-add sw0 public \
        -- lsp-set-addresses public unknown \
        -- lsp-set-type public localnet \
        -- lsp-set-options public network_name=public

check ovn-nbctl lsp-add sw1 ext \
        -- lsp-set-addresses ext unknown \
        -- lsp-set-type ext localnet \
        -- lsp-set-options ext network_name=ext

AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_min_rate=200000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_max_rate=300000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_burst=3000000])

AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_min_rate=400000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_max_rate=600000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_burst=6000000])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 200Kbit ceil 300Kbit burst 375000b cburst 375000b'])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-ext'])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* rate 400Kbit ceil 600Kbit burst 750000b cburst 750000b'])

# The same now with ovs db read only
#
AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_min_rate=400000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_max_rate=600000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_burst=6000000])
OVS_WAIT_UNTIL([test "$(tc class show dev ovs-ext | grep 'class htb')" == ""])

sleep_ovsdb .

AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_min_rate=400000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_max_rate=600000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_burst=6000000])
wake_up_ovsdb .

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 200Kbit ceil 300Kbit burst 375000b cburst 375000b'])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-ext'])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* rate 400Kbit ceil 600Kbit burst 750000b cburst 750000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_min_rate=200000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_max_rate=300000])

OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 12Kbit ceil 34359Mbit burst 375000b cburst 373662b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_burst=3000000])
OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-public')" = ""])

AT_CHECK([ovn-nbctl set Logical_Switch_Port ext options:qos_max_rate=800000])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* rate 400Kbit ceil 800Kbit burst 750000b cburst 750000b'])

AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_min_rate=400000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_max_rate=800000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_burst=6000000])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 400Kbit ceil 800Kbit burst 750000b cburst 750000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_min_rate=400000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_max_rate=800000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port ext options qos_burst=6000000])

OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-ext')" = ""])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 400Kbit ceil 800Kbit burst 750000b cburst 750000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_min_rate=400000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_max_rate=800000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_burst=6000000])

OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-public')" = ""])

AT_CHECK([ovn-nbctl set Logical_Switch_Port sw01 options:qos_min_rate=200000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw01 options:qos_max_rate=350000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw01 options:qos_burst=3000000])

AT_CHECK([ovn-nbctl set Logical_Switch_Port sw11 options:qos_min_rate=400000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw11 options:qos_max_rate=700000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw11 options:qos_burst=6000000])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 200Kbit ceil 350Kbit burst 375000b cburst 374999b'])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-ext'])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* prio 0 rate 400Kbit ceil 700Kbit burst 750000b cburst 749999b'])

AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_min_rate=300000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_max_rate=500000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_burst=3000000])

OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* prio 0 rate 300Kbit ceil 500Kbit burst 375000b cburst 375000b'])

AT_CHECK([ovn-nbctl set Logical_Switch_Port sw12 options:qos_min_rate=400000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw12 options:qos_max_rate=500000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw12 options:qos_burst=3000000])

OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* prio 0 rate 400Kbit ceil 500Kbit burst 375000b cburst 375000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw02 options qos_min_rate=300000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw02 options qos_max_rate=500000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw02 options qos_burst=3000000])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 200Kbit ceil 350Kbit burst 375000b cburst 374999b'])
OVS_WAIT_UNTIL([test "$(tc class show dev ovs-public | \
                grep 'class htb .* prio 0 rate 300Kbit ceil 500Kbit burst 375000b cburst 375000b')" = ""])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw01 options qos_min_rate=200000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw01 options qos_max_rate=350000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw01 options qos_burst=3000000])
OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-public')" = ""])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-ext'])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* prio 0 rate 400Kbit ceil 700Kbit burst 750000b cburst 749999b'])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* prio 0 rate 400Kbit ceil 500Kbit burst 375000b cburst 375000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw11 options qos_min_rate=400000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw11 options qos_max_rate=700000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw11 options qos_burst=6000000])

OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-ext'])
OVS_WAIT_UNTIL([test "$(tc class show dev ovs-ext | \
                grep 'class htb .* prio 0 rate 400Kbit ceil 700Kbit burst 750000b cburst 749999b')" = ""])
OVS_WAIT_UNTIL([tc class show dev ovs-ext | \
                grep -q 'class htb .* prio 0 rate 400Kbit ceil 500Kbit burst 375000b cburst 375000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw12 options qos_min_rate=400000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw12 options qos_max_rate=500000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port sw12 options qos_burst=3000000])

OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-ext')" = ""])

AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_min_rate=5000000000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_max_rate=6000000000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port sw02 options:qos_burst=1000000])

OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* prio 0 rate 5Gbit ceil 6Gbit burst 125000b cburst 124500b'])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([BFD])
AT_SKIP_IF([test $HAVE_BFDD_BEACON = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-bfd])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \
    -- lrp-set-gateway-chassis rp-public hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.2.2/24", "f0:00:00:02:02:03", \
         "192.168.2.1")
check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03 192.168.2.2"

ADD_NAMESPACES(server)
NS_CHECK_EXEC([server], [ip link set dev lo up])
ADD_VETH(s1, server, br-ext, "172.16.1.50/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
NS_CHECK_EXEC([server], [ip addr add 1000::b/64 dev s1])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

NETNS_DAEMONIZE([server], [bfdd-beacon  --nofork --tee --listen=172.16.1.50 >beacon.stdout 2>&1], [beacon.pid])
OVS_WAIT_UNTIL([grep -q "Listening for BFD connections" beacon.stdout])
NS_CHECK_EXEC([server], [bfdd-control allow 172.16.1.1], [0], [dnl
Allowing connections from 172.16.1.1
])

check ovn-nbctl --bfd lr-route-add R1 100.0.0.0/8 172.16.1.50 rp-public
uuid=$(fetch_column nb:bfd _uuid logical_port="rp-public")
route_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix="100.0.0.0/8")
check ovn-nbctl --wait=hv sync

wait_column "up" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 |grep lr_in_ip_routing |grep 'ip4.dst == 100.0.0.0/8' |grep -q 172.16.1.50])

# un-associate the bfd connection and the static route
check ovn-nbctl clear logical_router_static_route $route_uuid bfd
wait_column "admin_down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])

check ovn-nbctl --bfd lr-policy-add R1 100 "ip4.src == 200.0.0.0/8" reroute 172.16.1.50,172.16.1.60
wait_column "up" nb:bfd status dst_ip=172.16.1.50
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 | grep lr_in_policy_ecmp | grep -q 172.16.1.50])

check ovn-nbctl lr-policy-del R1
wait_column "admin_down" nb:bfd status dst_ip=172.16.1.50
wait_column "admin_down" nb:bfd status dst_ip=172.16.1.60
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])

NETNS_START_TCPDUMP([server], [-nni s1 udp port 3784 -Q in], [bfd])
sleep 5
kill $(pidof tcpdump)
AT_CHECK([grep -qi bfd bfd.tcpdump],[1])

uuid=$(fetch_column nb:bfd _uuid dst_ip="172.16.1.60")
check ovn-nbctl destroy bfd $uuid
uuid=$(fetch_column nb:bfd _uuid logical_port="rp-public")

# restart the connection
check ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid
check ovn-nbctl --bfd lr-policy-add R1 100 "ip4.src == 200.0.0.0/8" reroute 172.16.1.50
wait_column "up" nb:bfd status logical_port=rp-public

OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 |grep lr_in_ip_routing |grep 'ip4.dst == 100.0.0.0/8' |grep -q 172.16.1.50])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 |grep lr_in_policy |grep 'ip4.src == 200.0.0.0/8' |grep -q 172.16.1.50])

# stop bfd endpoint
NS_CHECK_EXEC([server], [bfdd-control stop], [0], [dnl
stopping
])
wait_column "down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([test "$(ovn-sbctl dump-flows R1 |grep lr_in_ip_routing |grep 'ip4.dst == 100.0.0.0/8' |grep 172.16.1.50)" = ""])
OVS_WAIT_UNTIL([test "$(ovn-sbctl dump-flows R1 |grep lr_in_policy |grep 'ip4.src == 200.0.0.0/8' |grep 172.16.1.50)" = ""])

# switch to gw router configuration
check ovn-nbctl clear logical_router_static_route $route_uuid bfd
check ovn-nbctl lr-policy-del R1
check ovn-nbctl clear logical_router_port rp-public gateway_chassis
check ovn-nbctl set logical_router R1 options:chassis=hv1
check ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid

# restart bfdd
NETNS_DAEMONIZE([server], [bfdd-beacon  --nofork --tee --listen=172.16.1.50 >beacon.stdout 2>&1], [beacon.pid])
OVS_WAIT_UNTIL([grep -q "Listening for BFD connections" beacon.stdout])
NS_CHECK_EXEC([server], [bfdd-control allow 172.16.1.1], [0], [dnl
Allowing connections from 172.16.1.1
])

wait_column "up" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 |grep lr_in_ip_routing |grep 'ip4.dst == 100.0.0.0/8' |grep -q 172.16.1.50])

check ovn-nbctl clear logical_router_static_route $route_uuid bfd
wait_column "admin_down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])
check ovn-nbctl destroy bfd $uuid
check_row_count bfd 0

# create reroute route policy
check ovn-nbctl --bfd lr-policy-add R1 100 "ip4.src == 210.0.0.0/8" reroute 172.16.1.50
wait_column "up" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 |grep lr_in_policy |grep 'ip4.src == 210.0.0.0/8' |grep -q 172.16.1.50])

check ovn-nbctl lr-policy-del R1
wait_column "admin_down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])
uuid=$(fetch_column nb:bfd _uuid logical_port="rp-public")

# stop bfd endpoint
NS_CHECK_EXEC([server], [bfdd-control stop], [0], [dnl
stopping
])

# remove bfd entry
check ovn-nbctl destroy bfd $uuid
check_row_count bfd 0
NETNS_START_TCPDUMP([server], [-nni s1 udp port 3784 -Q in], [bfd])
sleep 5
kill $(pidof tcpdump)
AT_CHECK([grep -qi bfd bfd.tcpdump],[1])

uuid_v6=$(ovn-nbctl create bfd logical_port=rp-public dst_ip=\"1000::b\")
check ovn-nbctl lr-route-add R1 2000::/64 1000::b
route_uuid_v6=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"2000::/64\")
check ovn-nbctl set logical_router_static_route $route_uuid_v6 bfd=$uuid_v6
check ovn-nbctl --wait=hv sync
NETNS_DAEMONIZE([server], [bfdd-beacon  --nofork --tee --listen=1000::b >beacon.stdout 2>&1], [beacon.pid])
OVS_WAIT_UNTIL([grep -q "Listening for BFD connections" beacon.stdout])
NS_CHECK_EXEC([server], [bfdd-control allow 1000::a], [0], [dnl
Allowing connections from 1000::a
])

wait_column "up" nb:bfd status logical_port=rp-public
check ovn-nbctl destroy bfd $uuid_v6

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([No ct_state matches in dp flows when no ACLs in an LS])
AT_KEYWORDS([no ct_state match])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"


# Create the second logical switch with one port and configure some ACLs.
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "ip" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "ip" allow-related

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")


ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

ADD_NAMESPACES(sw1-p1)
ADD_VETH(sw1-p1, sw1-p1, br-int, "20.0.0.4/24", "30:54:00:00:00:04", \
         "20.0.0.1")

wait_for_ports_up

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

# sw1-p1 may send IPv6 traffic.  So filter this out.  Since sw1-p1 has
# ACLs configured, the datapath flows for the packets from sw1-p1 will have
# matches on ct_state and ct_label fields.
# Since sw0 doesn't have any ACLs, there should be no match on ct fields.

echo ""

ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl
0
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl
0
])

# Add an ACL to sw0.
check ovn-nbctl --wait=hv acl-add sw0 to-lport 1002 ip allow-related

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [0], [ignore])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [0], [ignore])

# Clear ACL for sw0
check ovn-nbctl --wait=hv clear logical_switch sw0 acls

check ovs-appctl revalidator/purge

check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl
0
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl
0
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT LR hairpin IPv4])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# Logical network:
# Two VMs
#   * VM1 with IP address 192.168.100.5
#   * VM2 with IP address 192.168.100.6
# The VMs connect to logical switch ls1.
#
# An external router with IP address 172.18.1.2. We simulate this with a network namespace.
# There will be no traffic going here in this test.
# The external router connects to logical switch ls-pub
#
# One logical router (lr1) connects to ls1 and ls-pub. The router port connected to ls-pub is
# a gateway port.
#   * The subnet connected to ls1 is 192.168.100.0/24. The Router IP address is 192.168.100.1
#   * The subnet connected to ls-pub is 172.18.1.0/24. The Router IP address is 172.168.1.1
# lr1 has the following attributes:
#   * It has a "default" static route that sends traffic out the gateway router port.
#   * It has a DNAT rule that translates 172.18.2.10 to 192.168.100.6 (VM2)
#
# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.10 reaches VM2.

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 "00:00:00:00:00:05 192.168.100.5"
check ovn-nbctl lsp-add ls1 vm2 -- lsp-set-addresses vm2 "00:00:00:00:00:06 192.168.100.6"

check ovn-nbctl ls-add ls-pub
check ovn-nbctl lsp-add ls-pub ext-router -- lsp-set-addresses ext-router "00:00:00:00:01:02 172.18.1.2"

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.100.1/24
check ovn-nbctl lsp-add ls1 ls1-lr1                      \
    -- lsp-set-type ls1-lr1 router                 \
    -- lsp-set-addresses ls1-lr1 00:00:00:00:00:01 \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:01:01 172.18.1.1/24
check ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \
    -- lsp-set-type ls-pub-lr1 router                    \
    -- lsp-set-addresses ls-pub-lr1 00:00:00:00:01:01    \
    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub

check ovn-nbctl lr-nat-add lr1 snat 172.18.1.1 192.168.100.0/24
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.18.2.10 192.168.100.6
check ovn-nbctl lr-route-add lr1 0.0.0.0/0 172.18.1.2

#ls1_uuid=$(fetch_column Port_Binding datapath logical_port=vm1)
#ovn-sbctl create MAC_Binding ip=172.18.2.10 datapath=$ls1_uuid logical_port=vm2 mac="00:00:00:00:00:06"

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "192.168.100.5/24", "00:00:00:00:00:05", \
         "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.100.6/24", "00:00:00:00:00:06", \
         "192.168.100.1")

ADD_NAMESPACES(ext-router)
ADD_VETH(ext-router, ext-router, br-int, "172.18.1.2/24", "00:00:00:00:01:02", \
         "172.18.1.1")

# Let's take a quick look at the logical flows
ovn-sbctl lflow-list

# Let's check what ovn-trace says...
ovn-trace ls1 'inport == "vm1" && eth.src == 00:00:00:00:00:05 && ip4.src == 192.168.100.5 && eth.dst == 00:00:00:00:00:01 && ip4.dst == 172.18.2.10 && ip.ttl == 32'

# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

dnat_and_snat_uuid=$(fetch_column nb:NAT _uuid external_ip=172.18.2.10)
check ovn-nbctl set NAT $dnat_and_snat_uuid options:stateless=true

# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
# A ping from vm2 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm2], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Floating IP outside router subnet IPv4])
AT_KEYWORDS(NAT)

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# Logical network:
# Two VMs
#   * VM1 with IP address 192.168.100.5
#   * VM2 with IP address 192.168.200.5
#
# VM1 connects to logical switch ls1. ls1 connects to logical router lr1.
# VM2 connects to logical switch ls2. ls2 connects to logical router lr2.
# lr1 and lr2 both connect to logical switch ls-pub.
# * lr1's interface that connects to ls-pub has IP address 172.18.2.110/24
# * lr2's interface that connects to ls-pub has IP address 172.18.1.173/24
#
# lr1 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.11 to 192.168.100.5 (VM1)
#
# lr2 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.12 to 192.168.200.5 (VM2)
#
# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.12 reaches VM2.
# When the NAT rules are set up, there should be MAC_Bindings created that allow for traffic
# to exit lr1, go through ls-pub, and reach the NAT external IP configured on lr2.

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 "00:00:00:00:01:05 192.168.100.5"

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2 -- lsp-set-addresses vm2 "00:00:00:00:02:05 192.168.200.5"

check ovn-nbctl ls-add ls-pub

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:01:01 192.168.100.1/24
check ovn-nbctl lsp-add ls1 ls1-lr1                      \
    -- lsp-set-type ls1-lr1 router                 \
    -- lsp-set-addresses ls1-lr1 router            \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl lr-add lr2
check ovn-nbctl lrp-add lr2 lr2-ls2 00:00:00:00:02:01 192.168.200.1/24
check ovn-nbctl lsp-add ls2 ls2-lr2                      \
    -- lsp-set-type ls2-lr2 router                 \
    -- lsp-set-addresses ls2-lr2 router            \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2

check ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:03:01 172.18.2.110/24
check ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \
    -- lsp-set-type ls-pub-lr1 router                    \
    -- lsp-set-addresses ls-pub-lr1 router               \
    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub

check ovn-nbctl lrp-add lr2 lr2-ls-pub 00:00:00:00:03:02 172.18.1.173/24
check ovn-nbctl lrp-set-gateway-chassis lr2-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr2                      \
    -- lsp-set-type ls-pub-lr2 router                    \
    -- lsp-set-addresses ls-pub-lr2 router               \
    -- lsp-set-options ls-pub-lr2 router-port=lr2-ls-pub

# Putting --add-route on these NAT rules means there is no need to
# add any static routes.
check ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.18.2.11 192.168.100.5 vm1 00:00:00:00:03:01
check ovn-nbctl --add-route lr-nat-add lr2 dnat_and_snat 172.18.2.12 192.168.200.5 vm2 00:00:00:00:03:02

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "192.168.100.5/24", "00:00:00:00:01:05", \
         "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.200.5/24", "00:00:00:00:02:05", \
         "192.168.200.1")

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

AS_BOX([Testing a ping])

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.12 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Avoid checking flows on ls-pub due to different ct-zone allocation for cr-ports in I+P/recompute.
OVN_CLEANUP_CONTROLLER([hv1], [], [], [ls-pub])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- CoPP])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_SKIP_IF([test $HAVE_SCAPY = no])
AT_KEYWORDS([ovn-copp])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \
    -- lrp-set-gateway-chassis rp-public hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(server)
NS_CHECK_EXEC([server], [ip link set dev lo up])
ADD_VETH(s1, server, br-ext, "172.16.1.50/24", "f0:00:00:01:02:05", \
         "172.16.1.1")

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

NETNS_START_TCPDUMP([sw01], [-n -i sw01 icmp -Q in], [reject])
check ovn-nbctl meter-add acl-meter drop 1 pktps 0
check ovn-nbctl copp-add copp0 reject acl-meter
check ovn-nbctl ls-copp-add copp0 sw0
check ovn-nbctl --wait=hv acl-add sw0 from-lport 1002 'inport == "sw01" && ip && udp' reject

AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
reject: acl-meter
])

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 20)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.tcpdump | wc -l)
    test "${n_reject}" = "1"
])
kill $(pidof tcpdump)
rm -f reject.tcpdump

# Let's update the meter
NETNS_START_TCPDUMP([sw01], [-n -i sw01 icmp -Q in], [reject])
check ovn-nbctl --may-exist --wait=hv meter-add acl-meter drop 5 pktps 0
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow15 meter-stats br-int | grep -q packet_count:0])
ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 40)
EOF

# 10pps
OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.tcpdump | wc -l)
    test "${n_reject}" = "5"
])

kill $(pidof tcpdump)
rm -f reject.tcpdump

NETNS_START_TCPDUMP([sw01], [-n -i sw01 icmp -Q in], [reject])
check ovn-nbctl --wait=hv copp-del copp0 reject

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 20)
EOF

OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.tcpdump | wc -l)
    test "${n_reject}" = "20"
])

NETNS_START_TCPDUMP([server], [-n -i s1 arp[[24:4]]=0xac100164], [arp])
check ovn-nbctl meter-add arp-meter drop 1 pktps 0
check ovn-nbctl copp-add copp1 arp-resolve arp-meter
check ovn-nbctl --wait=hv lr-copp-add copp1 R1
AT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl
arp-resolve: arp-meter
])

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="172.16.1.100") / TCP(dport = 80, flags="S") / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 100)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_arp=$(grep ARP arp.tcpdump | wc -l)
    test "${n_arp}" = "1"
])

check ovn-nbctl meter-add icmp-meter drop 1 pktps 0
check ovn-nbctl copp-add copp2 icmp4-error icmp-meter
check ovn-nbctl --wait=hv lr-copp-add copp2 R1
AT_CHECK([ovn-nbctl copp-list copp2 |grep icmp4-error], [0], [dnl
icmp4-error: icmp-meter
])

NETNS_START_TCPDUMP([sw01], [-n -i sw01 icmp], [icmp])
ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="172.16.1.100", ttl=1) / TCP(dport = 8080, flags="S") / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 100)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_icmp=$(grep ICMP icmp.tcpdump | wc -l)
    test "${n_icmp}" = "1"
])

check ovn-nbctl meter-add bfd-meter drop 1 pktps 0
check ovn-nbctl copp-add copp3 bfd bfd-meter
check ovn-nbctl --wait=hv lr-copp-add copp3 R1
AT_CHECK([ovn-nbctl copp-list copp3 |grep bfd], [0], [dnl
bfd: bfd-meter
])

check ovn-nbctl --wait=hv --bfd lr-route-add R1 240.0.0.0/8 172.16.1.50 rp-public
ovn_discriminator=$(printf "%08x" $(ovn-sbctl get bfd . disc))
NETNS_START_TCPDUMP([server], [-nn -i s1 udp port 3784 and ip[[29]]==0x90 -Q in], [bfd])
ip netns exec server scapy -H <<-EOF
from scapy.contrib import bfd
BFD_STA_DOWN = 1
BFD_FLAG_POLL = 1 << 5
p = (Ether(src="f0:00:00:01:02:05", dst="00:00:02:01:02:03") /
     IP(src="172.16.1.50", dst="172.16.1.1") /
     UDP(dport = 3784, sport = 49152) /
     bfd.BFD(sta=BFD_STA_DOWN,
             flags=BFD_FLAG_POLL,
             your_discriminator=0x$ovn_discriminator))
sendp (p, iface='s1', loop = 0, verbose = 0, count = 100)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_bfd=$(grep 3784 bfd.tcpdump | wc -l)
    test "${n_bfd}" = "1"
])

check ovn-nbctl set nb_global . options:svc_monitor_mac="33:33:33:33:33:33"
check ovn-nbctl meter-add svc-meter drop 1 pktps 0
check ovn-nbctl copp-add copp4 svc-monitor svc-meter
check ovn-nbctl --wait=hv ls-copp-add copp4 sw0
check ovn-appctl -t ovn-controller vlog/set vconn:dbg
AT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl
svc-monitor: svc-meter
])

ip netns exec sw01 scapy -H <<-EOF
p = Ether(dst="33:33:33:33:33:33", src="f0:00:00:01:02:03") /\
    IP(dst="192.168.1.100", src="192.168.1.2") / TCP(dport=1234, sport=1234)
sendp(p, iface='sw01', loop=0, verbose=0, count=20)
EOF

OVS_WAIT_UNTIL([test "1" = "$(grep -c "dl_dst=33:33:33:33:33:33" ovn-controller.log)"])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d
/.*Service monitor not found/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack ct_label])
AT_KEYWORDS([acl label ct_commit])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:04 10.0.0.4"

# ACLs
# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234
# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235
# Case 3: sw0-p1 ---> sw0-p2 allowed, no label
# Case 4: sw0-p2 ---> sw0-p1 allowed, no label

check ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.4' allow-related
check ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == "sw0-p1" && ip4.src == 10.0.0.4' allow-related
check ovn-nbctl acl-add sw0 from-lport 1001 "ip" allow-related
check ovn-nbctl acl-add sw0 to-lport 1001 "ip" allow-related


ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p3)
ADD_VETH(sw0-p3, sw0-p3, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p3'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p3' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,mark=32,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p2'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p2' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack ct_label - acl after lb])
AT_KEYWORDS([acl label ct_commit])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:04 10.0.0.4"

# ACLs
# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234
# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235
# Case 3: sw0-p1 ---> sw0-p2 allowed, no label
# Case 4: sw0-p2 ---> sw0-p1 allowed, no label

check ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.4' allow-related
check ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == "sw0-p1" && ip4.src == 10.0.0.4' allow-related
check ovn-nbctl --apply-after-lb acl-add sw0 from-lport 1001 "ip" allow-related
check ovn-nbctl acl-add sw0 to-lport 1001 "ip" allow-related


ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p3)
ADD_VETH(sw0-p3, sw0-p3, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p3'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=16,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p3' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,mark=32,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p2'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p2' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack label change])
AT_KEYWORDS([acl label ct_commit label change])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

# ACLs
# sw0-p1 ---> sw0-p2 allowed, label=1234

check ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# start a background ping for ~30 secs.
NETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])

sleep 3s

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
])

# Add a higher priority ACL with different label.
# This ACL also allows the ping running in background.

check ovn-nbctl --label=1235 acl-add sw0 from-lport 1003 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related
check ovn-nbctl --wait=hv sync

sleep 3s

# Ensure conntrack entry is updated with new ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack label change - acl after lb])
AT_KEYWORDS([acl label ct_commit label change])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

# ACLs
# sw0-p1 ---> sw0-p2 allowed, label=1234

check ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# start a background ping for ~30 secs.
NETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])

sleep 3s

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=16,labels=0x4d2000000000000000000000000
])

# Add a higher priority ACL with different label.
# This ACL also allows the ping running in background.

check ovn-nbctl --label=1235 --apply-after-lb acl-add sw0 from-lport 1003 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related
check ovn-nbctl --wait=hv sync

sleep 3s

# Ensure conntrack entry is updated with new ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=16,labels=0x4d3000000000000000000000000
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL all drop and allow related - acl after lb])
AT_KEYWORDS([ACL all drop and allow related])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller


# No ACLs in sw0.
check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0p1
check ovn-nbctl lsp-set-addresses sw0p1 "50:54:00:00:00:02 10.0.0.3"

# ACLs to drop every thing and just allow-related.
check ovn-nbctl ls-add sw1

check ovn-nbctl lsp-add sw1 sw1p1
check ovn-nbctl lsp-set-addresses sw1p1 "50:54:00:00:00:03 20.0.0.3"

check ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1001 'inport == "sw1p1" && ip4' drop

check ovn-nbctl acl-add sw1 to-lport 1002 'ip4 && tcp && tcp.dst == 80' allow-related
check ovn-nbctl acl-add sw1 to-lport 1001 'ip4' drop

ADD_NAMESPACES(sw0p1)
ADD_VETH(sw0p1, sw0p1, br-int, "10.0.0.3/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw1p1)
ADD_VETH(sw1p1, sw1p1, br-int, "20.0.0.3/24", "50:54:00:00:00:03", \
         "20.0.0.1")

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

# Ensure ovn-controller is caught up
check ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

# Start webservers in 'sw1-p1'
OVS_START_L7([sw1p1], [http])

AT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])

# Clear the apply-after-lb option for the ACL
check ovn-nbctl acl-del sw1 from-lport 1001 'inport == "sw1p1" && ip4'
check ovn-nbctl acl-add sw1 from-lport 1001 'inport == "sw1p1" && ip4' drop

check ovn-nbctl --wait=hv sync

AT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL log_related])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

set_acl_options() {
    local acl_name=$1; shift

    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)
    check ovn-nbctl set ACL $acl_uuid "$@"
}

clear_log() {
    ovn-appctl -t ovn-controller vlog/close
    rm ovn-controller.log
    ovn-appctl -t ovn-controller vlog/reopen
}

test_ping() {
    NS_CHECK_EXEC([sw0-p1],  [ping -q -c 1 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
1 packets transmitted, 1 received, 0% packet loss, time 0ms
])
}

check_acl_log_count() {
    local expected_count=$1

    OVS_WAIT_UNTIL([test $expected_count = `cat ovn-controller.log | grep -c acl_log`])
}

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl pg-add pg1 sw0-p1 sw0-p2

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.1/24", "00:00:00:00:00:01")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.2/24", "00:00:00:00:00:02")

wait_for_ports_up

check ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport == @pg1 && ip4' allow

check ovn-nbctl --wait=hv sync

test_ping

# The allow ACL should match on the request and reply traffic, resulting in 2 logs.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0

# Now add a higher-priority stateful ACL that matches on the same
# parameters. Don't enable reply logging.
check ovn-nbctl --log --name=allow_related_acl acl-add pg1 from-lport 200 'inport == @pg1 && ip4' allow-related
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Since reply logging is not enabled, the allow-related ACL should match on the
# request, but the reply will not be logged.
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As a control, set a label on the allow-related ACL, but still don't enable
# reply traffic logging.
set_acl_options allow_related_acl label=1 options:log-related=false
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As another control, remove the label but enable reply logging.
set_acl_options allow_related_acl label=0 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# This time, add a label and enable reply logging on the allow_related ACL.
set_acl_options allow_related_acl label=1 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Now we should have the request and reply logged.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0


# And now, let's start from scratch but make sure everything works when
# using egress ACLs.
check ovn-nbctl acl-del pg1
check_row_count nb:ACL 0

check ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'outport == @pg1 && ip4' allow

check ovn-nbctl --wait=hv sync

clear_log
test_ping

# The allow ACL should match on the request and reply traffic, resulting in 2 logs.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0

# Now add a higher-priority stateful ACL that matches on the same
# parameters. Don't enable reply logging.
check ovn-nbctl --log --name=allow_related_acl acl-add pg1 to-lport 200 'outport == @pg1 && ip4' allow-related
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Since reply logging is not enabled, the allow-related ACL should match on the
# request, but the reply will not be logged.
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As a control, set a label on the allow-related ACL, but still don't enable
# reply traffic logging.
set_acl_options allow_related_acl label=1 options:log-related=false
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As another control, remove the label but enable reply logging.
set_acl_options allow_related_acl label=0 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# This time, add a label and enable reply logging on the allow_related ACL.
set_acl_options allow_related_acl label=1 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Now we should have the request and reply logged.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0


OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([East-West traffic with gateway router if DNAT configured])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller
# Logical network:
# One LR - R1  has two switches: sw0 and sw1
#    sw0 -- R1 -- sw1
# Logical port 'sw01' in switch 'sw0'.
# Logical port 'sw11' in switch 'sw1'.
# nc server running in sw01
# nc client running on sw11

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl set logical_router R1 options:chassis=hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
       "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.2.2/24", "f0:00:00:02:02:03", \
       "192.168.2.1")
check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03 192.168.2.2"

NETNS_DAEMONIZE([sw01], [nc -k -l 8000], [nc-sw01.pid])

test_ping() {
    NS_CHECK_EXEC([$1],  [ping -q -c 1 $2 -w 2 | FORMAT_PING], \
[0], [dnl
1 packets transmitted, 1 received, 0% packet loss, time 0ms
])
}

# Only SNAT
check ovn-nbctl --wait=hv lr-nat-add R1 snat 172.16.1.21 192.168.2.0/24

echo "foo" > foo
NS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 192.168.1.2

# Ensure nat has been hit
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -v "n_packets=0" | grep 'nat(src=172.16.1.21)'])
# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# SNAT and DNAT. using Logical IP
check ovn-nbctl --wait=hv lr-nat-add R1 dnat_and_snat 172.16.1.2 192.168.1.2
NS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 192.168.1.2

# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# SNAT and DNAT. using floating IP
NS_CHECK_EXEC([sw11], [nc 172.16.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 172.16.1.2

# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Container ping parent port])
AT_KEYWORDS([container-parent-port])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "00:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-add sw0 sw0-p1.2 sw0-p1 2
check ovn-nbctl lsp-set-addresses sw0-p1.2 "00:54:00:00:00:04 10.0.0.4"
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "00:54:00:00:00:03", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1], [ip link add link sw0-p1 name sw0-p1.2 type vlan id 2], [0])
ADD_NAMESPACES(sw0-p1.2)
NS_CHECK_EXEC([sw0-p1], [ip link set sw0-p1.2 netns sw0-p1.2], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 address 00:54:00:00:00:04], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 up], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip addr add 10.0.0.4/24 dev sw0-p1.2], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip route add default via 10.0.0.1 dev sw0-p1.2], [0])

NS_CHECK_EXEC([sw0-p1.2], [ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SNAT in gateway router mode])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
check ovs-ofctl add-flow br0 action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ip link set br0 up
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=provider:br0

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 ls1p1
check ovn-nbctl lsp-set-addresses ls1p1 "00:00:00:01:01:01 192.168.1.1 2001::1"
check ovn-nbctl lsp-add ls1 ls1p2
check ovn-nbctl lsp-set-addresses ls1p2 "00:00:00:01:01:02 192.168.1.2 2001::2"

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.1.254/24 2001::a/64
check ovn-nbctl lsp-add ls1 ls1-lr1
check ovn-nbctl lsp-set-addresses ls1-lr1 "00:00:00:00:00:01 192.168.1.254 2001::a"
check ovn-nbctl lsp-set-type ls1-lr1 router
check ovn-nbctl lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl set logical_router lr1 options:chassis=hv1

check ovn-nbctl lrp-add lr1 lr1-pub 00:00:00:00:0f:01 172.16.1.254/24 1711::a/64
check ovn-nbctl ls-add pub
check ovn-nbctl lsp-add pub pub-lr1
check ovn-nbctl lsp-set-type pub-lr1 router
check ovn-nbctl lsp-set-options pub-lr1 router-port=lr1-pub
check ovn-nbctl lsp-set-addresses pub-lr1 router

check ovn-nbctl lsp-add pub ln -- lsp-set-options ln network_name=provider
check ovn-nbctl lsp-set-type ln localnet
check ovn-nbctl lsp-set-addresses ln unknown

check ovn-nbctl lr-nat-add lr1 snat 172.16.1.10 192.168.1.0/24
check ovn-nbctl lr-nat-add lr1 snat 1711::10 2001::/64

ADD_NAMESPACES(ls1p1)
ADD_VETH(ls1p1, ls1p1, br-int, "2001::1/64", "00:00:00:01:01:01", \
         "2001::a", "nodad", "192.168.1.1/24", "192.168.1.254")

ADD_NAMESPACES(ls1p2)
ADD_VETH(ls1p2, ls1p2, br-int, "2001::2/64", "00:00:00:01:01:02", \
         "2001::a", "nodad", "192.168.1.2/24", "192.168.1.254")

ADD_NAMESPACES(ext1)
ADD_VETH(ext1, ext1, br0, "1711::1/64", "00:ee:00:01:01:01", \
         "1711::a", "nodad", "172.16.1.1/24", "172.16.1.254")

check ovn-nbctl --wait=hv sync
wait_for_ports_up

NS_CHECK_EXEC([ls1p1], [ping -q -c 3 -i 0.3 -w 2  172.16.1.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

NS_CHECK_EXEC([ls1p1], [ping6 -q -c 3 -i 0.3 -w 2 1711::1  | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/removing policing failed: No such device/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([mcast flow count])
AT_KEYWORDS([ovnigmp IP-multicast])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01
check ovn-nbctl lsp-add ls vm2
check ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02
check ovn-nbctl lsp-add ls vm3
check ovn-nbctl lsp-set-addresses vm3 00:00:00:00:00:03

check ovn-nbctl set logical_switch ls other_config:mcast_querier=false other_config:mcast_snoop=true other_config:mcast_query_interval=30 other_config:mcast_eth_src=00:00:00:00:00:05 other_config:mcast_ip4_src=42.42.42.5 other_config:mcast_ip6_src=fe80::1 other_config:mcast_idle_timeout=3000
ovn-sbctl list ip_multicast

wait_igmp_flows_installed()
{
    OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable ls_in_l2_lkup) | \
    grep 'priority=90' | grep "nw_dst=$1"])
}

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.1/24", "00:00:00:00:00:01", \
         "42.42.42.5")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.2/24", "00:00:00:00:00:02")

ADD_NAMESPACES(vm3)
NETNS_START_TCPDUMP([vm3], [-n -i any -nnleX], [vm3])

ADD_VETH(vm3, vm3, br-int, "42.42.42.3/24", "00:00:00:00:00:03", \
         "42.42.42.5")

NS_CHECK_EXEC([vm2], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])
wait_for_ports_up

NS_CHECK_EXEC([vm3], [ip addr add 228.0.0.1 dev vm3 autojoin], [0])
wait_igmp_flows_installed 228.0.0.1

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.0.0.1], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "ICMP echo request" -c vm3.tcpdump`
    test "${requests}" -ge "3"
])

NETNS_START_TCPDUMP([vm2], [-n -i any -nnleX], [vm2])

for i in `seq 1 40`;do
    NS_CHECK_EXEC([vm2], [ip addr add 228.1.$i.1 dev vm2 autojoin &], [0])
    NS_CHECK_EXEC([vm3], [ip addr add 229.1.$i.1 dev vm3 autojoin &], [0])
    # Do not go too fast. If going fast, there is a higher chance of sb being busy, causing full recompute (engine has not run)
    # In this test, we do not want too many recomputes as they might hide I+I related errors
    sleep 0.2
done

for i in `seq 1 40`;do
    wait_igmp_flows_installed 228.1.$i.1
    wait_igmp_flows_installed 229.1.$i.1
done
ovn-sbctl list multicast_group

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.1.1.1], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "ICMP echo request" -c vm2.tcpdump`
    test "${requests}" -ge "3"
])

# The test could succeed thanks to a lucky northd recompute...after hitting too any flows
# Double check we never hit error condition
AT_CHECK([grep -qE 'Too many active IPv4 mcast flows' northd/ovn-northd.log], [1])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/removing policing failed: No such device/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DVR ping router port])
AT_KEYWORDS([dvr])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovs-vsctl set open . external_ids:ovn-bridge-mappings=phys:br-ext
check ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:ee:00:00:00:00:10"


check ovn-nbctl ls-add internal

check ovn-nbctl lsp-add internal ln_internal "" 100
check ovn-nbctl lsp-set-addresses ln_internal unknown
check ovn-nbctl lsp-set-type ln_internal localnet
check ovn-nbctl lsp-set-options ln_internal network_name=phys

check ovn-nbctl lsp-add internal internal-gw
check ovn-nbctl lsp-set-type internal-gw router
check ovn-nbctl lsp-set-addresses internal-gw router
check ovn-nbctl lsp-set-options internal-gw router-port=gw-internal

check ovn-nbctl lsp-add internal vif0
# Set address as unknown so that LRP has to generate ARP request
check ovn-nbctl lsp-set-addresses vif0 unknown

check ovn-nbctl lr-add gw
check ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:00 192.168.20.1/24

ADD_NAMESPACES(vif0)
ADD_VETH(vif0, vif0, br-int, "192.168.20.10/24", "00:00:00:00:20:10", "192.168.20.1")

check ovn-nbctl --wait=sb sync
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 1 192.168.20.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([LB - ICMP related traffic])
TAG_UNSTABLE

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

m4_define([WAIT_PACKET], [
pcap=$1
packet=$2
OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap |\
grep -c $packet) -eq 1])
])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true
start_daemon ovn-controller

# client -- ls0 -- lr -- ls1 -- server
check ovn-nbctl ls-add ls0
check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls0 ls0-lr
check ovn-nbctl lsp-set-type ls0-lr router
check ovn-nbctl lsp-set-addresses ls0-lr 00:00:00:00:10:00 router
check ovn-nbctl lsp-set-options ls0-lr router-port=lr-ls0

check ovn-nbctl lsp-add ls1 ls1-lr
check ovn-nbctl lsp-set-type ls1-lr router
check ovn-nbctl lsp-set-addresses ls1-lr 00:00:00:00:20:00 router
check ovn-nbctl lsp-set-options ls1-lr router-port=lr-ls1

check ovn-nbctl lsp-add ls0 client
check ovn-nbctl lsp-set-addresses client "00:00:00:00:10:10 192.168.10.10"

check ovn-nbctl lsp-add ls1 server
check ovn-nbctl lsp-set-addresses server "00:00:00:00:20:10 192.168.20.10"

check ovn-nbctl lr-add lr
check ovn-nbctl lrp-add lr lr-ls0 00:00:00:00:10:00 192.168.10.1/24
check ovn-nbctl lrp-add lr lr-ls1 00:00:00:00:20:00 192.168.20.1/24

check ovn-nbctl set logical_router lr options:chassis=hv1

ADD_NAMESPACES(client)
ADD_VETH(client, client, br-int, "192.168.10.10/24", "00:00:00:00:10:10", \
         "192.168.10.1")
ADD_NAMESPACES(server)
ADD_VETH(server, server, br-int, "192.168.20.10/24", "00:00:00:00:20:10", \
         "192.168.20.1")

# Define packets to send
client_udp=00000000100000000000101008004500001C000040000A11D162C0A80A0AC0A\
814140001000200080000
server_udp=00000000200000000000201008004500001C000040000A11D16CC0A8140AC0A\
80A0A0002000100080000
client_icmp=000000001000000000001010080045000038011F0000FF011B37C0A80A0AC0A814140\
304F778000005784500001c000040000911d262c0a81414c0a80a0a0002000100080000
server_icmp=000000002000000000002010080045000038011F0000FF011B41C0A8140AC0A80A0A0\
304F778000005784500001C000040000911D26CC0A80A0AC0A8140A0001000200080000

# Define expected packets
client_udp_expected=00000000101000000000100008004500001c000040000911d262c0a\
81414c0a80a0a0002000100080000
server_udp_expected=00000000201000000000200008004500001c000040000911d26cc0a8\
0a0ac0a8140a0001000200080000
client_icmp_expected=000000001010000000001000080045000038011f0000fe011c37c0a81414c0a\
80a0a0304f778000005784500001c000040000911d262c0a80a0ac0a814140001000200080000
server_icmp_expected=000000002010000000002000080045000038011f0000fe011c41c0a80a0ac0\
a8140a0304f778000005784500001c000040000911d26cc0a8140ac0a80a0a0002000100080000

test_related_traffic() {
    check ovn-nbctl --wait=hv sync

    check ovs-appctl dpctl/flush-conntrack

    NETNS_START_TCPDUMP([client], [-U -i client -w client.pcap], [tcpdump0])
    NETNS_START_TCPDUMP([server], [-U -i server -w server.pcap], [tcpdump1])

    # Setup a dummy UDP listeners so we don't get "port unreachable".
    NETNS_DAEMONIZE([client], [nc -l -u 1], [nc0.pid])
    NETNS_DAEMONIZE([server], [nc -l -u 2], [nc1.pid])

    # Send UDP client -> server
    check ovs-ofctl packet-out br-int "in_port=ovs-client,packet=$client_udp,actions=resubmit(,0)"

    # Send ICMP "need to frag" server -> client
    check ovs-ofctl packet-out br-int "in_port=ovs-server,packet=$server_icmp,actions=resubmit(,0)"

    # Send reply server -> client
    check ovs-ofctl packet-out br-int "in_port=ovs-server,packet=$server_udp,actions=resubmit(,0)"

    # Send ICMP "need to frag" client -> server
    check ovs-ofctl packet-out br-int "in_port=ovs-client,packet=$client_icmp,actions=resubmit(,0)"

    # Check if all packets have arrived
    WAIT_PACKET([server.pcap], [$server_udp_expected])
    WAIT_PACKET([client.pcap], [$client_icmp_expected])
    WAIT_PACKET([client.pcap], [$client_udp_expected])
    WAIT_PACKET([server.pcap], [$server_icmp_expected])

    kill $(cat tcpdump0.pid) $(cat tcpdump1.pid)
    kill $(cat nc0.pid) $(cat nc1.pid)

    rm -f client.pcap server.pcap
}

AS_BOX([ICMP related on switch, LB without port and protocol])
check ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10
check ovn-nbctl ls-lb-add ls0 lb0

test_related_traffic

check ovn-nbctl ls-lb-del ls0
check ovn-nbctl lb-del lb0

AS_BOX([ICMP related on switch, LB with port and protocol])
check ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp
check ovn-nbctl ls-lb-add ls0 lb0

test_related_traffic

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
udp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
])

check ovn-nbctl ls-lb-del ls0
check ovn-nbctl lb-del lb0

AS_BOX([ICMP related on router, LB without port and protocol])
check ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10
check ovn-nbctl lr-lb-add lr lb0

test_related_traffic

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
udp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
])

check ovn-nbctl lr-lb-del lr
check ovn-nbctl lb-del lb0

AS_BOX([ICMP related on router, LB with port and protocol])
check ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp
check ovn-nbctl lr-lb-add lr lb0

test_related_traffic

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
udp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
])

check ovn-nbctl lr-lb-del lr
check ovn-nbctl lb-del lb0

AS_BOX([ICMP related force SNAT])
check ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10
check ovn-nbctl lr-lb-add lr lb0

check ovn-nbctl --wait=sb set logical_router lr options:lb_force_snat_ip="router_ip"

# Change the expected packets on server to be with source IP from router
server_udp_expected=00000000201000000000200008004500001c000040000911c875c0a8\
1401c0a8140a0001000200080000
server_icmp_expected=000000002010000000002000080045000038011f0000fe01124ac0a81401c0\
a8140a0304f778000005784500001c000040000911c875c0a8140ac0a814010002000100080000

# Server should respond to the router IP
server_udp=00000000200000000000201008004500001C000040000A11C775C0A8140AC0A8\
14010002000100080000
server_icmp=000000002000000000002010080045000038011F0000FF01114AC0A8140AC0A814010\
304F778000005784500001C000040000911C875C0A81401C0A8140A0001000200080000

test_related_traffic

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
udp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer template IPv4])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb templates])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# VM1 -- LS1 -- GW-Router -- LS2 -- VM3
#         |
# VM2 ----+
#
# Four templated load balancer applied on LS1 and GW-Router with
# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.

check ovn-nbctl                                                   \
    -- lr-add rtr                                                 \
    -- set Logical_Router rtr options:chassis=hv1                 \
    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 42.42.42.1/24        \
    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 43.43.43.1/24        \
    -- ls-add ls1                                                 \
    -- lsp-add ls1 ls1-rtr                                        \
    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls1-rtr router                                \
    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \
    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- ls-add ls2                                                 \
    -- lsp-add ls2 ls2-rtr                                        \
    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \
    -- lsp-set-type ls2-rtr router                                \
    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \
    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03

# Add a TCP template LB that eventually expands to:
# VIP=66.66.66.66:666 backends=42.42.42.2:4242 proto=tcp
# And a UDP template LB that eventually expands to:
# VIP=66.66.66.66:777 backends=42.42.42.2:4343 proto=udp

AT_CHECK([ovn-nbctl -- create chassis_template_var chassis="hv1" \
    variables="{vip=66.66.66.66,vport1=666,backends1=\"42.42.42.2:4242\",vport2=777,backends2=\"42.42.42.2:4343\",vport3=888,vport4=999}"],
         [0], [ignore])

check ovn-nbctl --template lb-add lb-test-tcp "^vip:^vport1" "^backends1" tcp \
    -- ls-lb-add ls1 lb-test-tcp                                              \
    -- lr-lb-add rtr lb-test-tcp

check ovn-nbctl --template lb-add lb-test-udp "^vip:^vport2" "^backends2" udp \
    -- ls-lb-add ls1 lb-test-udp                                              \
    -- lr-lb-add rtr lb-test-udp

# Add a TCP template LB with explicit backends that eventually expands to:
# VIP=66.66.66.66:888 backends=42.42.42.2:4242 proto=tcp
# And a UDP template LB that eventually expands to:
# VIP=66.66.66.66:999 backends=42.42.42.2:4343 proto=udp
check ovn-nbctl --template lb-add lb-test-tcp2 "^vip:^vport3" "42.42.42.2:4242" tcp ipv4 \
    -- ls-lb-add ls1 lb-test-tcp2                                                        \
    -- lr-lb-add rtr lb-test-tcp2

check ovn-nbctl --template lb-add lb-test-udp2 "^vip:^vport4" "42.42.42.2:4343" udp ipv4 \
    -- ls-lb-add ls1 lb-test-udp2                                                        \
    -- lr-lb-add rtr lb-test-udp2

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

ADD_NAMESPACES(vm3)
ADD_VETH(vm3, vm3, br-int, "43.43.43.2/24", "00:00:00:00:00:03", "43.43.43.1")

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

AT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl
Local template vars:
name: 'backends1' value: '42.42.42.2:4242'
name: 'backends2' value: '42.42.42.2:4343'
name: 'vip' value: '66.66.66.66'
name: 'vport1' value: '666'
name: 'vport2' value: '777'
name: 'vport3' value: '888'
name: 'vport4' value: '999'
])

# Start IPv4 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])

NETNS_START_TCPDUMP([vm1],
    [-n -i vm1 -nnqleX -c6 udp and dst 42.42.42.2 and dst port 4343],
    [vm1])

# Make sure connecting to the VIP works (hairpin, via ls and via lr).
NS_CHECK_EXEC([vm1], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "UDP" -c vm1.tcpdump`
    test "${requests}" -ge "6"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer template IPv6])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb templates])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# VM1 -- LS1 -- GW-Router -- LS2 -- VM3
#         |
# VM2 ----+
#
# Four templated load balancer applied on LS1 and GW-Router with
# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.

check ovn-nbctl                                                   \
    -- lr-add rtr                                                 \
    -- set Logical_Router rtr options:chassis=hv1                 \
    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 4242::1/64           \
    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 4343::1/64           \
    -- ls-add ls1                                                 \
    -- lsp-add ls1 ls1-rtr                                        \
    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls1-rtr router                                \
    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \
    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- ls-add ls2                                                 \
    -- lsp-add ls2 ls2-rtr                                        \
    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \
    -- lsp-set-type ls2-rtr router                                \
    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \
    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03

# Add a template LB that eventually expands to:
# VIP=[6666::1]:666 backends=[4242::2]:4242 proto=tcp
# Add a template LB that eventually expands to:
# VIP=[6666::1]:777 backends=[4242::2]:4343 proto=udp

AT_CHECK([ovn-nbctl -- create chassis_template_var chassis="hv1" \
    variables="{vip=\"6666::1\",vport1=666,backends1=\"[[4242::2]]:4242\",vport2=777,backends2=\"[[4242::2]]:4343\",vport3=888,vport4=999}"],
         [0], [ignore])

check ovn-nbctl --template lb-add lb-test-tcp "^vip:^vport1" "^backends1" tcp ipv6 \
    -- ls-lb-add ls1 lb-test-tcp                                                   \
    -- lr-lb-add rtr lb-test-tcp

check ovn-nbctl --template lb-add lb-test-udp "^vip:^vport2" "^backends2" udp ipv6 \
    -- ls-lb-add ls1 lb-test-udp                                                   \
    -- lr-lb-add rtr lb-test-udp

# Add a TCP template LB with explicit backends that eventually expands to:
# VIP=[6666::1]:888 backends=[4242::2]:4242 proto=tcp
# And a UDP template LB that eventually expands to:
# VIP=[6666::1]:999 backends=[4242::2]:4343 proto=udp
check ovn-nbctl --template lb-add lb-test-tcp2 "^vip:^vport3" "[[4242::2]]:4242" tcp ipv6 \
    -- ls-lb-add ls1 lb-test-tcp2                                                         \
    -- lr-lb-add rtr lb-test-tcp2

check ovn-nbctl --template lb-add lb-test-udp2 "^vip:^vport4" "[[4242::2]]:4343" udp ipv6 \
    -- ls-lb-add ls1 lb-test-udp2                                                         \
    -- lr-lb-add rtr lb-test-udp2

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "4242::2/64", "00:00:00:00:00:01", "4242::1", "nodad")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "4242::3/64", "00:00:00:00:00:02", "4242::1", "nodad")

ADD_NAMESPACES(vm3)
ADD_VETH(vm3, vm3, br-int, "4343::2/64", "00:00:00:00:00:03", "4343::1", "nodad")

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

AT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl
Local template vars:
name: 'backends1' value: '[[4242::2]]:4242'
name: 'backends2' value: '[[4242::2]]:4343'
name: 'vip' value: '6666::1'
name: 'vport1' value: '666'
name: 'vport2' value: '777'
name: 'vport3' value: '888'
name: 'vport4' value: '999'
])

# Start IPv6 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])

NETNS_START_TCPDUMP([vm1],
    [-n -i vm1 -nnqleX -c6 udp and dst 4242::2 and dst port 4343],
    [vm1])

# Make sure connecting to the VIP works (hairpin, via ls and via lr).
NS_CHECK_EXEC([vm1], [nc 6666::1 666 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [nc 6666::1 666 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [nc 6666::1 666 -z], [0], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [nc 6666::1 888 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [nc 6666::1 888 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [nc 6666::1 888 -z], [0], [ignore], [ignore])

NS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "UDP" -c vm1.tcpdump`
    test "${requests}" -ge "6"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IP buffering])
AT_KEYWORDS([ip-buffering])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.2.2/24", "f0:00:00:02:02:03", \
         "192.168.2.1")
ADD_NAMESPACES(remote)
ADD_VETH(remote, remote, br-ext, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
ADD_NAMESPACES(remote1)
ADD_VETH(remote1, remote1, br-ext, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.1")

NETNS_START_TCPDUMP([remote], [-c 3 -nneei remote -Q in src 192.168.1.2 and dst 172.16.1.2 and icmp], [icmp])
NETNS_START_TCPDUMP([remote], [-c 1 -nneei remote -Q in arp and arp[[24:4]]==0xac100102], [arp])
NETNS_START_TCPDUMP([remote1], [-c 3 -nneei remote1 -Q in src 172.16.1.3 and dst 172.16.1.4 and icmp], [icmp1])
NETNS_START_TCPDUMP([remote1], [-c 1 -nneei remote1 -Q in arp and arp[[24:4]]==0xac100104], [arp1])

check ovn-nbctl lr-add R1 -- set Logical_Router R1 options:chassis=hv1
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03 192.168.2.2"

check ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.2.2 sw11 00:00:02:02:03:10

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([sw01], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
        total_arp_pkts=$(cat arp.tcpdump | wc -l)
        test "${total_arp_pkts}" = "1"
])

OVS_WAIT_UNTIL([
        total_icmp_pkts=$(cat icmp.tcpdump | wc -l)
        test "${total_icmp_pkts}" = "3"
])

NS_CHECK_EXEC([sw11], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
        total_arp1_pkts=$(cat arp1.tcpdump | wc -l)
        test "${total_arp1_pkts}" = "1"
])

OVS_WAIT_UNTIL([
        total_icmp1_pkts=$(cat icmp1.tcpdump | wc -l)
        test "${total_icmp1_pkts}" = "3"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

# For packets that match stateless ACL flows, make sure we bypass
# connection tracking, even with a LB in the switch. Testing for
# TCP should suffice. For v4 and v6.
#
OVN_FOR_EACH_NORTHD([
AT_SETUP([omit connection tracking for stateless flows v4])

CHECK_CONNTRACK()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
#
#    foo -- R1 -- bar

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24

# Connect foo to R1
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Config OVN load-balancer with a VIP.
check ovn-nbctl lb-add lb1 30.30.30.30:80 "192.168.2.2:80" tcp
check ovn-nbctl ls-lb-add foo lb1

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

zone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)

OVS_START_L7([bar1], [http])

AT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(192.168.1.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# now check with VIP
AT_CHECK([ip netns exec foo1 wget   30.30.30.30  -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(30.30.30.30) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.30.30.30,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# remove lb
check ovn-nbctl ls-lb-del foo lb1

# add stateless acl
check ovn-nbctl acl-add foo from-lport 1 1 allow-stateless
check ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless

AT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has no tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(192.168.1.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# add lb back
check ovn-nbctl ls-lb-add foo lb1

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

# should not dnat so will not be able to connect
AT_CHECK([ip netns exec foo1 curl 30.30.30.30 --retry 3 --max-time 1], [28], [ignore], [ignore])

# check conntrack zone has no tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(30.30.30.30) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([omit connection tracking for stateless flows v6])

CHECK_CONNTRACK()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR - R1 with switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it
#
#    foo -- R1 -- bar

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
         "fd12::1",  "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Config OVN load-balancer with a VIP.
check ovn-nbctl lb-add lb1 [[fd30::2]]:80 [[fd12::2]]:80 tcp
check ovn-nbctl ls-lb-add foo lb1

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd12::2\]]:80)'])

zone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)

OVS_START_L7([bar1], [http6])
AT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(fd12::2) |  grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd11::2,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# now check with VIP
AT_CHECK([ip netns exec foo1 wget  http://[[fd30::2]]  -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(fd30::2) |  grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd11::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# remove lb
check ovn-nbctl ls-lb-del foo lb1

# add stateless acl
check ovn-nbctl acl-add foo from-lport 1 1 allow-stateless
check ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless

AT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])

# check conntrack zone has no tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(fd12::2) |  grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# add lb back
check ovn-nbctl ls-lb-add foo lb1

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd12::2\]]:80)'])

# should not dnat so will not be able to connect
AT_CHECK([ip netns exec foo1 curl http://[[fd30::2]] --retry 3 --max-time 1], [28], [ignore], [ignore])
#
# check conntrack zone has no tcp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(fd30::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

###########################################################
## ls1 -- cluster-router -- join - gr1 -- public1 -- ln1 ##
###########################################################
OVN_FOR_EACH_NORTHD([
AT_SETUP([Gateway router with dynamic_neigh_routers])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ex], [set Bridge br-ex fail-mode=standalone])

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=provider:br-ex

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Add routers
check ovn-nbctl lr-add gr1
check ovn-nbctl lr-add cluster-router

# Add switches
check ovn-nbctl ls-add join
check ovn-nbctl ls-add public1
check ovn-nbctl ls-add ls1

# Add ls1 ports
check ovn-nbctl lsp-add ls1 ls1p1 \
    -- lsp-set-addresses ls1p1 "00:00:00:00:01:11 10.244.2.11"

check ovn-nbctl lsp-add ls1 ls1-to-cluster-router \
    -- lsp-set-type ls1-to-cluster-router router \
    -- lsp-set-options ls1-to-cluster-router router-port=cluster-router-to-ls1 \
    -- lsp-set-addresses ls1-to-cluster-router router

# Add cluster-router ports
check ovn-nbctl lrp-add cluster-router cluster-router-to-ls1 "00:00:00:0f:01:01" 10.244.2.1/24 \
    -- lrp-add cluster-router cluster-router-to-join "00:00:00:0f:02:01" 100.64.0.1/16 \
    -- lrp-set-gateway-chassis cluster-router-to-ls1 hv1 10 \
    -- --policy=src-ip lr-route-add cluster-router 10.244.2.0/24 100.64.0.3

# Add join ports
check ovn-nbctl lsp-add join join-to-cluster-router \
    -- lsp-set-type join-to-cluster-router router \
    -- lsp-set-options join-to-cluster-router router-port=cluster-router-to-join \
    -- lsp-set-addresses join-to-cluster-router router \
    -- lsp-add join join-to-gr1 \
    -- lsp-set-type join-to-gr1 router \
    -- lsp-set-options join-to-gr1 router-port=gr1-to-join \
    -- lsp-set-addresses join-to-gr1 router

check ovn-nbctl set logical_router gr1 options:lb_force_snat_ip=router_ip \
    -- set logical_router gr1 options:snat-ct-zone=0 \
    -- set logical_router gr1 options:dynamic_neigh_routers=true

# Add gr1 ports and set natting
check ovn-nbctl lrp-add gr1 gr1-to-join "00:00:00:0f:02:03" 100.64.0.3/16 \
    -- lr-route-add gr1 10.244.0.0/16 100.64.0.1 \
    -- lr-nat-add gr1 snat 10.89.189.12 10.244.0.0/16 \
    -- lrp-add gr1 gr1-to-public1 "0a:0a:b6:fc:03:12" 10.89.189.12/24 \
    -- set logical_router gr1 options:chassis=hv1

# Add public1 ports
check ovn-nbctl lsp-add public1 public1-to-gr1 \
    -- lsp-set-type public1-to-gr1 router \
    -- lsp-set-options public1-to-gr1 router-port=gr1-to-public1 \
    -- lsp-set-addresses public1-to-gr1 router \
    -- lsp-add public1 ln1 \
    -- lsp-set-type ln1 localnet \
    -- lsp-set-options ln1 network_name=provider \
    -- lsp-set-addresses ln1 unknown

check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(ns_ls1p1)
ADD_VETH(ls1p1, ns_ls1p1, br-int, "10.244.2.11/24", "00:00:00:00:01:11", "10.244.2.1")

ADD_NAMESPACES(ns_ext1)
ADD_VETH(ln1, ns_ext1, br-ex, "10.89.189.1/24", "0a:0a:b6:fc:03:01")

NS_CHECK_EXEC([ns_ls1p1], [ping -q -c 3 -i 0.3 -w 2 10.89.189.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL default_acl_drop])
AT_KEYWORDS([acl default_acl_drop])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw

# Logical port 'vm1' in switch 'sw'.
ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "10.0.0.1/24", "f0:00:00:01:02:03", \
         "10.0.0.254")
check ovn-nbctl lsp-add sw vm1 \
-- lsp-set-addresses vm1 "f0:00:00:01:02:03 10.0.0.1"

# Logical port 'vm2' in switch 'sw'.
ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "10.0.0.2/24", "f0:00:00:01:02:05", \
"10.0.0.254")
check ovn-nbctl lsp-add sw vm2 \
-- lsp-set-addresses vm2 "f0:00:00:01:02:05 10.0.0.2"

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

AS_BOX([from-lport acl, default_acl_drop false])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=false \
    -- acl-add sw from-lport 20 "ip4 && icmp" allow-related \
    -- acl-add sw from-lport 10 "ip4" drop
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AS_BOX([from-lport acl, default_acl_drop true])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=true \
    -- acl-add sw from-lport 20 "ip4 && icmp" allow-related \
    -- acl-add sw from-lport 10 "arp" allow \
    -- --apply-after-lb acl-add sw from-lport 1 1 allow \
    -- acl-add sw to-lport 1 1 allow
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AS_BOX([from-lport acl, after LB, default_acl_drop false])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=false \
    -- --apply-after-lb acl-add sw from-lport 20 "ip4 && icmp" allow-related \
    -- --apply-after-lb acl-add sw from-lport 10 "ip4" drop
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AS_BOX([from-lport acl, after LB, default_acl_drop true])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=true \
    -- acl-add sw from-lport 1 1 allow \
    -- --apply-after-lb acl-add sw from-lport 20 "ip4 && icmp" allow-related \
    -- --apply-after-lb acl-add sw from-lport 20 "arp" allow-related \
    -- acl-add sw to-lport 1 1 allow
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AS_BOX([to-lport acl, default_acl_drop false])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=false \
    -- acl-add sw to-lport 20 "ip4 && icmp" allow-related \
    -- acl-add sw to-lport 10 "ip4" drop
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AS_BOX([to-lport acl, default_acl_drop true])
check ovn-nbctl acl-del sw
check ovn-nbctl set NB_Global . options:default_acl_drop=true \
    -- acl-add sw from-lport 1 1 allow \
    -- --apply-after-lb acl-add sw from-lport 1 1 allow \
    -- acl-add sw to-lport 20 "ip4 && icmp" allow-related \
    -- acl-add sw to-lport 20 "arp" allow
check ovn-nbctl --wait=hv sync

# 'vm1' should be able to ping 'vm2' directly.
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing CT flush backends])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 2 logical switches "foo" (192.168.1.0/24) and "bar" (172.16.1.0/24)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.
#
# Loadbalancer VIPs in 30.0.0.0/24 network.

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "172.16.1.2/24", "f0:00:0f:01:02:03", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 172.16.1.2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "172.16.1.3/24", "f0:00:0f:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 172.16.1.3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "172.16.1.4/24", "f0:00:0f:01:02:05", \
         "172.16.1.1")
check ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 172.16.1.4"

# Config OVN load-balancer with a VIP.
check ovn-nbctl lb-add lb1 30.0.0.1 "172.16.1.2,172.16.1.3,172.16.1.4" \
    -- set load_balancer lb1 options:ct_flush="true"
check ovn-nbctl ls-lb-add foo lb1

# Create another load-balancer with another VIP.
lb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3="172.16.1.2,172.16.1.3,172.16.1.4"`
check ovn-nbctl set load_balancer lb2 options:ct_flush="true"
check ovn-nbctl ls-lb-add foo lb2

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $lb2_uuid vips:'"30.0.0.2:8000"'='"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80"'

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=172.16.1.4:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3'.
OVS_START_L7([bar1], [http])
OVS_START_L7([bar2], [http])
OVS_START_L7([bar3], [http])

m4_define([LB1_CT_ENTRIES], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Remove one backend
check ovn-nbctl set load_balancer lb1 vips='"30.0.0.1"="172.16.1.2,172.16.1.3"'

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Remove whole LB
check ovn-nbctl lb-del lb1

OVS_WAIT_UNTIL([test "$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | wc -l)" = "0"])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Remove one VIP
check ovn-nbctl remove load_balancer lb2 vips '"30.0.0.2:8000"'

OVS_WAIT_UNTIL([test "$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | wc -l)" = "0"])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Remove second LB
check ovn-nbctl lb-del lb2

OVS_WAIT_UNTIL([test "$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | wc -l)" = "0"])

# Check that LB has CT flush disabled by default
check ovn-nbctl lb-add lb1 30.0.0.1 "172.16.1.2,172.16.1.3,172.16.1.4"
check ovn-nbctl ls-lb-add foo lb1

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])

# Remove one backend
check ovn-nbctl --wait=hv set load_balancer lb1 vips='"30.0.0.1"="172.16.1.2,172.16.1.3"'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])

# Remove whole LB
check ovn-nbctl --wait=hv lb-del lb1

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

####################################################################
#  ls1p1 (virtual parent of VIP)
#           \
#           ls1 -- lr1 (floating-ip) -- public1 (localnet) -- ext1
#           /
#  ls1p2 (virtual parent of VIP)
####################################################################
OVN_FOR_EACH_NORTHD([
AT_SETUP([virtual port with floating IP])
AT_SKIP_IF([test "$HAVE_ARPING" = no])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ex], [set Bridge br-ex fail-mode=standalone])

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=provider:br-ex

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Add routers
check ovn-nbctl lr-add lr1

# Add switches
check ovn-nbctl ls-add public1
check ovn-nbctl ls-add ls1

# Add ls1 ports
check ovn-nbctl lsp-add ls1 ls1p1 \
    -- lsp-set-addresses ls1p1 "00:00:00:00:01:11 10.0.0.11"

check ovn-nbctl lsp-add ls1 ls1p2 \
    -- lsp-set-addresses ls1p2 "00:00:00:00:01:12 10.0.0.12"

check ovn-nbctl lsp-add ls1 ls1-to-lr1 \
    -- lsp-set-type ls1-to-lr1 router \
    -- lsp-set-options ls1-to-lr1 router-port=lr1-to-ls1 \
    -- lsp-set-addresses ls1-to-lr1 router

# Add ls1 virtual port
check ovn-nbctl lsp-add ls1 vip \
    -- lsp-set-addresses vip "00:00:00:00:01:88 10.0.0.88" \
    -- lsp-set-type vip virtual \
    -- set logical_switch_port vip options:virtual-ip=10.0.0.88 \
    -- set logical_switch_port vip options:virtual-parents=ls1p1,ls1p2

# Add lr1 ports
check ovn-nbctl lrp-add lr1 lr1-to-ls1 "00:00:00:0f:01:01" 10.0.0.1/24 \
    -- lrp-add lr1 lr1-to-public1 "00:00:00:0f:02:01" 172.0.0.1/24 \
    -- lrp-set-gateway-chassis lr1-to-public1 hv1 10

# Add floating-ip
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.0.0.88 10.0.0.88 vip 10:54:00:00:00:88

# Add public1 ports
check ovn-nbctl lsp-add public1 public1-to-lr1 \
    -- lsp-set-type public1-to-lr1 router \
    -- lsp-set-options public1-to-lr1 router-port=lr1-to-public1 \
    -- lsp-set-addresses public1-to-lr1 router \
    -- lsp-add public1 ln1 \
    -- lsp-set-type ln1 localnet \
    -- lsp-set-options ln1 network_name=provider \
    -- lsp-set-addresses ln1 unknown

check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(ns_ls1p1)
ADD_VETH(ls1p1, ns_ls1p1, br-int, "10.0.0.11/24", "00:00:00:00:01:11", "10.0.0.1")

ADD_NAMESPACES(ns_ls1p2)
ADD_VETH(ls1p2, ns_ls1p2, br-int, "10.0.0.12/24", "00:00:00:00:01:12", "10.0.0.1")

ADD_NAMESPACES(ns_ext1)
ADD_VETH(ln1, ns_ext1, br-ex, "172.0.0.99/24", "0a:0a:b6:fc:03:01", "172.0.0.1")

# Claim vip at ls1p1: configure the virtual IP and send GARP.
NS_CHECK_EXEC([ns_ls1p1], [ip addr del 10.0.0.11/24 dev ls1p1;
                           ip addr add 10.0.0.88/24 dev ls1p1;
                           ip route add default via 10.0.0.1])
NS_EXEC([ns_ls1p1], [arping -U -c 1 -w 2 -I ls1p1 10.0.0.88])
wait_for_ports_up vip
check ovn-nbctl --wait=hv sync

# ping virtual IP from ext1
NS_CHECK_EXEC([ns_ext1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.88 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# ping floating virtual IP from ext1
NS_CHECK_EXEC([ns_ext1], [ping -q -c 3 -i 0.3 -w 2 172.0.0.88 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Move virtual IP to ls1p2
NS_CHECK_EXEC([ns_ls1p1], [ip addr del 10.0.0.88/24 dev ls1p1])
NS_CHECK_EXEC([ns_ls1p2], [ip addr del 10.0.0.12/24 dev ls1p2;
                           ip addr add 10.0.0.88/24 dev ls1p2;
                           ip route add default via 10.0.0.1])
NS_EXEC([ns_ls1p2], [arping -U -c 1 -w 2 -I ls1p2 10.0.0.88])

wait_column "ls1p2" Port_Binding virtual_parent logical_port=vip
check ovn-nbctl --wait=hv sync

# ping virtual IP from ext1
NS_CHECK_EXEC([ns_ext1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.88 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# ping floating virtual IP from ext1
NS_CHECK_EXEC([ns_ext1], [ping -q -c 3 -i 0.3 -w 2 172.0.0.88 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL and committing to conntrack])
AT_KEYWORDS([acl])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add r1
check ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24
check ovn-nbctl lrp-add r1 r1_s2 00:de:ad:fe:00:02 173.0.2.1/24

check ovn-nbctl ls-add s1
check ovn-nbctl lsp-add s1 s1_r1
check ovn-nbctl lsp-set-type s1_r1 router
check ovn-nbctl lsp-set-addresses s1_r1 router
check ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1

check ovn-nbctl ls-add s2
check ovn-nbctl lsp-add s2 s2_r1
check ovn-nbctl lsp-set-type s2_r1 router
check ovn-nbctl lsp-set-addresses s2_r1 router
check ovn-nbctl lsp-set-options s2_r1 router-port=r1_s2

check ovn-nbctl lsp-add s1 vm1
check ovn-nbctl lsp-set-addresses vm1 "00:de:ad:01:00:01 173.0.1.2"

check ovn-nbctl lsp-add s2 vm2
check ovn-nbctl lsp-set-addresses vm2 "00:de:ad:01:00:02 173.0.2.2"

check ovn-nbctl lsp-add s2 vm3
check ovn-nbctl lsp-set-addresses vm3 "00:de:ad:01:00:03 173.0.2.3"

check ovn-nbctl lb-add lb1 30.0.0.1:80 173.0.2.2:80 udp
check ovn-nbctl lb-add lb2 20.0.0.1:80 173.0.1.2:80 udp
check ovn-nbctl lb-add lb1 30.0.0.1 173.0.2.2
check ovn-nbctl lb-add lb2 173.0.2.250 173.0.1.3
check ovn-nbctl ls-lb-add s1 lb1
check ovn-nbctl ls-lb-add s2 lb2

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "173.0.1.2/24", "00:de:ad:01:00:01", \
         "173.0.1.1")
ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "173.0.2.2/24", "00:de:ad:01:00:02", \
         "173.0.2.1")
ADD_NAMESPACES(vm3)
ADD_VETH(vm3, vm3, br-int, "173.0.2.250/24", "00:de:ad:01:00:03", \
         "173.0.2.1")

check ovn-nbctl acl-add s1 from-lport 1001 "ip" allow
check ovn-nbctl acl-add s1 to-lport 1002 "ip" allow
check ovn-nbctl acl-add s2 from-lport 1003 "ip" allow
check ovn-nbctl acl-add s2 to-lport 1004 "ip" allow
check ovn-nbctl --wait=hv sync
AS_BOX([initial ping])
# Send ping in background. Same ping, same flow throughout the test
on_exit 'kill $(pidof ping)'
NS_EXEC([vm1], [ping -c 10000 -i 0.1 30.0.0.1 > icmp.txt &])

# Check for conntrack entries
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(173.0.1.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=173.0.1.2,dst=173.0.2.2,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2
])

check ovn-nbctl acl-del s1 from-lport 1001 "ip"
check ovn-nbctl acl-del s1 to-lport 1002 "ip"
check ovn-nbctl acl-del s2 from-lport 1003 "ip"
check ovn-nbctl acl-del s2 to-lport 1004 "ip"

AS_BOX([acl drop echo request])
check ovn-nbctl --log --severity=alert --name=drop-flow-s1 acl-add s1 to-lport 2001 icmp4 drop
# acl-drop to-lport s1 apply to traffic from s1 to vm1 and s1 to r1.
check ovn-nbctl --wait=hv sync

# Check that traffic is blocked
# Wait for some packets to hit the rule to avoid potential race conditions. Then count packets.
OVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s1` -gt "0"])
total_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)

# Wait some time and check whether packets went through. In the worse race condition, the sleep is too short
# and this test will still succeed.
sleep 1
OVS_WAIT_UNTIL([
        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)
        test "${total_icmp1_pkts}" -eq "${total_icmp_pkts}"
])

AS_BOX([acl allow-related echo request])
check ovn-nbctl acl-add s1 to-lport 2002 "icmp4 && ip4.src == 173.0.1.2" allow-related
# This rule has higher priority than to-lport 2001 icmp4 drop.
# So traffic from s1 (w/ src=173.0.1.2) to r1 should be accepted
# (return) traffic from s1 to vm1 should be accepted as return traffic
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([
        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)
        test "${total_icmp1_pkts}" -gt "${total_icmp_pkts}"
])

# Check we did not break handling acl-drop for existing flows
AS_BOX([acl drop echo request in s2])
check ovn-nbctl acl-del s1 to-lport 2001 icmp4
check ovn-nbctl --log --severity=alert --name=drop-flow-s2 acl-add s2 to-lport 2001 icmp4 drop
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s2` -gt "0"])

OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
      sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
icmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>
])
total_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)

# Allow ping again
AS_BOX([acl allow echo request in s2])
check ovn-nbctl acl-add s2 to-lport 2005 icmp4 allow
check ovn-nbctl --wait=hv sync
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2
])
OVS_WAIT_UNTIL([
        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)
        test "${total_icmp1_pkts}" -gt "${total_icmp_pkts}"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 LR to test ARP proxy combinations])
AT_KEYWORDS([proxy-arp])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])
ovs-ofctl add-flow br-ext action=normal

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR - R1 and two LSs - foo and bar, R1 has switches foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it
#
#    br-ext -- localnet -- foo -- R1 -- bar

check ovs-vsctl set open . external-ids:ovn-bridge-mappings=provider:br-ext

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:arp_proxy="0a:58:a9:fe:01:01 169.254.239.254 169.254.239.2 169.254.238.0/24 192.168.1.100 192.168.1.200" options:router-port=foo addresses='"router"'

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:arp_proxy="169.254.239.253" options:router-port=bar addresses='"router"'


# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "169.254.239.2")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:04", \
         "169.254.239.254")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:04 192.168.1.3"

# Logical port 'foo3' in switch 'foo'.
ADD_NAMESPACES(foo3)
ADD_VETH(foo3, foo3, br-int, "192.168.1.4/24", "f0:00:00:01:02:05", \
         "169.254.238.1")
check ovn-nbctl lsp-add foo foo3 \
-- lsp-set-addresses foo3 "f0:00:00:01:02:05 192.168.1.4"

ADD_NAMESPACES(foo4)
ADD_VETH(foo4, foo4, br-int, "192.168.1.6/24", "f0:00:00:01:02:11", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo4 \
-- lsp-set-addresses foo4 "f0:00:00:01:02:11 192.168.1.6"

# Logical port 'ext1' in switch 'foo'
ADD_NAMESPACES(ext1)
ADD_VETH(ext1, ext1, br-ext, "192.168.1.5/24", "f0:00:00:01:02:06", \
         "192.168.1.100",)
check ovn-nbctl lsp-add foo ln -- lsp-set-options ln network_name=provider
check ovn-nbctl lsp-set-type ln localnet
check ovn-nbctl lsp-set-addresses ln unknown

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:07", \
"169.254.239.253")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:07 192.168.2.2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "192.168.2.3/24", "f0:00:00:01:02:10", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:00:01:10:10 192.168.2.3"

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

NETNS_START_TCPDUMP([foo1], [-nn -e -i foo1 'ether dst 0a:58:a9:fe:01:01 and icmp'], [foo1-icmp])

# 'foo1' should be able to ping 'bar1'
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo1-icmp.tcpdump| wc -l)
    test "${total_pkts}" = "3"
])

NETNS_START_TCPDUMP([foo2], [-nn -e -i foo2 'ether dst 0a:58:a9:fe:01:01 and icmp'], [foo2-icmp])

# 'foo2' should be able to ping 'bar1'
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo2-icmp.tcpdump| wc -l)
    test "${total_pkts}" = "3"
])

NETNS_START_TCPDUMP([foo3], [-nn -e -i foo3 'ether dst 0a:58:a9:fe:01:01 and icmp'], [foo3-icmp])

# 'foo3' should be able to ping 'bar1'
NS_CHECK_EXEC([foo3], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo3-icmp.tcpdump| wc -l)
    test "${total_pkts}" = "3"
])

NETNS_START_TCPDUMP([ext1], [-nn -e -i ext1 'ether dst 0a:58:a9:fe:01:01 and icmp'], [ext1-icmp])

# 'ext1' should be able to ping 'bar1'
NS_CHECK_EXEC([ext1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat ext1-icmp.tcpdump| wc -l)
    test "${total_pkts}" = "3"
])

check ovn-nbctl lr-route-add R1 169.254.240.0/24 192.168.1.200
NETNS_START_TCPDUMP([foo4], [-nn -c 4 -e -i foo4 arp[[24:4]]=0xc0a801c8], [foo4-arp])

NS_CHECK_EXEC([bar2], [ping -q -c 5 -i 0.3 -w 2 169.254.240.10],[ignore],[ignore])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo4-arp.tcpdump| wc -l)
    test "${total_pkts}" = "4"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 LR to test ARP proxy combinations - IPv6])
AT_KEYWORDS([proxy-arp])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR - R1 and two LSs - foo and bar, R1 has switches foo (fd11::/64) and
# bar (fd12::/64) connected to it
#
#    foo -- R1 -- bar

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:arp_proxy="0a:58:a9:fe:01:01 fd7b:6b4d:7b25:d22f::1 fd7b:6b4d:7b25:d22f::2 fd7b:6b4d:7b25:d22d::0/64" options:router-port=foo addresses='"router"'

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:arp_proxy="fd7b:6b4d:7b25:d22f::3" options:router-port=bar addresses='"router"'

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd7b:6b4d:7b25:d22f::1", "nodad")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd11::3/64", "f0:00:00:01:02:04", \
         "fd7b:6b4d:7b25:d22f::2", "nodad")
check ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:04 fd11::3"

# Logical port 'foo3' in switch 'foo'.
ADD_NAMESPACES(foo3)
ADD_VETH(foo3, foo3, br-int, "fd11::4/64", "f0:00:00:01:02:05", \
         "fd7b:6b4d:7b25:d22d::1", "nodad")
check ovn-nbctl lsp-add foo foo3 \
-- lsp-set-addresses foo3 "f0:00:00:01:02:05 fd11::4"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:06", \
         "fd7b:6b4d:7b25:d22f::3", "nodad")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:06 fd12::2"

# wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Force ipv6 nd neighbour solicitation
NS_EXEC([foo1], [ping6 -c 1 fd12::2])

NETNS_START_TCPDUMP([foo1], [-vvvv -ttt -nn -e -i foo1 'ether dst 0a:58:a9:fe:01:01 and icmp6'], [foo1-icmp6])

# 'foo1' should be able to ping 'bar1'
NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo1-icmp6.tcpdump| grep "echo request" | wc -l)
    test "${total_pkts}" = "3"
])

# Force ipv6 nd neighbour solicitation
NS_EXEC([foo2], [ping6 -c 1 fd12::2])

NETNS_START_TCPDUMP([foo2], [-vvvv -ttt -nn -e -i foo2 'ether dst 0a:58:a9:fe:01:01 and icmp6'], [foo2-icmp6])

# 'foo2' should be able to ping 'bar1'
NS_CHECK_EXEC([foo2], [ping6 -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo2-icmp6.tcpdump| grep "echo request" | wc -l)
    test "${total_pkts}" = "3"
])

# Force ipv6 nd neighbour solicitation
NS_EXEC([foo3], [ping6 -c 1 fd12::2])

NETNS_START_TCPDUMP([foo3], [-vvvv -ttt -nn -e -i foo3 'ether dst 0a:58:a9:fe:01:01 and icmp6'], [foo3-icmp6])

# 'foo3' should be able to ping 'bar1'
NS_CHECK_EXEC([foo3], [ping6 -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    total_pkts=$(cat foo3-icmp6.tcpdump| grep "echo request" | wc -l)
    test "${total_pkts}" = "3"
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

# This tests port->up/down and ovn-installed after adding and removing Ports and Interfaces.
# 3 Conditions x 3 tests:
# - 3 Conditions:
#   - In normal conditions
#   - Remove interface while starting and stopping SB and Controller
#   - Remove and add back interface while starting and stopping SB and Controller
# - 3 tests:
#   - Add/Remove Logical Port
#   - Add/Remove iface-id
#   - Add/Remove Interface
# Each tests/conditions checks for
# - Port_binding->chassis
# - Port up or down
# - ovn-installed
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-install on slow ovsdb])
AT_KEYWORDS([ovn-install])

OVS_TRAFFIC_VSWITCHD_START()
# Restart ovsdb-server, this time with tcp
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
start_daemon ovsdb-server --remote=punix:"$OVS_RUNDIR"/db.sock --remote=ptcp:0:127.0.0.1

ovn_start
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
PARSE_LISTENING_PORT([$ovs_base/ovsdb-server.log], [TCP_PORT])
start_daemon ovn-controller tcp:127.0.0.1:$TCP_PORT

check ovn-nbctl ls-add ls1
check ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16

check ovn-nbctl --wait=hv sync

add_logical_ports() {
  echo Adding logical ports
  check ovn-nbctl lsp-add ls1 lsp1
  check ovn-nbctl lsp-add ls1 lsp2
}

remove_logical_ports() {
  echo Removing logical ports
  check ovn-nbctl lsp-del lsp1
  check ovn-nbctl lsp-del lsp2
}

add_ovs_interface() {
  echo Adding interface $1 $2
  ovs-vsctl --no-wait -- add-port br-int $1 \
                      -- set Interface $1 external_ids:iface-id=$2 \
                      -- set Interface $1 type=internal
}
add_ovs_interfaces() {
  add_ovs_interface vif1 lsp1
  add_ovs_interface vif2 lsp2
}
remove_ovs_interface() {
  echo Removing interface $1
  check ovs-vsctl --no-wait -- del-port $1
}
remove_ovs_interfaces() {
  remove_ovs_interface vif1
  remove_ovs_interface vif2
}
add_iface_ids() {
  echo Adding iface-id vif1 lsp1
  ovs-vsctl --no-wait -- set Interface vif1 external_ids:iface-id=lsp1
  echo Adding iface-id vif2 lsp2
  ovs-vsctl --no-wait -- set Interface vif2 external_ids:iface-id=lsp2
}
remove_iface_id() {
  echo Removing iface-id $1
  check ovs-vsctl remove Interface $1 external_ids iface-id
}
remove_iface_ids() {
  remove_iface_id vif1
  remove_iface_id vif2
}
wait_for_local_bindings() {
  OVS_WAIT_UNTIL(
      [test `ovs-appctl -t ovn-controller debug/dump-local-bindings | grep interface | wc -l` -eq 2],
      [kill -CONT $(cat ovn-sb/ovsdb-server.pid)]
  )
}
ensure_controller_run() {
# We want to make sure controller could run at least one full loop.
# We can't use wait=hv as sb might be sleeping.
# Use 2 ovn-appctl to guarentee that ovn-controller run the full loop, and not just the unixctl handling
  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = "xrunning"])
  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = "xrunning"])
}
sleep_ovsdb() {
  echo OVSDB going to sleep
  AT_CHECK([kill -STOP $(cat ovsdb-server.pid)])
}
wake_up_ovsdb() {
  echo OVSDB waking up
  AT_CHECK([kill -CONT $(cat ovsdb-server.pid)])
}
check_ovn_installed() {
  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif1 external_ids:ovn-installed` = '"true"'])
  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif2 external_ids:ovn-installed` = '"true"'])
}
check_ovn_uninstalled() {
  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif2 external_ids:ovn-installed` = x])
  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif1 external_ids:ovn-installed` = x])
}
check_ports_up() {
  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'true'])
  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'true'])
}
check_ports_down() {
  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'false'])
  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'false'])
}

check_ports_bound() {
  ch=$(fetch_column Chassis _uuid name=hv1)
  wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
  wait_row_count Port_Binding 1 logical_port=lsp2 chassis=$ch
}
check_ports_unbound() {
  wait_column "" Port_Binding chassis logical_port=lsp1
  wait_column "" Port_Binding chassis logical_port=lsp2
}
add_logical_ports
add_ovs_interfaces
wait_for_local_bindings
wait_for_ports_up
check ovn-nbctl --wait=hv sync
############################################################
########## Remove interface while removing iface-id ########
############################################################
AS_BOX(["Remove interface while removing iface-id"])
stop_ovsdb_controller_updates $TCP_PORT
remove_iface_id vif1
ensure_controller_run
# OVSDB should be seen as ro now
remove_iface_id vif2
ensure_controller_run
# Controller delaying ovn-install removal for vif2 as ovsdb ro
sleep_controller
restart_ovsdb_controller_updates $TCP_PORT
remove_ovs_interface vif2
# vif2, for which we want to remove ovn-install, is deleted
wake_up_controller
check_ovn_uninstalled
check_ports_down
check_ports_unbound
add_ovs_interface vif2 lsp2
add_iface_ids
check_ovn_installed
check_ports_up
check_ports_bound
############################################################
################### Add/Remove iface-id ####################
############################################################
AS_BOX(["iface-id removal and added back (no sleeping sb or controller)"])
remove_iface_ids
check_ovn_uninstalled
check_ports_down
check_ports_unbound
add_iface_ids
check_ovn_installed
check_ports_up
check_ports_bound

AS_BOX(["iface-id removal"])
sleep_sb
remove_iface_ids
ensure_controller_run
sleep_controller
wake_up_sb
wake_up_controller
check_ovn_uninstalled
check_ports_down
check_ports_unbound
add_iface_ids
check ovn-nbctl --wait=hv sync

AS_BOX(["iface-id removal 2"])
# Block IDL from ovn-controller to OVSDB
stop_ovsdb_controller_updates $TCP_PORT
remove_iface_id vif2
ensure_controller_run

# OVSDB should now be seen as read-only by ovn-controller
remove_iface_id vif1
ensure_controller_run

# Restart connection from ovn-controller to OVSDB
restart_ovsdb_controller_updates $TCP_PORT
check_ovn_uninstalled
check_ports_down
check_ports_unbound

add_iface_ids
check ovn-nbctl --wait=hv sync

AS_BOX(["iface-id removal and added back"])
sleep_sb
remove_iface_ids
ensure_controller_run
sleep_controller
add_iface_ids
wake_up_sb
wake_up_controller
check_ovn_installed
check_ports_up
check_ports_bound
############################################################
###################### Add/Remove Interface ################
############################################################
AS_BOX(["Interface removal and added back (no sleeping sb or controller)"])
remove_ovs_interfaces
check_ovn_uninstalled
check_ports_down
check_ports_unbound
add_ovs_interfaces
check_ovn_installed
check_ports_up
check_ports_bound
check ovn-nbctl --wait=hv sync

AS_BOX(["Interface removal"])
sleep_sb
remove_ovs_interfaces
ensure_controller_run
sleep_controller
wake_up_sb
wake_up_controller
check_ovn_uninstalled
check_ports_down
check_ports_unbound
add_ovs_interfaces
check ovn-nbctl --wait=hv sync

AS_BOX(["Interface removal and added back"])
sleep_sb
remove_ovs_interfaces
ensure_controller_run
sleep_controller
add_ovs_interfaces
wake_up_sb
wake_up_controller
check_ovn_installed
check_ports_up
check_ports_bound
check ovn-nbctl --wait=hv sync
############################################################
###################### Add/Remove Logical Port #############
############################################################
AS_BOX(["Logical port removal and added back (no sleeping sb or controller)"])
remove_logical_ports
check_ovn_uninstalled
check_ports_unbound
sleep_ovsdb
add_logical_ports
ensure_controller_run
wake_up_ovsdb
check_ovn_installed
check_ports_up
check_ports_bound
check ovn-nbctl --wait=hv sync

AS_BOX(["Logical port removal"])
sleep_sb
remove_logical_ports
ensure_controller_run
sleep_controller
wake_up_sb
wake_up_controller
check_ovn_uninstalled
check_ports_unbound
add_logical_ports
check ovn-nbctl --wait=hv sync

AS_BOX(["Logical port removal and added back"])
sleep_sb
remove_logical_ports
ensure_controller_run
sleep_controller
add_logical_ports
wake_up_sb
wake_up_controller
check_ovn_installed
check_ports_up
check_ports_bound

AS_BOX(["Leave some ovn-installed while closing ovn-controller"])
# Block IDL from ovn-controller to OVSDB
stop_ovsdb_controller_updates $TCP_PORT
remove_iface_id vif2
ensure_controller_run

# OVSDB should now be seen as read-only by ovn-controller
remove_iface_id vif1
check ovn-nbctl --wait=hv sync

# Stop ovsdb before ovn-controller to ensure it's not updated
as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

# Don't use OVS_APP_EXIT... to use --restart to avoid cleaning up the databases.
TMPPID=$(cat $OVS_RUNDIR/ovn-controller.pid)
check ovs-appctl -t ovn-controller exit --restart
OVS_WAIT_WHILE([kill -0 $TMPPID 2>/dev/null])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn mirroring])
AT_KEYWORDS([mirror])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-mirror])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovs-ofctl add-flow br-mirror action=normal

check_uuid ovn-nbctl create Logical_Router name=R1 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 2001::1/64
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 2002::1/64
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "2001::2/64", "f0:00:00:01:02:03", \
         "2001::1", "nodad", "192.168.1.2/24", "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2 2001::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "2002::2/64", "f0:00:00:01:02:05", \
         "2002::1", "nodad", "192.168.2.2/24", "192.168.2.1")
check ovn-nbctl --wait=hv lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2 2002::2"

# Warm up the datapath (needed to make the DPDK datapth happy)
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

check ovn-nbctl mirror-add mirror0 gre 1 to-lport 172.16.0.100
check ovn-nbctl lsp-attach-mirror bar1 mirror0

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(mirror)
ADD_VETH(mirror, mirror, br-mirror, "2003::b/64", "f0:00:00:01:07:06", \
         "2003::1", "nodad", "172.16.0.100/24", "172.16.0.1")
AT_CHECK([ip addr add 172.16.0.101/24 dev br-mirror])
AT_CHECK([ip addr add 2003::a/64 dev br-mirror nodad])
AT_CHECK([ip link set dev br-mirror up])

NETNS_START_TCPDUMP([mirror], [-c 3 -neei mirror proto GRE], [gre_mirror4])

NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    n_packets=$(grep "GRE" -c gre_mirror4.tcpdump)
    test "${n_packets}" = "3"
])

check ovn-nbctl mirror-del mirror0
check ovn-nbctl mirror-add mirror1 gre 2 to-lport 2003::b

check ovn-nbctl --wait=hv lsp-attach-mirror bar1 mirror1

NETNS_START_TCPDUMP([mirror], [-c 3 -neei mirror proto GRE], [gre_mirror6])

NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
    n_packets=$(grep "GRE" -c gre_mirror6.tcpdump)
    test "${n_packets}" = "3"
])

check ovn-nbctl mirror-del mirror1
check ovn-nbctl mirror-add mirror2 erspan 3 to-lport 172.16.0.100
check ovn-nbctl --wait=hv lsp-attach-mirror bar1 mirror2

NETNS_START_TCPDUMP([mirror], [-c 3 -neei mirror ip[[22:2]]=0x88be], [erspan_mirror4])

NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    n_packets=$(grep "gre-proto-0x88be" -c erspan_mirror4.tcpdump)
    test "${n_packets}" = "3"
])

check ovn-nbctl mirror-del mirror2
check ovn-nbctl mirror-add mirror3 erspan 4 to-lport 2003::b
check ovn-nbctl --wait=hv lsp-attach-mirror bar1 mirror3

NETNS_START_TCPDUMP([mirror], [-c 3 -neei mirror ip6[[42:2]]=0x88be], [erspan_mirror6])

NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
OVS_WAIT_UNTIL([
    n_packets=$(grep "gre-proto-0x88be" -c erspan_mirror6.tcpdump)
    test "${n_packets}" = "3"
])

uuid=$(fetch_column nb:mirror _uuid name="mirror3")
check ovn-nbctl --wait=hv set mirror $uuid type=gre

NETNS_START_TCPDUMP([mirror], [-c 3 -neei mirror proto GRE], [gre2_mirror6])

NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
    n_packets=$(grep "GRE" -c gre2_mirror6.tcpdump)
    test "${n_packets}" = "3"
])

killall tcpdump

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Tiered ACLs])
AT_KEYWORDS([acl])
TAG_UNSTABLE

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller

start_daemon ovn-controller

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp1 -- lsp-set-addresses lsp1 "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-add ls lsp2 -- lsp-set-addresses lsp2 "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl --wait=hv pg-add pg lsp1 lsp2

ADD_NAMESPACES(lsp1)
ADD_VETH(lsp1, lsp1, br-int, "10.0.0.1/24", "00:00:00:00:00:01")
ADD_NAMESPACES(lsp2)
ADD_VETH(lsp2, lsp2, br-int, "10.0.0.2/24", "00:00:00:00:00:02")

m4_define([PING_PCT], [grep -o "[[0-9]]\{1,3\}% packet loss"])

acl_test() {
    direction=$1
    options=$2
    thing=$3

    # First a baseline. If traffic isn't being allowed, then something is
    # very wrong.
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
0% packet loss
])
    # Add an untiered drop ACL. This should cause pings to fail.
    check ovn-nbctl --wait=hv $options acl-add $thing $direction 1000 "ip4.dst == 10.0.0.2" drop
    acl1_uuid=$(ovn-nbctl --bare --columns _uuid find ACL priority=1000)
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
100% packet loss
])

    # Change the tier to 3. Despite there being "holes" in tiers 0, 1, and 2,
    # the ACL should still apply, and pings should fail.
    check ovn-nbctl --wait=hv set ACL $acl1_uuid tier=3
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
100% packet loss
])

    # Add a tier-0 ACL that allows the traffic. The priority is only 4, but
    # since it is a higher tier, the traffic should be allowed.
    check ovn-nbctl --wait=hv $options acl-add $thing $direction 4 "ip4.dst == 10.0.0.2" allow
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
0% packet loss
])

    # Add a higher-priority tier-0 ACL that passes. This should cause the traffic
    # to pass over the lower-priority tier-0 "allow" ACL, and move to the tier-3
    # ACL that drops the traffic.
    check ovn-nbctl --wait=hv $options acl-add $thing $direction 1000 "ip4.dst == 10.0.0.2" pass
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
100% packet loss
])

    # Remove the "pass" ACL, and the "allow" rule should kick back in.
    check ovn-nbctl --wait=hv --tier=0 acl-del $thing $direction 1000 "ip4.dst == 10.0.0.2"
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
0% packet loss
])

    # Removing the remaining 0-tier ACL should make traffic go back to being dropped.
    check ovn-nbctl --wait=hv acl-del $thing $direction 4 "ip4.dst == 10.0.0.2"
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
100% packet loss
])

    # Adding a higher-priority "pass" ACL at tier 3 should result in using the
    # default ACL action. Currently, the default is to allow traffic, so the
    # traffic should be allowed.
    check ovn-nbctl --wait=hv --tier=3 $options acl-add $thing $direction 2000 "ip4.dst == 10.0.0.2" pass
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
0% packet loss
])

    # Change the default ACL action to drop, and now the traffic should be dropped.
    check ovn-nbctl --wait=hv set NB_Global . options:default_acl_drop=true
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
100% packet loss
])

    # Removing all ACLs (and setting the default acl drop back to false) should
    # make traffic go back to passing.
    check ovn-nbctl clear NB_Global . options
    check ovn-nbctl --wait=hv acl-del $thing
    NS_CHECK_EXEC([lsp1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | PING_PCT], \
[0], [dnl
0% packet loss
])
}

acl_test from-lport "" ls
acl_test from-lport "--apply-after-lb" ls
acl_test to-lport "" ls
acl_test from-lport "" pg
acl_test from-lport "--apply-after-lb" pg
acl_test to-lport "" pg

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancer with localnet port])
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add ro
check ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 192.168.0.1/24
check ovn-nbctl lrp-add ro ro-pub 00:00:00:00:01:01 10.0.0.1/24

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw sw-vm1 \
    -- lsp-set-addresses sw-vm1 "00:00:00:00:00:02 192.168.0.2"
check ovn-nbctl lsp-add sw sw-ro \
    -- lsp-set-type sw-ro router \
    -- lsp-set-addresses sw-ro router \
    -- lsp-set-options sw-ro router-port=ro-sw

check ovn-nbctl ls-add pub
check ovn-nbctl lsp-add pub sw-ln \
    -- lsp-set-type sw-ln localnet \
    -- lsp-set-addresses sw-ln unknown \
    -- lsp-set-options sw-ln network_name=phys
check ovn-nbctl lsp-add pub pub-ro \
    -- lsp-set-type pub-ro router \
    -- lsp-set-addresses pub-ro router \
    -- lsp-set-options pub-ro router-port=ro-pub

check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

ADD_NAMESPACES(sw-vm1)
ADD_VETH(sw-vm1, sw-vm1, br-int, "192.168.0.2/24", "00:00:00:00:00:02", \
         "192.168.0.1")

ADD_NAMESPACES(ln)
ADD_VETH(ln, ln, br-phys, "10.0.0.2/24", "00:00:00:00:01:02", \
         "10.0.0.1")

# We have the basic network set up. Now let's add a load balancer
# on the "pub" logical switch.

check ovn-nbctl lb-add ln-lb 172.16.0.1:80 192.168.0.2:80 tcp
check ovn-nbctl ls-lb-add pub ln-lb
check ovn-nbctl --wait=hv sync

# Add a route so that the localnet port can reach the load balancer
# VIP.
NS_CHECK_EXEC([ln], [ip route add 172.16.0.1 via 10.0.0.1])
NS_CHECK_EXEC([ln], [ip route add 192.168.0.0/24 via 10.0.0.1])

OVS_START_L7([sw-vm1], [http])

NS_CHECK_EXEC([ln], [wget 172.16.0.1 -t 5 -T 1 --retry-connrefused -v -o wget.log])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.0.2,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Traffic to router port via LLA])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:00:01 fd00::1/64

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 vif0 \
    -- lsp-set-addresses vif0 "00:00:00:00:00:02 fd00::2"
check ovn-nbctl lsp-add ls0 ls0-lr0 \
    -- lsp-set-type ls0-lr0 router \
    -- lsp-set-addresses ls0-lr0 router \
    -- lsp-set-options ls0-lr0 router-port=lr0-ls0

ADD_NAMESPACES(vif0)
ADD_VETH(vif0, vif0, br-int, "fd00::2/64", "00:00:00:00:00:02", "fd00::1", "nodad")
OVS_WAIT_UNTIL([test "$(ip netns exec vif0 ip a | grep fe80:: | grep tentative)" = ""])

check ovn-nbctl set logical_router lr0 options:always_learn_from_arp_request=false

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=sb sync

NS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

check_row_count mac_binding 1 mac=\"00:00:00:00:00:02\"
check ovn-sbctl --all destroy mac_binding

check ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=true

NS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

check_row_count mac_binding 1 mac=\"00:00:00:00:00:02\"

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ct_flush on logical router load balancer])
AT_KEYWORDS([ct-lr-flush])
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24

check ovn-nbctl set logical_router R1 options:chassis=hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add sw0 sw0-vm \
    -- lsp-set-addresses sw0-vm "00:00:01:01:02:04 192.168.1.2/24"

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovn-nbctl lsp-add public public-vm \
   -- lsp-set-addresses public-vm "00:00:02:01:02:04 172.16.1.2/24"

ADD_NAMESPACES(sw0-vm)
ADD_VETH(sw0-vm, sw0-vm, br-int, "192.168.1.2/24", "00:00:01:01:02:04", \
         "192.168.1.1")

ADD_NAMESPACES(public-vm)
ADD_VETH(public-vm, public-vm, br-int, "172.16.1.2/24", "00:00:02:01:02:04", \
         "172.16.1.1")

# Start webservers in 'server'.
OVS_START_L7([sw0-vm], [http])

# Create a load balancer and associate to R1
check ovn-nbctl lb-add lb1 172.16.1.150:80 192.168.1.2:80 \
    -- set load_balancer lb1 options:ct_flush="true"
check ovn-nbctl lr-lb-add R1 lb1

check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([public-vm], [wget 172.16.1.150 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.150) | wc -l ], [0], [dnl
1
])

check ovn-nbctl --wait=hv lb-del lb1

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.150) | wc -l ], [0], [dnl
0
])

check ovn-nbctl lb-add lb2 172.16.1.151:80 192.168.1.2:80
check ovn-nbctl lr-lb-add R1 lb2

check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([public-vm], [wget 172.16.1.151 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.151) | wc -l ], [0], [dnl
1
])

check ovn-nbctl --wait=hv lb-del lb2

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.151) | wc -l ], [0], [dnl
1
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

AT_SETUP([load balancing in gateway router - SCTP])
AT_SKIP_IF([test $HAVE_SCTP = no])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb sctp])

# Make sure the SCTP kernel module is loaded.
LOAD_MODULE([sctp])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller.
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start the ovn-controller.
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer protocol=sctp vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:12345,192.168.2.2:12345"'

# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.
check_uuid ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:12345)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [sctp])
OVS_START_L7([bar1], [sctp])

on_exit "ovs-ofctl -O OpenFlow13 dump-flows br-int"

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [nc --sctp --recv-only 30.0.0.1 12345 > client$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed 's/,protoinfo=.*$//' | uniq], [0], [dnl
sctp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
sctp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [nc --sctp --recv-only 30.0.0.2 8000 > clients$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed 's/,protoinfo=.*$//' | uniq], [0], [dnl
sctp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
sctp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2
])

check_est_flows () {
    n=$(ovs-ofctl dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable lr_in_dnat) | grep "+est" \
        | grep "ct_mark=$1" | sed -n 's/.*n_packets=\([[0-9]]\{1,\}\).*/\1/p')

    echo "n_packets=$n"
    test -n "$n" && test "$n" != "0"
}

OVS_WAIT_UNTIL([check_est_flows 0x2], [check established flows])


check ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.2"

# Destroy the load balancer and create again. ovn-controller will
# clear the OF flows and re add again and clears the n_packets
# for these flows.
check ovn-nbctl destroy load_balancer $uuid
uuid=`ovn-nbctl  create load_balancer protocol=sctp vips:30.0.0.1="192.168.1.2,192.168.2.2"`
check ovn-nbctl set logical_router R2 load_balancer=$uuid

check ovs-appctl dpctl/flush-conntrack

# Config OVN load-balancer with another VIP (this time with ports).
check ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:12345,192.168.2.2:12345"'

ovn-nbctl list load_balancer
ovn-sbctl dump-flows R2
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=$(ovn-debug lflow-stage-to-oftable lr_out_snat) | grep 'nat(src=20.0.0.2)'])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [nc --sctp --recv-only 30.0.0.2 8000 > clients$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed 's/,protoinfo=.*$//' | uniq], [0], [dnl
sctp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10
sctp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed 's/,protoinfo=.*$//' | uniq], [0], [dnl
sctp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>
sctp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>
])

OVS_WAIT_UNTIL([check_est_flows 0xa], [check established flows])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router - client behind LB with SNAT])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add lr \
    -- set logical_router lr options:chassis=hv1
check ovn-nbctl lrp-add lr lr-ls1 00:00:00:00:01:00 41.41.41.2/24
check ovn-nbctl lrp-add lr lr-ls2 00:00:00:00:02:00 42.42.42.2/24
check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2

check ovn-nbctl lsp-add ls1 ls1-lr
check ovn-nbctl lsp-set-addresses ls1-lr 00:00:00:00:01:00
check ovn-nbctl lsp-set-type ls1-lr router
check ovn-nbctl lsp-set-options ls1-lr router-port=lr-ls1
check ovn-nbctl lsp-add ls1 vm1
check ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01

check ovn-nbctl lsp-add ls2 ls2-lr
check ovn-nbctl lsp-set-addresses ls2-lr 00:00:00:00:02:00
check ovn-nbctl lsp-set-type ls2-lr router
check ovn-nbctl lsp-set-options ls2-lr router-port=lr-ls2
check ovn-nbctl lsp-add ls2 vm2
check ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02

dnl LB using the router IP connected to vm2 as VIP.
check ovn-nbctl lb-add lb-test 42.42.42.2:8080 41.41.41.1:8080 tcp \
    -- lr-lb-add lr lb-test

dnl SNAT everything coming from vm1 to the router IP (towards vm2).
check ovn-nbctl lr-nat-add lr snat 42.42.42.2 41.41.41.1

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "41.41.41.1/24", "00:00:00:00:00:01", "41.41.41.2")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.1/24", "00:00:00:00:00:02", "42.42.42.2")

dnl Start a server on vm2.
NETNS_DAEMONIZE([vm2], [nc -l -k 42.42.42.1 80], [vm2.pid])

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Test the connection originating something that uses the same source port
dnl as the LB VIP.
NS_CHECK_EXEC([vm1], [nc -z -p 8080 42.42.42.1 80], 0, [ignore], [ignore])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing affinity sessions - auto clear learnt flows])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add lr
check ovn-nbctl lrp-add lr lr-ls 00:00:00:00:01:00 42.42.42.3/24
check ovn-nbctl ls-add ls

check ovn-nbctl lsp-add ls ls-lr
check ovn-nbctl lsp-set-addresses ls-lr 00:00:00:00:01:00
check ovn-nbctl lsp-set-type ls-lr router
check ovn-nbctl lsp-set-options ls-lr router-port=lr-ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01
check ovn-nbctl lsp-add ls vm2
check ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02
check ovn-nbctl lb-add lb-test 43.43.43.43:80 42.42.42.1:8080,42.42.42.2:8080 tcp \
    -- set load_balancer lb-test options:affinity_timeout=65535 \
    -- ls-lb-add ls lb-test

dnl Start a server on vm1.
ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.1/24", "00:00:00:00:00:01", "42.42.42.3")
NETNS_DAEMONIZE([vm1], [nc -l -k 42.42.42.1 8080], [vm1.pid])

dnl Start a server on vm2.
ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.2/24", "00:00:00:00:00:02", "42.42.42.3")
NETNS_DAEMONIZE([vm2], [nc -l -k 42.42.42.2 8080], [vm2.pid])

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Test the connection.
OVS_WAIT_UNTIL([
    ip netns exec vm1 nc -z 43.43.43.43 80 &> /dev/null
])

OVS_WAIT_UNTIL([test $(ovs-ofctl dump-flows br-int | grep 'table=OFTABLE_CHK_LB_AFFINITY, n_packets' -c) -eq 1])

dnl Find the backend that was hit.
backend=$(ovs-ofctl dump-flows br-int table=OFTABLE_CHK_LB_AFFINITY | \
    grep -oE 'load:0x2a2a2a0[[12]]' | sed -n 's/load:0x2a2a2a0\(.*\)/\1/p')

dnl Remove the backend that was hit.
if [[ "$backend" == "1" ]]; then
    check ovn-nbctl set load_balancer lb-test vip:\"43.43.43.43:80\"=\"42.42.42.2:8080\"
else
    check ovn-nbctl set load_balancer lb-test vip:\"43.43.43.43:80\"=\"42.42.42.1:8080\"
fi
check ovn-nbctl --wait=hv sync

dnl The learnt flow should also be auto deleted.
AT_CHECK([ovs-ofctl dump-flows br-int | grep 'table=OFTABLE_CHK_LB_AFFINITY, n_packets' -c], [1], [dnl
0
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IP NAT add-route])
AT_KEYWORDS([ip-nat-add-route])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl lr-add lr0
check ovn-nbctl set logical_router lr0 options:chassis=hv1

check ovn-nbctl lr-add lr1
check ovn-nbctl set logical_router lr1 options:chassis=hv1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add join

check ovn-nbctl lrp-add lr0 lr-sw0 00:00:01:01:02:03 192.168.0.1/24
check ovn-nbctl lsp-add sw0 rp-sw0 -- set Logical_Switch_Port rp-sw0 \
    type=router options:router-port=lr-sw0 \
    -- lsp-set-addresses rp-sw0 router

check ovn-nbctl lrp-add lr0 lr0-join 04:00:01:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add join rp0-join -- set Logical_Switch_Port rp0-join \
    type=router options:router-port=lr0-join \
    -- lsp-set-addresses rp0-join router

check ovn-nbctl lrp-add lr1 lr-sw1 00:00:02:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add sw1 rp-sw1 -- set Logical_Switch_Port rp-sw1 \
    type=router options:router-port=lr-sw1 \
    -- lsp-set-addresses rp-sw1 router

check ovn-nbctl lrp-add lr1 lr1-join 04:00:02:01:02:03 172.16.2.2/24
check ovn-nbctl lsp-add join rp1-join -- set Logical_Switch_Port rp1-join \
    type=router options:router-port=lr1-join \
    -- lsp-set-addresses rp1-join router

ADD_NAMESPACES(sw0-p0)
ADD_VETH(sw0-p0, sw0-p0, br-int, "192.168.0.2/24", "f0:00:00:01:02:03", "192.168.0.1")
check ovn-nbctl lsp-add sw0 sw0-p0 \
    -- lsp-set-addresses sw0-p0 "f0:00:00:01:02:03 192.168.0.2"

ADD_NAMESPACES(sw1-p0)
ADD_VETH(sw1-p0, sw1-p0, br-int, "192.168.1.2/24", "f0:00:00:11:02:03", "192.168.1.1")
check ovn-nbctl lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 "f0:00:00:11:02:03 192.168.1.2"

check ovn-nbctl --add-route lr-nat-add lr0 dnat_and_snat 172.16.1.100 192.168.0.2 sw0-p0 00:00:00:00:03:01
check ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.16.1.101 192.168.1.2 sw1-p0 00:00:00:00:04:01

wait_for_ports_up
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([sw0-p0], [ping -q -c 3 -i 0.3 -w 2 172.16.1.101 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

NS_CHECK_EXEC([sw1-p0], [ping -q -c 3 -i 0.3 -w 2 172.16.1.100 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([MAC_Bindings updates on read-only sb])
ovn_start --use-tcp-to-sb
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

PARSE_LISTENING_PORT([$ovs_base/ovn-sb/ovsdb-server.log], [TCP_PORT])

# Use tcp to connect to sb
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=tcp:127.0.0.1:$TCP_PORT \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# A public switch (pub) with a localnet port connected to two LRs (lr0 and lr1)
# each with a distributed gateway port.
# Two VMs: lp0 on sw0 connected to lr0
#          lp1 on sw1 connected to lr1
#
# This test adds a floating IP on one VM and checks the MAC_Binding entries to be updated properly.

# Create logical switches
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add pub

# Created localnet port on public switch
check ovn-nbctl lsp-add pub ln-pub
check ovn-nbctl lsp-set-type ln-pub localnet
check ovn-nbctl lsp-set-addresses ln-pub unknown
check ovn-nbctl lsp-set-options ln-pub network_name=phys

# Create logical routers and connect them to public switch
check_uuid ovn-nbctl create Logical_Router name=lr0
check_uuid ovn-nbctl create Logical_Router name=lr1

check ovn-nbctl lrp-add lr0 lr0-pub f0:00:00:00:00:01 172.24.4.220/24
check ovn-nbctl lsp-add pub pub-lr0 -- set Logical_Switch_Port pub-lr0 \
    type=router options:router-port=lr0-pub options:nat-addresses="router" addresses="router"
check ovn-nbctl lrp-add lr1 lr1-pub f0:00:00:00:01:01 172.24.4.221/24
check ovn-nbctl lsp-add pub pub-lr1 -- set Logical_Switch_Port pub-lr1 \
    type=router options:router-port=lr1-pub options:nat-addresses="router" addresses="router"

check ovn-nbctl lrp-set-gateway-chassis lr0-pub hv1 10
check ovn-nbctl lrp-set-gateway-chassis lr1-pub hv1 10

# Connect sw0 and sw1 to lr0 and lr1
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.254/24
check ovn-nbctl lsp-add sw0 sw0-lr0 -- set Logical_Switch_Port sw0-lr0 type=router \
    options:router-port=lr0-sw0 addresses="router"
check ovn-nbctl lrp-add lr1 lr1-sw1 00:00:00:00:ff:02 20.0.0.254/24
check ovn-nbctl lsp-add sw1 sw1-lr1 -- set Logical_Switch_Port sw1-lr1 type=router \
    options:router-port=lr1-sw1 addresses="router"

ADD_BR([br-phys])
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

check ovs-vsctl add-port br-int vif0 \
      -- set Interface vif0 external-ids:iface-id=lp0 \
      -- set Interface vif0 type=internal

check ovn-nbctl lsp-add sw0 lp0
check ovn-nbctl lsp-add sw1 lp1
check ovn-nbctl lsp-set-addresses lp0 "50:54:00:00:00:01 10.0.0.10"
check ovn-nbctl lsp-set-addresses lp1 "50:54:00:00:00:02 20.0.0.10"

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp0` = xup])
check ovn-nbctl --wait=hv sync

# Stopping updates to sb
# By stopping temporarily updates from controller to sb, we are making sb read-only.
# We can't just pause sb to make it read-only, as we expect sb to still handle northd changes.
stop_ovsdb_controller_updates $TCP_PORT

# Adding lp1 : this will make sb read-only
check ovs-vsctl add-port br-int vif1 \
      -- set Interface vif1 external-ids:iface-id=lp1 \
      -- set Interface vif1 type=internal

# Make sure ovn-controller handled vif1 addition. So, at this point ovn-controller did try to update sb
OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif1 external_ids:ovn-installed` = x'"true"'])

# Create floating IP. SB should be read-only, so we should not be enable to update MAC_Bindings now.
check ovn-nbctl --wait=sb lr-nat-add lr0 dnat_and_snat 172.24.4.100 10.0.0.10

# Restarting updates.
restart_ovsdb_controller_updates $TCP_PORT
# Check that the MAC_Binding entries have been properly created as SB is now writable.
wait_row_count MAC_Binding 1 logical_port=lr1-pub ip=172.24.4.100

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([LB with first packet buffered])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add lr
check ovn-nbctl ls-add internal
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add lr lr-pub 00:00:01:01:02:03 192.168.100.1/24 1000::1/64
check ovn-nbctl lsp-add  public pub-lr -- set Logical_Switch_Port pub-lr \
    type=router options:router-port=lr-pub addresses=\"00:00:01:01:02:03\"

check ovn-nbctl lrp-add lr lr-internal 00:00:01:01:02:04 192.168.200.1/24 2000::1/64
check ovn-nbctl lsp-add internal internal-lr -- set Logical_Switch_Port internal-lr \
    type=router options:router-port=lr-internal addresses=\"00:00:01:01:02:04\"

check ovn-nbctl lsp-add internal server -- lsp-set-addresses server "unknown"

check ovn-nbctl lsp-add public ln_port \
                -- lsp-set-addresses ln_port unknown \
                -- lsp-set-type ln_port localnet \
                -- lsp-set-options ln_port network_name=phynet

check ovn-nbctl set logical_router lr options:chassis=hv1

check ovn-nbctl lb-add lb1 192.168.100.20 192.168.200.10
check ovn-nbctl lb-add lb2 1000::20 2000::10
check ovn-nbctl lr-lb-add lr lb1
check ovn-nbctl lr-lb-add lr lb2
check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(client)
ADD_VETH(client, client, br-ext, "1000::10/64", "f0:00:00:01:02:03", \
         "1000::1", "nodad", "192.168.100.10/24", "192.168.100.1")

ADD_NAMESPACES(server)
ADD_VETH(server, server, br-int, "2000::10/64", "f0:00:0f:01:02:03", \
         "2000::1", "nodad", "192.168.200.10/24", "192.168.200.1")

NETNS_DAEMONIZE([server], [nc -l -u 192.168.200.10 4242 > /dev/null], [serverv4.pid])
NETNS_DAEMONIZE([server], [nc -l -u 2000::10 4243 > /dev/null], [serverv6.pid])

NETNS_START_TCPDUMP([client], [-l -U -i client -vnne udp], [client])
NETNS_START_TCPDUMP([server], [-l -U -i server -vnne udp], [server])

check ovs-appctl dpctl/flush-conntrack

NS_CHECK_EXEC([client], [nc -z -u 192.168.100.20 4242], [ignore], [ignore], [ignore])
OVS_WAIT_UNTIL([grep -q "192.168.200.10" server.tcpdump])

NS_CHECK_EXEC([client], [nc -z -u 1000::20 4243])
OVS_WAIT_UNTIL([grep -q "2000::10" server.tcpdump])

zone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep lr_dnat | cut -d ' ' -f2)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep -c "zone=$zone_id"], [0], [2
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DHCP RELAY])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_DHCLIENT = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "0", "f0:00:00:01:02:03")
ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "0", "f0:00:00:02:02:03")
ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "172.16.1.1/24", "f0:00:00:01:02:05", \
         "172.16.1.254")

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add sw-ext

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl lrp-add R1 rp-ext 00:00:02:01:02:03 172.16.1.254/24

dhcp_relay=$(ovn-nbctl create DHCP_Relay servers=172.16.1.1)
check ovn-nbctl set Logical_Router_port rp-sw0 dhcp_relay=$dhcp_relay
check ovn-nbctl set Logical_Router_port rp-sw1 dhcp_relay=$dhcp_relay
check ovn-nbctl lrp-set-gateway-chassis rp-ext hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl set Logical_Switch sw0 other_config:dhcp_relay_port=sw0-rp
check ovn-nbctl set Logical_Switch sw1 other_config:dhcp_relay_port=sw1-rp

check ovn-nbctl lsp-add sw-ext ext-rp -- set Logical_Switch_Port ext-rp \
    type=router options:router-port=rp-ext \
    -- lsp-set-addresses ext-rp router
check ovn-nbctl lsp-add sw-ext lnet \
        -- lsp-set-addresses lnet unknown \
        -- lsp-set-type lnet localnet \
        -- lsp-set-options lnet network_name=phynet

check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03"

check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03"

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])

OVN_POPULATE_ARP

check ovn-nbctl --wait=hv sync

DHCP_TEST_DIR="/tmp/dhcp-test"
rm -rf $DHCP_TEST_DIR
mkdir $DHCP_TEST_DIR
cat > $DHCP_TEST_DIR/dhcpd.conf <<EOF
subnet 172.16.1.0 netmask 255.255.255.0 {
}
subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.10 192.168.1.10;
  option routers 192.168.1.1;
  option broadcast-address 192.168.1.255;
  default-lease-time 60;
  max-lease-time 120;
}
subnet 192.168.2.0 netmask 255.255.255.0 {
  range 192.168.2.10 192.168.2.10;
  option routers 192.168.2.1;
  option broadcast-address 192.168.2.255;
  default-lease-time 60;
  max-lease-time 120;
}
EOF
cat > $DHCP_TEST_DIR/dhclien.conf <<EOF
timeout 2
EOF

touch $DHCP_TEST_DIR/dhcpd.leases
chown root:dhcpd $DHCP_TEST_DIR $DHCP_TEST_DIR/dhcpd.leases
chmod 775 $DHCP_TEST_DIR
chmod 664 $DHCP_TEST_DIR/dhcpd.leases


NETNS_DAEMONIZE([server], [dhcpd -4 -f -cf $DHCP_TEST_DIR/dhcpd.conf s1 > dhcpd.log 2>&1], [dhcpd.pid])

NS_CHECK_EXEC([server], [tcpdump -l -nvv -i s1  udp > pkt.pcap 2>tcpdump_err &])
OVS_WAIT_UNTIL([grep "listening" tcpdump_err])
on_exit 'kill $(pidof tcpdump)'

NS_CHECK_EXEC([sw01], [dhclient -1 -q -lf $DHCP_TEST_DIR/dhclient-sw01.lease -pf $DHCP_TEST_DIR/dhclient-sw01.pid -cf $DHCP_TEST_DIR/dhclien.conf sw01])
NS_CHECK_EXEC([sw11], [dhclient -1 -q -lf $DHCP_TEST_DIR/dhclient-sw11.lease -pf $DHCP_TEST_DIR/dhclient-sw11.pid -cf $DHCP_TEST_DIR/dhclien.conf sw11])

OVS_WAIT_UNTIL([
    total_pkts=$(cat pkt.pcap | wc -l)
    test ${total_pkts} -ge 8
])

on_exit 'kill `cat $DHCP_TEST_DIR/dhclient-sw01.pid` &&
kill `cat $DHCP_TEST_DIR/dhclient-sw11.pid` && rm -rf $DHCP_TEST_DIR'

NS_CHECK_EXEC([sw01], [ip addr show sw01 | grep -oP '(?<=inet\s)\d+(\.\d+){3}'], [0], [dnl
192.168.1.10
])
NS_CHECK_EXEC([sw11], [ip addr show sw11 | grep -oP '(?<=inet\s)\d+(\.\d+){3}'], [0], [dnl
192.168.2.10
])
OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/failed to query port patch-.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([NAT arbitrary match - IPv4])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add lr
check ovn-nbctl ls-add internal
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add lr lr-pub 00:00:01:01:02:03 192.168.100.1/24
check ovn-nbctl lsp-add  public pub-lr -- set Logical_Switch_Port pub-lr \
    type=router options:router-port=lr-pub addresses=\"00:00:01:01:02:03\"

check ovn-nbctl lrp-add lr lr-internal 00:00:01:01:02:04 192.168.200.1/24
check ovn-nbctl lsp-add internal internal-lr -- set Logical_Switch_Port internal-lr \
    type=router options:router-port=lr-internal addresses=\"00:00:01:01:02:04\"

check ovn-nbctl lsp-add internal vm0 \
    -- lsp-set-addresses vm0 "f0:00:0f:01:02:03 192.168.200.10"
check ovn-nbctl lsp-add internal vm2 \
    -- lsp-set-addresses vm2 "f0:00:0f:01:02:04 192.168.200.20"
check ovn-nbctl lsp-add internal vm3 \
    -- lsp-set-addresses vm3 "f0:00:0f:01:02:05 192.168.200.30"

check ovn-nbctl lsp-add public ln_port \
    -- lsp-set-addresses ln_port unknown \
    -- lsp-set-type ln_port localnet \
    -- lsp-set-options ln_port network_name=phynet

check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(vm0)
ADD_VETH(vm0, vm0, br-int, "192.168.200.10/24", "f0:00:0f:01:02:03", "192.168.200.1")

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-ext, "192.168.100.10/24", "f0:00:00:01:02:03", "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.200.20/24", "f0:00:0f:01:02:04", "192.168.200.1")

ADD_NAMESPACES(vm3)
ADD_VETH(vm3, vm3, br-int, "192.168.200.30/24", "f0:00:0f:01:02:05", "192.168.200.1")

NETNS_DAEMONIZE([vm0], [nc -l -k 192.168.200.10 4242], [server0.pid])
NETNS_DAEMONIZE([vm1], [nc -l -k 192.168.100.10 4242], [server1.pid])
NETNS_DAEMONIZE([vm2], [nc -l -k 192.168.200.20 4242], [server2.pid])
NETNS_DAEMONIZE([vm3], [nc -l -k 192.168.200.30 4242], [server3.pid])

check_snat() {
    check ovn-nbctl lr-nat-del lr
    check ovn-nbctl lr-nat-add lr snat 192.168.100.1 192.168.200.0/24
    check ovn-nbctl --match="tcp && tcp.src == 2001" lr-nat-add lr snat 192.168.100.11 192.168.200.0/24
    check ovn-nbctl --match="tcp && tcp.src == 2002" lr-nat-add lr snat 192.168.100.12 192.168.200.0/24
    check ovn-nbctl --wait=hv sync

    check ovs-appctl dpctl/flush-conntrack

    NS_CHECK_EXEC([vm0], [nc -z 192.168.100.10 4242 -p 2000])
    NS_CHECK_EXEC([vm0], [nc -z 192.168.100.10 4242 -p 2001])
    NS_CHECK_EXEC([vm0], [nc -z 192.168.100.10 4242 -p 2002])

    snat_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep lr_snat | cut -d ' ' -f2)
    AT_CHECK_UNQUOTED([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.100.10) | grep "zone=$snat_id"], [0], [dnl
tcp,orig=(src=192.168.200.10,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.100.10,dst=192.168.100.1,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.200.10,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.100.10,dst=192.168.100.11,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.200.10,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.100.10,dst=192.168.100.12,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
])
}

check_dnat() {
    check ovn-nbctl lr-nat-del lr
    check ovn-nbctl lr-nat-add lr dnat 192.168.100.100 192.168.200.10
    check ovn-nbctl --match="tcp && tcp.src == 2001" lr-nat-add lr dnat 192.168.100.100 192.168.200.20
    check ovn-nbctl --match="tcp && tcp.src == 2002" lr-nat-add lr dnat 192.168.100.100 192.168.200.30
    check ovn-nbctl --wait=hv sync

    check ovs-appctl dpctl/flush-conntrack

    NS_CHECK_EXEC([vm1], [nc -z 192.168.100.100 4242 -p 2000])
    NS_CHECK_EXEC([vm1], [nc -z 192.168.100.100 4242 -p 2001])
    NS_CHECK_EXEC([vm1], [nc -z 192.168.100.100 4242 -p 2002])

    dnat_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep lr_dnat | cut -d ' ' -f2)
    AT_CHECK_UNQUOTED([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.100.100) | grep "zone=$dnat_id"], [0], [dnl
tcp,orig=(src=192.168.100.10,dst=192.168.100.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.200.10,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.100.10,dst=192.168.100.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.200.20,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.100.10,dst=192.168.100.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.200.30,dst=192.168.100.10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
])
}

check ovn-nbctl lrp-set-gateway-chassis lr-pub hv1
check_snat
check_dnat
check ovn-nbctl lrp-del-gateway-chassis lr-pub hv1

check ovn-nbctl set logical_router lr options:chassis=hv1
check_snat
check_dnat

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([NAT arbitrary match - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add lr
check ovn-nbctl ls-add internal
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add lr lr-pub 00:00:01:01:02:03 1000::1/64
check ovn-nbctl lsp-add  public pub-lr -- set Logical_Switch_Port pub-lr \
    type=router options:router-port=lr-pub addresses=\"00:00:01:01:02:03\"

check ovn-nbctl lrp-add lr lr-internal 00:00:01:01:02:04 2000::1/64
check ovn-nbctl lsp-add internal internal-lr -- set Logical_Switch_Port internal-lr \
    type=router options:router-port=lr-internal addresses=\"00:00:01:01:02:04\"

check ovn-nbctl lsp-add internal vm0 \
    -- lsp-set-addresses vm0 "f0:00:0f:01:02:03 2000::10"
check ovn-nbctl lsp-add internal vm2 \
    -- lsp-set-addresses vm2 "f0:00:0f:01:02:04 2000::20"
check ovn-nbctl lsp-add internal vm3 \
    -- lsp-set-addresses vm3 "f0:00:0f:01:02:05 2000::30"

check ovn-nbctl lsp-add public ln_port \
    -- lsp-set-addresses ln_port unknown \
    -- lsp-set-type ln_port localnet \
    -- lsp-set-options ln_port network_name=phynet

check ovn-nbctl --wait=hv sync

ADD_NAMESPACES(vm0)
ADD_VETH(vm0, vm0, br-int, "2000::10/64", "f0:00:0f:01:02:03", "2000::1", "nodad")

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-ext, "1000::10/64", "f0:00:00:01:02:03", "1000::1", "nodad")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "2000::20/64", "f0:00:0f:01:02:04", "2000::1", "nodad")

ADD_NAMESPACES(vm3)
ADD_VETH(vm3, vm3, br-int, "2000::30/64", "f0:00:0f:01:02:05", "2000::1", "nodad")

NETNS_DAEMONIZE([vm0], [nc -lk 2000::10 4242 > /dev/null], [server0.pid])
NETNS_DAEMONIZE([vm1], [nc -lk 1000::10 4242 > /dev/null], [server1.pid])
NETNS_DAEMONIZE([vm2], [nc -lk 2000::20 4242 > /dev/null], [server2.pid])
NETNS_DAEMONIZE([vm3], [nc -lk 2000::30 4242 > /dev/null], [server3.pid])

check_snat() {
    check ovn-nbctl lr-nat-del lr
    check ovn-nbctl lr-nat-add lr snat 1000::1 2000::/64
    check ovn-nbctl --match="tcp && tcp.src == 2001" lr-nat-add lr snat 1000::11 2000::/64
    check ovn-nbctl --match="tcp && tcp.src == 2002" lr-nat-add lr snat 1000::12 2000::/64
    check ovn-nbctl --wait=hv sync

    check ovs-appctl dpctl/flush-conntrack

    NS_CHECK_EXEC([vm0], [nc -z 1000::10 4242 -p 2000])
    NS_CHECK_EXEC([vm0], [nc -z 1000::10 4242 -p 2001])
    NS_CHECK_EXEC([vm0], [nc -z 1000::10 4242 -p 2002])

    snat_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep lr_snat | cut -d ' ' -f2)
    AT_CHECK_UNQUOTED([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(1000::10) | grep "zone=$snat_id"], [0], [dnl
tcp,orig=(src=2000::10,dst=1000::10,sport=<cleared>,dport=<cleared>),reply=(src=1000::10,dst=1000::1,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=2000::10,dst=1000::10,sport=<cleared>,dport=<cleared>),reply=(src=1000::10,dst=1000::11,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=2000::10,dst=1000::10,sport=<cleared>,dport=<cleared>),reply=(src=1000::10,dst=1000::12,sport=<cleared>,dport=<cleared>),zone=$snat_id,protoinfo=(state=<cleared>)
])
}

check_dnat() {
    check ovn-nbctl lr-nat-del lr
    check ovn-nbctl lr-nat-add lr dnat 1000::100 2000::10
    check ovn-nbctl --match="tcp && tcp.src == 2001" lr-nat-add lr dnat 1000::100 2000::20
    check ovn-nbctl --match="tcp && tcp.src == 2002" lr-nat-add lr dnat 1000::100 2000::30
    check ovn-nbctl --wait=hv sync

    check ovs-appctl dpctl/flush-conntrack

    NS_CHECK_EXEC([vm1], [nc -z 1000::100 4242 -p 2000])
    NS_CHECK_EXEC([vm1], [nc -z 1000::100 4242 -p 2001])
    NS_CHECK_EXEC([vm1], [nc -z 1000::100 4242 -p 2002])

    dnat_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep lr_dnat | cut -d ' ' -f2)
    AT_CHECK_UNQUOTED([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(1000::100) | grep "zone=$dnat_id"], [0], [dnl
tcp,orig=(src=1000::10,dst=1000::100,sport=<cleared>,dport=<cleared>),reply=(src=2000::10,dst=1000::10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=1000::10,dst=1000::100,sport=<cleared>,dport=<cleared>),reply=(src=2000::20,dst=1000::10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
tcp,orig=(src=1000::10,dst=1000::100,sport=<cleared>,dport=<cleared>),reply=(src=2000::30,dst=1000::10,sport=<cleared>,dport=<cleared>),zone=$dnat_id,protoinfo=(state=<cleared>)
])
}

check ovn-nbctl lrp-set-gateway-chassis lr-pub hv1
check_snat
check_dnat
check ovn-nbctl lrp-del-gateway-chassis lr-pub hv1

check ovn-nbctl set logical_router lr options:chassis=hv1
check_snat
check_dnat

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL Sampling])
AT_SKIP_IF([test $HAVE_NFCAPD = no])
AT_SKIP_IF([test $HAVE_NFDUMP = no])
AT_KEYWORDS([ACL])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

dnl Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

dnl Start ovn-controller
start_daemon ovn-controller

dnl Logical network:
dnl 1 logical switch connetected to one logical router
dnl 6 UDP load balancers (ports 1000, 1010, 2000, 2010, 3000, 3010)
dnl 2 VIFs

check ovn-nbctl                                                  \
    -- lr-add rtr                                                \
    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24        \
    -- ls-add ls                                                 \
    -- lsp-add ls ls-rtr                                         \
    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls-rtr router                                \
    -- lsp-set-options ls-rtr router-port=rtr-ls                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- lb-add lb1 43.43.43.43:1000 42.42.42.3:1000 udp           \
    -- lb-add lb2 43.43.43.43:1010 42.42.42.3:1010 udp           \
    -- lb-add lb3 43.43.43.43:2000 42.42.42.3:2000 udp           \
    -- lb-add lb4 43.43.43.43:2010 42.42.42.3:2010 udp           \
    -- lb-add lb5 43.43.43.43:3000 42.42.42.3:3000 udp           \
    -- lb-add lb6 43.43.43.43:3010 42.42.42.3:3010 udp           \
    -- ls-lb-add ls lb1                                          \
    -- ls-lb-add ls lb2                                          \
    -- ls-lb-add ls lb3                                          \
    -- ls-lb-add ls lb4                                          \
    -- ls-lb-add ls lb5                                          \
    -- ls-lb-add ls lb6

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

collector1=$(ovn-nbctl create Sample_Collector id=1 name=c1 probability=65535 set_id=100)
collector2=$(ovn-nbctl create Sample_Collector id=2 name=c2 probability=65535 set_id=200)
check_row_count nb:Sample_Collector 2

check_uuid ovn-nbctl create Sampling_App type="acl-new" id="42"
check_uuid ovn-nbctl create Sampling_App type="acl-est" id="43"
check_row_count nb:Sampling_App 2

dnl Create ACLs that match the 3 types of traffic in all 3 possible stages:
dnl from-lport, from-lport-after-lb, to-lport.
check_uuid ovn-nbctl                                                              \
    -- --id=@sample_in_1c_new create Sample collector="$collector1" metadata=1001 \
    -- --id=@sample_in_1c_est create Sample collector="$collector1" metadata=1002 \
    -- --sample-new=@sample_in_1c_new --sample-est=@sample_in_1c_est              \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 1000"             \
       allow-related
check_uuid ovn-nbctl                                                                          \
    -- --id=@sample_in_2c_new create Sample collector="$collector1 $collector2" metadata=1011 \
    -- --id=@sample_in_2c_est create Sample collector="$collector1 $collector2" metadata=1012 \
    -- --sample-new=@sample_in_2c_new --sample-est=@sample_in_2c_est                          \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 1010"                         \
       allow-related

check_uuid ovn-nbctl                                                                 \
    -- --id=@sample_in_lb_1c_new create Sample collector="$collector1" metadata=2001 \
    -- --id=@sample_in_lb_1c_est create Sample collector="$collector1" metadata=2002 \
    -- --apply-after-lb --sample-new=@sample_in_lb_1c_new                            \
       --sample-est=@sample_in_lb_1c_est                                             \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 2000"                \
       allow-related
check_uuid ovn-nbctl                                                                             \
    -- --id=@sample_in_lb_2c_new create Sample collector="$collector1 $collector2" metadata=2011 \
    -- --id=@sample_in_lb_2c_est create Sample collector="$collector1 $collector2" metadata=2012 \
    -- --apply-after-lb --sample-new=@sample_in_lb_2c_new --sample-est=@sample_in_lb_2c_est      \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 2010"                            \
       allow-related

check_uuid ovn-nbctl                                                               \
    -- --id=@sample_out_1c_new create Sample collector="$collector1" metadata=3001 \
    -- --id=@sample_out_1c_est create Sample collector="$collector1" metadata=3002 \
    -- --sample-new=@sample_out_1c_new --sample-est=@sample_out_1c_est             \
       acl-add ls to-lport 1 "outport == \"vm2\" && udp.dst == 3000"               \
       allow-related
check_uuid ovn-nbctl                                                                           \
    -- --id=@sample_out_2c_new create Sample collector="$collector1 $collector2" metadata=3011 \
    -- --id=@sample_out_2c_est create Sample collector="$collector1 $collector2" metadata=3012 \
    -- --sample-new=@sample_out_2c_new --sample-est=@sample_out_2c_est                         \
       acl-add ls to-lport 1 "outport == \"vm2\" && udp.dst == 3010"                           \
       allow-related

check_row_count nb:ACL 6
check_row_count nb:Sample 12

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Start an IPFIX collector.
DAEMONIZE([nfcapd -B 1024000 -w . -p 4242 2> collector.err], [collector.pid])

dnl Wait for the collector to be up.
OVS_WAIT_UNTIL([grep -q 'Startup nfcapd.' collector.err])

dnl Configure the OVS flow sample collector.
ovs-vsctl --id=@br get Bridge br-int \
    -- --id=@ipfix create IPFIX targets=\"127.0.0.1:4242\" template_interval=1 \
    -- --id=@cs create Flow_Sample_Collector_Set id=100 bridge=@br ipfix=@ipfix

check ovn-nbctl --wait=hv sync
dnl And wait for it to be up and running.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q '1 ids'])

dnl Start UDP echo server on vm2.
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 1000], [nc-vm2-1000.pid])
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 1010], [nc-vm2-1010.pid])
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 2000], [nc-vm2-2000.pid])
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 2010], [nc-vm2-2010.pid])
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 3000], [nc-vm2-3000.pid])
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 3010], [nc-vm2-3010.pid])

dnl Send traffic (2 packets) to the UDP LB1 (hits the from-lport ACL).
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 1000])
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 1010])

dnl Send traffic (2 packets) to the UDP LB1 (hits the from-lport after-lb ACL).
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 2000])
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 2010])

dnl Send traffic (2 packets) to the UDP LB1 (hits the from-lport ACL).
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 3000])
NS_CHECK_EXEC([vm1], [(echo a; sleep 1; echo a) | nc --send-only -u 43.43.43.43 3010])

dnl Wait until OVS sampled all expected packets (4 data packets + 1 ICMP
dnl port unreachable error on each session).
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q 'sampled pkts=30'])

dnl Check the IPFIX samples.
kill $(cat collector.pid)
OVS_WAIT_WHILE([kill -0 $(cat collector.pid) 2>/dev/null])

dnl Can't match on observation domain ID due to the followig fix not being
dnl available in any released version of nfdump:
dnl https://github.com/phaag/nfdump/issues/544
dnl
dnl Only match on the point ID.
dnl
dnl Expect for each ACL:
dnl - one sample for new packets
dnl - four samples for established packets (3 data + one icmp error)
AT_CHECK([for f in $(ls -1 nfcapd.*); do nfdump -o json -r $f; done | grep observationPointID | awk '{$1=$1;print}' | sort], [0], [dnl
"observationPointID" : 1001,
"observationPointID" : 1002,
"observationPointID" : 1002,
"observationPointID" : 1002,
"observationPointID" : 1002,
"observationPointID" : 1011,
"observationPointID" : 1012,
"observationPointID" : 1012,
"observationPointID" : 1012,
"observationPointID" : 1012,
"observationPointID" : 2001,
"observationPointID" : 2002,
"observationPointID" : 2002,
"observationPointID" : 2002,
"observationPointID" : 2002,
"observationPointID" : 2011,
"observationPointID" : 2012,
"observationPointID" : 2012,
"observationPointID" : 2012,
"observationPointID" : 2012,
"observationPointID" : 3001,
"observationPointID" : 3002,
"observationPointID" : 3002,
"observationPointID" : 3002,
"observationPointID" : 3002,
"observationPointID" : 3011,
"observationPointID" : 3012,
"observationPointID" : 3012,
"observationPointID" : 3012,
"observationPointID" : 3012,
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Tiered ACL Sampling])
AT_SKIP_IF([test $HAVE_NFCAPD = no])
AT_SKIP_IF([test $HAVE_NFDUMP = no])
AT_KEYWORDS([ACL])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

dnl Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

dnl Start ovn-controller
start_daemon ovn-controller

dnl Logical network:
dnl 1 logical switch
dnl 2 VIFs

check ovn-nbctl                                                  \
    -- ls-add ls                                                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02
ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

collector1=$(ovn-nbctl create Sample_Collector id=1 name=c1 probability=65535 set_id=100)
check_row_count nb:Sample_Collector 1

check_uuid ovn-nbctl create Sampling_App type="acl-new" id="42"
check_uuid ovn-nbctl create Sampling_App type="acl-est" id="43"
check_row_count nb:Sampling_App 2

dnl Create two tiers of ACLs.
check_uuid ovn-nbctl                                                          \
    -- --id=@sample_1_new create Sample collector="$collector1" metadata=1001 \
    -- --id=@sample_1_est create Sample collector="$collector1" metadata=1002 \
    -- --tier=0 --sample-new=@sample_1_new --sample-est=@sample_1_est         \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 1000"         \
       pass

check_uuid ovn-nbctl                                                          \
    -- --id=@sample_2_new create Sample collector="$collector1" metadata=2001 \
    -- --id=@sample_2_est create Sample collector="$collector1" metadata=2002 \
    -- --tier=1 --sample-new=@sample_2_new --sample-est=@sample_2_est         \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 1000" \
       allow-related

check_row_count nb:ACL 2
check_row_count nb:Sample 4

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Start an IPFIX collector.
DAEMONIZE([nfcapd -B 1024000 -w . -p 4242 2> collector.err], [collector.pid])

dnl Wait for the collector to be up.
OVS_WAIT_UNTIL([grep -q 'Startup nfcapd.' collector.err])

dnl Configure the OVS flow sample collector.
ovs-vsctl --id=@br get Bridge br-int \
    -- --id=@ipfix create IPFIX targets=\"127.0.0.1:4242\" template_interval=1 \
    -- --id=@cs create Flow_Sample_Collector_Set id=100 bridge=@br ipfix=@ipfix

check ovn-nbctl --wait=hv sync
dnl And wait for it to be up and running.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q '1 ids'])

dnl Start UDP echo server on vm2.
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 1000], [nc-vm2-1000.pid])

dnl Send traffic to the UDP server (hits both ACL tiers).
NS_CHECK_EXEC([vm1], [echo a | nc --send-only -u 42.42.42.3 1000])

dnl Wait until OVS sampled all expected packets:
dnl - first packet sampled by both tiers
dnl - reply packet sampled by last tier (established session)
dnl - related ICMP port unreachable error sampled by last tier (established session)
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q 'sampled pkts=4'])

dnl Check the IPFIX samples.
kill $(cat collector.pid)
OVS_WAIT_WHILE([kill -0 $(cat collector.pid) 2>/dev/null])

dnl Can't match on observation domain ID due to the followig fix not being
dnl available in any released version of nfdump:
dnl https://github.com/phaag/nfdump/issues/544
dnl
dnl Only match on the point ID.
AT_CHECK([for f in $(ls -1 nfcapd.*); do nfdump -o json -r $f; done | grep observationPointID | awk '{$1=$1;print}' | sort], [0], [dnl
"observationPointID" : 1001,
"observationPointID" : 2001,
"observationPointID" : 2002,
"observationPointID" : 2002,
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Tiered ACL Sampling - tier mismatch])
AT_SKIP_IF([test $HAVE_NFCAPD = no])
AT_SKIP_IF([test $HAVE_NFDUMP = no])
AT_KEYWORDS([ACL])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

dnl Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

dnl Start ovn-controller
start_daemon ovn-controller

dnl Logical network:
dnl 1 logical switch
dnl 2 VIFs

check ovn-nbctl                                                  \
    -- ls-add ls                                                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02
ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

collector1=$(ovn-nbctl create Sample_Collector id=1 name=c1 probability=65535 set_id=100)
check_row_count nb:Sample_Collector 1

check_uuid ovn-nbctl create Sampling_App type="acl-new" id="42"
check_uuid ovn-nbctl create Sampling_App type="acl-est" id="43"
check_row_count nb:Sampling_App 2

dnl Create two tiers of ACLs.
dnl The first ACL is an ingress "pass" ACL at tier 0.
check_uuid ovn-nbctl                                                          \
    -- --id=@sample_1_new create Sample collector="$collector1" metadata=1001 \
    -- --id=@sample_1_est create Sample collector="$collector1" metadata=1002 \
    -- --tier=0 --sample-new=@sample_1_new --sample-est=@sample_1_est         \
       acl-add ls from-lport 1 "inport == \"vm1\" && udp.dst == 1000"         \
       pass

dnl The second ACL is an unrelated egress ACL. However, it uses tier 1 instead
dnl of tier 0.
check ovn-nbctl --tier=1 acl-add ls to-lport 1 "inport == \"vm1\" && udp.dst == 1000" allow-related

check_row_count nb:ACL 2
check_row_count nb:Sample 2

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Start an IPFIX collector.
DAEMONIZE([nfcapd -B 1024000 -w . -p 4242 2> collector.err], [collector.pid])

dnl Wait for the collector to be up.
OVS_WAIT_UNTIL([grep -q 'Startup nfcapd.' collector.err])

dnl Configure the OVS flow sample collector.
ovs-vsctl --id=@br get Bridge br-int \
    -- --id=@ipfix create IPFIX targets=\"127.0.0.1:4242\" template_interval=1 \
    -- --id=@cs create Flow_Sample_Collector_Set id=100 bridge=@br ipfix=@ipfix

check ovn-nbctl --wait=hv sync
dnl And wait for it to be up and running.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q '1 ids'])

dnl Start UDP echo server on vm2.
NETNS_DAEMONIZE([vm2], [nc -e /bin/cat -k -u -v -l -m 1 1000], [nc-vm2-1000.pid])

dnl Send traffic to the UDP server (hits both ACL tiers).
NS_CHECK_EXEC([vm1], [echo a | nc --send-only -u 42.42.42.3 1000])

dnl Wait until OVS sampled all expected packets:
dnl In this case, we only expect a single sampled packet.
dnl The pass ACL should sample its "pass" result. The egress
dnl ACL should not get hit (and it doesn't have sampling configured
dnl anyway). A bug that previously existed in OVN would result in
dnl the "pass" being sampled two times instead of just once.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q 'sampled pkts=1'])

dnl Check the IPFIX samples.
kill $(cat collector.pid)
OVS_WAIT_WHILE([kill -0 $(cat collector.pid) 2>/dev/null])

dnl Can't match on observation domain ID due to the followig fix not being
dnl available in any released version of nfdump:
dnl https://github.com/phaag/nfdump/issues/544
dnl
dnl Only match on the point ID.
AT_CHECK([for f in $(ls -1 nfcapd.*); do nfdump -o json -r $f; done | grep observationPointID | awk '{$1=$1;print}' | sort], [0], [dnl
"observationPointID" : 1001,
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL Sampling - Stateful ACL - to-lport router port])
AT_SKIP_IF([test $HAVE_NFCAPD = no])
AT_SKIP_IF([test $HAVE_NFDUMP = no])
AT_KEYWORDS([ACL])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

dnl Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

dnl Start ovn-controller
start_daemon ovn-controller

dnl Logical network:
dnl 1 router
dnl 1 logical switch
dnl 1 VIF

check ovn-nbctl                                      \
  -- lr-add lr                                       \
  -- lrp-add lr lrp1 00:00:00:00:01:00 42.42.42.1/24 \
  -- ls-add ls                                       \
  -- lsp-add ls vm1                                  \
  -- lsp-set-addresses vm1 00:00:00:00:00:01         \
  -- lsp-add ls ls-lr                                \
  -- lsp-set-type ls-lr router                       \
  -- lsp-set-options ls-lr router-port=lrp1          \
  -- lsp-set-addresses ls-lr router
check ovn-nbctl --wait=sb sync

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

collector1=$(ovn-nbctl create Sample_Collector id=1 name=c1 probability=65535 set_id=100)
collector2=$(ovn-nbctl create Sample_Collector id=2 name=c2 probability=65535 set_id=200)
check_row_count nb:Sample_Collector 2

check_uuid ovn-nbctl create Sampling_App type="acl-new" id="42"
check_row_count nb:Sampling_App 1

dnl Create three ACLs:
dnl - one from-lport, stateful, allowing all traffic
dnl - one to-lport, dropping all traffic to 1.1.1.1 (single collector)
dnl - one to-lport, dropping all traffic to 1.1.1.2 (two collectors)
check_uuid ovn-nbctl                                                               \
  -- --id=@sample1 create Sample collector="$collector1" metadata=1001             \
  -- --id=@sample2 create Sample collector="$collector1" metadata=1002             \
  -- --id=@sample3 create Sample collector="$collector1 $collector2" metadata=1003 \
  -- --sample-new=@sample1 acl-add ls from-lport 1 "1" allow-related               \
  -- --sample-new=@sample2 acl-add ls to-lport 1 "ip4.dst == 1.1.1.1" drop         \
  -- --sample-new=@sample3 acl-add ls to-lport 1 "ip4.dst == 1.1.1.2" drop

check_row_count nb:ACL 3
check_row_count nb:Sample 3

dnl Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Start an IPFIX collector.
DAEMONIZE([nfcapd -B 1024000 -w . -p 4242 2> collector.err], [collector.pid])

dnl Wait for the collector to be up.
OVS_WAIT_UNTIL([grep -q 'Startup nfcapd.' collector.err])

dnl Configure the OVS flow sample collector.
ovs-vsctl --id=@br get Bridge br-int \
    -- --id=@ipfix create IPFIX targets=\"127.0.0.1:4242\" template_interval=1 \
    -- --id=@cs create Flow_Sample_Collector_Set id=100 bridge=@br ipfix=@ipfix

check ovn-nbctl --wait=hv sync
dnl And wait for it to be up and running.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q '1 ids'])

NS_CHECK_EXEC([vm1], [ping -c 1 1.1.1.1], [1], [ignore], [ignore])
NS_CHECK_EXEC([vm1], [ping -c 1 1.1.1.2], [1], [ignore], [ignore])

dnl Wait until OVS sampled the two ICMP packet on two ACLs.
OVS_WAIT_UNTIL([ovs-ofctl dump-ipfix-flow br-int | grep -q 'sampled pkts=4'])

dnl Check the IPFIX samples.
kill $(cat collector.pid)
OVS_WAIT_WHILE([kill -0 $(cat collector.pid) 2>/dev/null])

dnl Can't match on observation domain ID due to the followig fix not being
dnl available in any released version of nfdump:
dnl https://github.com/phaag/nfdump/issues/544
dnl
dnl Only match on the point ID.
AT_CHECK([for f in $(ls -1 nfcapd.*); do nfdump -o json -r $f; done | grep observationPointID | awk '{$1=$1;print}' | sort], [0], [dnl
"observationPointID" : 1001,
"observationPointID" : 1001,
"observationPointID" : 1002,
"observationPointID" : 1003,
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SB Disconnect - MAC_Binding])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

SB_PATH="unix:$ovs_base/ovn-sb/ovn-sb.sock"
ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=$SB_PATH \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.10/24", "f0:00:00:01:02:03", \
        "192.168.1.1")
ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "172.16.1.1/24", "f0:00:00:01:02:05", \
         "172.16.1.254")
NS_CHECK_EXEC([server], [ip addr add 172.16.1.2 dev s1])
check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw-ext

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-ext 00:00:02:01:02:03 172.16.1.254/16

check ovn-nbctl lrp-set-gateway-chassis rp-ext hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl set Logical_Switch sw0 other_config:dhcp_relay_port=sw0-rp

check ovn-nbctl lsp-add sw-ext ext-rp -- set Logical_Switch_Port ext-rp \
    type=router options:router-port=rp-ext \
    -- lsp-set-addresses ext-rp router
check ovn-nbctl lsp-add sw-ext lnet \
        -- lsp-set-addresses lnet unknown \
        -- lsp-set-type lnet localnet \
        -- lsp-set-options lnet network_name=phynet

check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.10"

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote-probe-interval=100])

OVN_POPULATE_ARP

check ovn-nbctl --wait=hv sync

AS_BOX([Verify ARP resolution is working when SB is in connected state])

AT_CHECK([ovn-appctl connection-status], [0], [dnl
connected
])

NS_CHECK_EXEC([server], [tcpdump -l -nvv -i s1  icmp > pkt.pcap 2>tcpdump_err &])
OVS_WAIT_UNTIL([grep "listening" tcpdump_err])
on_exit 'kill $(pidof tcpdump)'

NS_CHECK_EXEC([sw01], [ping -q -c 2 -i 0.2 -w 2 172.16.1.1 | FORMAT_PING],
[0], [dnl
2 packets transmitted, 2 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
    total_pkts=$(cat pkt.pcap | wc -l)
    test ${total_pkts} -ge 2
])

AS_BOX([Disconnect SB and test ping that generates new ARP])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=tcp:127.0.0.1:1234])

sleep 1
AT_CHECK([ovn-appctl connection-status], [0], [dnl
not connected
])

NS_CHECK_EXEC([sw01], [ping -q -c 2 -i 0.5 -w 1 172.16.1.2 | FORMAT_PING | sed 's/.* packets/n packets/'],
[0], [dnl
n packets transmitted, 0 received, 100% packet loss, time 0ms
])

ovn-sbctl list fdb
AS_BOX([Test traffic for which ARP entry existed in MAC_Binding table])
NS_CHECK_EXEC([sw01], [ping -q -c 2 -i 0.2 -w 2 172.16.1.1 | FORMAT_PING],
[0], [dnl
2 packets transmitted, 2 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=$SB_PATH])
OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/failed to query port patch-.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SB Disconnect - MAC_Binding buffer limit])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

SB_PATH="unix:$ovs_base/ovn-sb/ovn-sb.sock"
ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=$SB_PATH \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.10/24", "f0:00:00:01:02:03", \
        "192.168.1.1")
ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "172.16.1.1/24", "f0:00:00:01:02:05", \
         "172.16.1.254")

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add sw-ext

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-ext 00:00:02:01:02:03 172.16.1.254/16

check ovn-nbctl lrp-set-gateway-chassis rp-ext hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl set Logical_Switch sw0 other_config:dhcp_relay_port=sw0-rp

check ovn-nbctl lsp-add sw-ext ext-rp -- set Logical_Switch_Port ext-rp \
    type=router options:router-port=rp-ext \
    -- lsp-set-addresses ext-rp router
check ovn-nbctl lsp-add sw-ext lnet \
        -- lsp-set-addresses lnet unknown \
        -- lsp-set-type lnet localnet \
        -- lsp-set-options lnet network_name=phynet

check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.10"

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])

OVN_POPULATE_ARP

check ovn-nbctl --wait=hv sync

AS_BOX([Disconnect SB and send ping to generate multiple ARPs (>1000)])
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=tcp:127.0.0.1:1234])
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote-probe-interval=100])

sleep 1
AT_CHECK([ovn-appctl connection-status], [0], [dnl
not connected
])

for i in {1..20}; do
  for j in {1..100}; do
    NS_EXEC([sw01], [timeout 0.1 ping -q -c 1 -W 0.1 172.16.$i.$j >/dev/null 2>&1 &])
  done
  sleep 0.5
done

AS_BOX([Verify pinctrl_drop_buffered_packets_map counter])
ovn-appctl  coverage/show >ovn_counters
AT_CAPTURE_FILE([ovn_counters])
AT_CHECK([grep -q "pinctrl_drop_buffered_packets_map" ovn_counters], [0])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=$SB_PATH])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/failed to query port patch-.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Routing protocol redirect - l3 gateway])
AT_SKIP_IF([test $HAVE_NC = no])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1 \
    -- set Logical_Router R1 options:chassis=hv1

check ovn-nbctl ls-add public
check ovn-nbctl ls-add bar

check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lrp-add R1 rp-bar 00:00:ff:00:00:01 192.168.10.1/24

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovn-nbctl lsp-add bar bar-rp -- set Logical_Switch_Port bar-rp \
    type=router options:router-port=rp-bar \
    -- lsp-set-addresses bar-rp router

check ovn-nbctl lsp-add public bgp-daemon \
    -- lsp-set-addresses bgp-daemon unknown

# Setup container "bar1" representing host on an internal network
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.10.2/24", "00:00:ff:ff:ff:01", \
         "192.168.10.1")
check ovn-nbctl lsp-add bar bar1 \
    -- lsp-set-addresses bar1 "00:00:ff:ff:ff:01 192.168.10.2"

# Setup SNAT for the internal host
check ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.10.2

# Configure external connectivity
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

check ovn-nbctl --wait=hv sync

# Set option that redirects BGP and BFD traffic to a LSP "bgp-daemon"
check ovn-nbctl --wait=sb set logical_router_port rp-public options:routing-protocol-redirect=bgp-daemon
check ovn-nbctl --wait=sb set logical_router_port rp-public options:routing-protocols=BGP,BFD

# Create "bgp-daemon" interface in a namespace with IP and MAC matching LRP "rp-public"
ADD_NAMESPACES(bgp-daemon)
ADD_VETH(bgp-daemon, bgp-daemon, br-int, "172.16.1.1/24", "00:00:02:01:02:03")

ADD_NAMESPACES(ext-foo)
ADD_VETH(ext-foo, ext-foo, br-ext, "172.16.1.100/24", "00:10:10:01:02:13", \
         "172.16.1.1")

# Flip the interface down/up to get proper IPv6 LLA
NS_EXEC([bgp-daemon], [ip link set down bgp-daemon])
NS_EXEC([bgp-daemon], [ip link set up bgp-daemon])
NS_EXEC([ext-foo], [ip link set down ext-foo])
NS_EXEC([ext-foo], [ip link set up ext-foo])

# Wait until IPv6 LLA loses the "tentative" flag otherwise it can't be bound to.
OVS_WAIT_UNTIL([NS_EXEC([bgp-daemon], [ip a show dev bgp-daemon | grep "fe80::" | grep -v tentative])])
OVS_WAIT_UNTIL([NS_EXEC([ext-foo], [ip a show dev ext-foo | grep "fe80::" | grep -v tentative])])

# Verify that BGP control plane traffic is delivered to the "bgp-daemon"
# interface on both IPv4 and IPv6 LLA addresses
NETNS_DAEMONIZE([bgp-daemon], [nc -l -k 172.16.1.1 179], [bgp_v4.pid])
NS_CHECK_EXEC([ext-foo], [echo "BGP IPv4 server traffic" | nc --send-only 172.16.1.1 179])

NETNS_DAEMONIZE([bgp-daemon], [nc -l -6 -k fe80::200:2ff:fe01:203%bgp-daemon 179], [bgp_v6.pid])
NS_CHECK_EXEC([ext-foo], [echo "BGP IPv6 server traffic" | nc --send-only -6 fe80::200:2ff:fe01:203%ext-foo 179])

# Perform same set of checks as above for BFD daemon.
# We need to manually check that the message arrived on the receiving end as Ncat will
# produce false positive results over UDP due to lack of ICMP port unreachable messages
# from LRP's IP.
NETNS_DAEMONIZE([bgp-daemon], [nc -l -u 172.16.1.1 3784 > bgp-daemon_bfd_v4.out], [bfd_v4.pid])
NS_CHECK_EXEC([ext-foo], [echo "from ext-foo: BFD IPv4 server traffic" | nc -u 172.16.1.1 3784])
AT_CHECK([cat bgp-daemon_bfd_v4.out], [0], [dnl
from ext-foo: BFD IPv4 server traffic
])

NETNS_DAEMONIZE([bgp-daemon], [nc -l -6 -u fe80::200:2ff:fe01:203%bgp-daemon 3784 > bgp-daemon_bfd_v6.out], [bfd_v6.pid])
NS_CHECK_EXEC([ext-foo], [echo "from ext-foo: BFD IPv6 server traffic" | nc -u -6 fe80::200:2ff:fe01:203%ext-foo 3784])
AT_CHECK([cat bgp-daemon_bfd_v6.out], [0], [dnl
from ext-foo: BFD IPv6 server traffic
])

# Verify connection in other direction. i.e when BGP daemon running on "bgp-daemon" port
# makes a client connection to its peer
NETNS_DAEMONIZE([ext-foo], [nc -l -k 172.16.1.100 179], [reply_bgp_v4.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "BGP IPv4 client traffic" | nc --send-only 172.16.1.100 179])

NETNS_DAEMONIZE([ext-foo], [nc -l -6 -k fe80::210:10ff:fe01:213%ext-foo 179], [reply_bgp_v6.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "BGP IPv6 client traffic" | nc --send-only -6 fe80::210:10ff:fe01:213%bgp-daemon 179])

# Perform same checks in other direction for BFD daemon
NETNS_DAEMONIZE([ext-foo], [nc -l -u 172.16.1.100 3784 > ext-foo_bfd_v4.out], [reply_bfd_v4.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "from bgp-daemon: BFD IPv4 client traffic" | nc -u 172.16.1.100 3784])
AT_CHECK([cat ext-foo_bfd_v4.out], [0], [dnl
from bgp-daemon: BFD IPv4 client traffic
])

NETNS_DAEMONIZE([ext-foo], [nc -l -6 -u fe80::210:10ff:fe01:213%ext-foo 3784 > ext-foo_bfd_v6.out], [reply_bfd_v6.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "from bgp-daemon: BFD IPv6 client traffic" | nc -u -6 fe80::210:10ff:fe01:213%bgp-daemon 3784])
AT_CHECK([cat ext-foo_bfd_v6.out], [0], [dnl
from bgp-daemon: BFD IPv6 client traffic
])

# Verify that hosts on the internal network can reach external networks
NETNS_DAEMONIZE([ext-foo], [nc -l -k 172.16.1.100 2222], [nc_external.pid])
NS_CHECK_EXEC([bar1], [echo "TCP test" | nc -w 1 --send-only 172.16.1.100 2222])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Routing protocol redirect - DGP])
AT_SKIP_IF([test $HAVE_NC = no])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add public
check ovn-nbctl ls-add bar

check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lrp-add R1 rp-bar 00:00:ff:00:00:01 192.168.10.1/24

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovn-nbctl lsp-add bar bar-rp -- set Logical_Switch_Port bar-rp \
    type=router options:router-port=rp-bar \
    -- lsp-set-addresses bar-rp router

check ovn-nbctl lsp-add public bgp-daemon \
    -- lsp-set-addresses bgp-daemon unknown

check ovn-nbctl lrp-set-gateway-chassis rp-public hv1

# Setup container "bar1" representing host on an internal network
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.10.2/24", "00:00:ff:ff:ff:01", \
         "192.168.10.1")
check ovn-nbctl lsp-add bar bar1 \
    -- lsp-set-addresses bar1 "00:00:ff:ff:ff:01 192.168.10.2"

# Setup SNAT for the internal host
check ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.10.2

# Configure external connectivity
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

check ovn-nbctl --wait=hv sync

# Set option that redirects BGP and BFD traffic to a LSP "bgp-daemon"
check ovn-nbctl --wait=sb set logical_router_port rp-public options:routing-protocol-redirect=bgp-daemon
check ovn-nbctl --wait=sb set logical_router_port rp-public options:routing-protocols=BGP,BFD

# Create "bgp-daemon" interface in a namespace with IP and MAC matching LRP "rp-public"
ADD_NAMESPACES(bgp-daemon)
ADD_VETH(bgp-daemon, bgp-daemon, br-int, "172.16.1.1/24", "00:00:02:01:02:03")

ADD_NAMESPACES(ext-foo)
ADD_VETH(ext-foo, ext-foo, br-ext, "172.16.1.100/24", "00:10:10:01:02:13", \
         "172.16.1.1")

# Flip the interface down/up to get proper IPv6 LLA
NS_EXEC([bgp-daemon], [ip link set down bgp-daemon])
NS_EXEC([bgp-daemon], [ip link set up bgp-daemon])
NS_EXEC([ext-foo], [ip link set down ext-foo])
NS_EXEC([ext-foo], [ip link set up ext-foo])

# Wait until IPv6 LLA loses the "tentative" flag otherwise it can't be bound to.
OVS_WAIT_UNTIL([NS_EXEC([bgp-daemon], [ip a show dev bgp-daemon | grep "fe80::" | grep -v tentative])])
OVS_WAIT_UNTIL([NS_EXEC([ext-foo], [ip a show dev ext-foo | grep "fe80::" | grep -v tentative])])

# Verify that BGP control plane traffic is delivered to the "bgp-daemon"
# interface on both IPv4 and IPv6 LLA addresses
NETNS_DAEMONIZE([bgp-daemon], [nc -l -k 172.16.1.1 179], [bgp_v4.pid])
NS_CHECK_EXEC([ext-foo], [echo "BGP IPv4 server traffic" | nc --send-only 172.16.1.1 179])

NETNS_DAEMONIZE([bgp-daemon], [nc -l -6 -k fe80::200:2ff:fe01:203%bgp-daemon 179], [bgp_v6.pid])
NS_CHECK_EXEC([ext-foo], [echo "BGP IPv6 server traffic" | nc --send-only -6 fe80::200:2ff:fe01:203%ext-foo 179])

# Perform same set of checks as above for BFD daemon.
# We need to manually check that the message arrived on the receiving end as Ncat will
# produce false positive results over UDP due to lack of ICMP port unreachable messages
# from LRP's IP.
NETNS_DAEMONIZE([bgp-daemon], [nc -l -u 172.16.1.1 3784 > bgp-daemon_bfd_v4.out], [bfd_v4.pid])
NS_CHECK_EXEC([ext-foo], [echo "from ext-foo: BFD IPv4 server traffic" | nc -u 172.16.1.1 3784])
AT_CHECK([cat bgp-daemon_bfd_v4.out], [0], [dnl
from ext-foo: BFD IPv4 server traffic
])

NETNS_DAEMONIZE([bgp-daemon], [nc -l -6 -u fe80::200:2ff:fe01:203%bgp-daemon 3784 > bgp-daemon_bfd_v6.out], [bfd_v6.pid])
NS_CHECK_EXEC([ext-foo], [echo "from ext-foo: BFD IPv6 server traffic" | nc -u -6 fe80::200:2ff:fe01:203%ext-foo 3784])
AT_CHECK([cat bgp-daemon_bfd_v6.out], [0], [dnl
from ext-foo: BFD IPv6 server traffic
])

# Verify connection in other direction. i.e when BGP daemon running on "bgp-daemon" port
# makes a client connection to its peer
NETNS_DAEMONIZE([ext-foo], [nc -l -k 172.16.1.100 179], [reply_bgp_v4.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "BGP IPv4 client traffic" | nc --send-only 172.16.1.100 179])

NETNS_DAEMONIZE([ext-foo], [nc -l -6 -k fe80::210:10ff:fe01:213%ext-foo 179], [reply_bgp_v6.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "BGP IPv6 client traffic" | nc --send-only -6 fe80::210:10ff:fe01:213%bgp-daemon 179])

# Perform same checks in other direction for BFD daemon
NETNS_DAEMONIZE([ext-foo], [nc -l -u 172.16.1.100 3784 > ext-foo_bfd_v4.out], [reply_bfd_v4.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "from bgp-daemon: BFD IPv4 client traffic" | nc -u 172.16.1.100 3784])
AT_CHECK([cat ext-foo_bfd_v4.out], [0], [dnl
from bgp-daemon: BFD IPv4 client traffic
])

NETNS_DAEMONIZE([ext-foo], [nc -l -6 -u fe80::210:10ff:fe01:213%ext-foo 3784 > ext-foo_bfd_v6.out], [reply_bfd_v6.pid])
NS_CHECK_EXEC([bgp-daemon], [echo "from bgp-daemon: BFD IPv6 client traffic" | nc -u -6 fe80::210:10ff:fe01:213%bgp-daemon 3784])
AT_CHECK([cat ext-foo_bfd_v6.out], [0], [dnl
from bgp-daemon: BFD IPv6 client traffic
])

# Verify that hosts on the internal network can reach external networks
NETNS_DAEMONIZE([ext-foo], [nc -l -k 172.16.1.100 2222], [nc_external.pid])
NS_CHECK_EXEC([bar1], [echo "TCP test" | nc -w 1 --send-only 172.16.1.100 2222])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([NXT_CT_FLUSH_ZONE count])
ovn_start --use-tcp-to-sb
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

dnl Set external-ids in br-int needed for ovn-controller
PARSE_LISTENING_PORT([$ovs_base/ovn-sb/ovsdb-server.log], [TCP_PORT])
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=tcp:127.0.0.1:$TCP_PORT \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

dnl Start ovn-controller
start_daemon ovn-controller
check ovn-appctl -t ovn-controller vlog/set dbg:ct_zone

# sw0-port1 -- sw0

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1

# Make sure address is set in a different transaction.
sleep_sb
stop_ovsdb_controller_updates $TCP_PORT
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 192.168.0.2"

ovs-vsctl add-port br-int p1 -- \
    set Interface p1 external_ids:iface-id=sw0-port1 -- set Interface p1 type=internal

# Make sure ovn-controller runs and claims the port.
ensure_controller_run

# Wake up sb, so that it can handle lsp-set-address, but no the pb->chassis (as updates from controller stillblocked)
wake_up_sb
ensure_controller_run

# And now restarts ovn-controller.
restart_ovsdb_controller_updates $TCP_PORT

wait_for_ports_up
check ovn-nbctl --wait=hv sync

AT_CHECK([ovn-appctl -t ovn-controller ct-zone-list | sed "s/ [[0-9]]*/ ??/" | sort], [0], [dnl
sw0-port1 ??
sw0_dnat ??
sw0_snat ??
])

# Check that we did just the initial zone flush
AT_CHECK([grep -c "NXT_CT_FLUSH_ZONE" ovs-vswitchd.log], [0], [dnl
3
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 prefix delegation - l3gateway ports creation])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-ipv6-prefix_d])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-vsctl set-fail-mode br-ext standalone
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "2001:db8:3333::2/64", "f0:00:00:01:02:05", \
         "2001:db8:3333::1", "nodad")

check_uuid ovn-nbctl create Logical_Router name=R1 options:chassis=hv1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

# Add localnet port on public and router ports between R1 and public.
# This should create the patch ports.
# This is done early in the test as this used to cause some recomputes (due
# to runtime data handler for ovs_interface).
# Hence, we avoid such recompute later in the test, so we only rely on I+P.
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public ln1 \
        -- lsp-set-addresses ln1 unknown \
        -- lsp-set-type ln1 localnet \
        -- lsp-set-options ln1 network_name=phynet

check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

# Wait for a flow outputing to patch port, so we know ovn-controller handled the patch port creation in OVS.
OVN_WAIT_PATCH_PORT_FLOWS(["ln1"], ["./"])

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

check ovn-nbctl set logical_router_port rp-public options:prefix_delegation=true
check ovn-nbctl set logical_router_port rp-public options:prefix=true
check ovn-nbctl set logical_router_port rp-sw0 options:prefix=true

OVN_POPULATE_ARP

check ovn-nbctl --wait=hv sync

cat > dhcpd.conf <<EOF
option dhcp-rebinding-time 10;
option dhcp-renewal-time 5;
subnet6 2001:db8:3333::/56 {
    prefix6 2001:db8:3333:100:: 2001:db8:3333:111:: /64;
}
EOF

NETNS_START_DHCPD([server], [s1], [dhcpd.conf])
check ovn-nbctl --wait=hv sync

AT_CHECK([ovn-appctl debug/dump-peer-ports | sort], [0], [dnl
dp R1 : local = rp-public, remote = public-rp
dp R1 : local = rp-sw0, remote = sw0-rp
dp public : local = public-rp, remote = rp-public
dp sw0 : local = sw0-rp, remote = rp-sw0
])

OVS_WAIT_WHILE([test "$(ovn-nbctl get logical_router_port rp-public ipv6_prefix | cut -c4-15)" = ""])
OVS_WAIT_WHILE([test "$(ovn-nbctl get logical_router_port rp-sw0 ipv6_prefix | cut -c4-15)" = ""])

AT_CHECK([ovn-nbctl get logical_router_port rp-public ipv6_prefix | cut -c3-15], [0], [dnl
[2001:db8:3333]
])
AT_CHECK([ovn-nbctl get logical_router_port rp-sw0 ipv6_prefix | cut -c3-15], [0], [dnl
[2001:db8:3333]
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/failed to query port patch-.*/d
/.*terminating with signal 15.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACLs - persistent sessions])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

ovs-vsctl set-fail-mode br-ext standalone
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# For this test, we want to ensure that established traffic
# is allowed on ACLs when the persist-established option
# is enabled.
#
# To start, we will set up allow-related ACLs.
# We will send traffic and ensure it is allowed. Then we will adjust
# the ACL so it no longer matches, and we will ensure that the traffic
# is no longer allowed.
#
# Next, we will reset the ACL to its initial state, but we will also
# change the ACL to have persist-established enabled.
# We will flush conntrack, and rerun the test exactly as before.
# The difference this time is that after we adjust the ACL so it no
# longer matches, the traffic should still be allowed.

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw swp1 -- lsp-set-addresses swp1 "00:00:00:00:00:01 192.168.1.1"
check ovn-nbctl lsp-add sw swp2 -- lsp-set-addresses swp2 "00:00:00:00:00:02 192.168.1.2"

ADD_NAMESPACES(swp1)
ADD_VETH(swp1, swp1, br-int, "192.168.1.1/24", "00:00:00:00:00:01")

ADD_NAMESPACES(swp2)
ADD_VETH(swp2, swp2, br-int, "192.168.1.2/24", "00:00:00:00:00:02")

# Start a TCP server on swp2.
NETNS_DAEMONIZE(swp2, [server.py -i 192.168.1.2 -p 10000], [server.pid])

# Ensure TCP server is ready for connections
OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
Server Ready
])
: > output.txt

# Make a FIFO and send its output to a client
# from swp1
mkfifo /tmp/myfifo
on_exit 'rm -rf /tmp/myfifo'

NETNS_DAEMONIZE(swp1, [client.py -f "/tmp/myfifo" -i 192.168.1.2 -p 10000], [client.pid])

# First, ensure that we have basic connectivity before we even start setting
# up ACLs.
AT_CHECK([printf "test\n" > /tmp/myfifo], [0], [dnl
])

OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
test
])

: > output.txt

check ovn-nbctl acl-add sw from-lport 1000 'ip4.dst == 192.168.1.2' allow-related
check ovn-nbctl acl-add sw from-lport 0 '1' drop

# Do another basic connectivity check to ensure the ACL is allowing traffic as expected.
AT_CHECK([printf "test\n" > /tmp/myfifo], [0], [dnl
])

OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
test
])

: > output.txt

# At this point, I need to adjust the ACL so it no longer matches. We then need
# to ensure that the traffic does not pass. How we test this is...interesting. I'm
# not sure how to test for a negative condition accurately.

acl_uuid=$(fetch_column nb:ACL _uuid priority=1000)

# Update the ACL so that it no longer matches our client-server traffic
check ovn-nbctl set ACL $acl_uuid match="\"ip4.dst == 192.168.1.3\""

# Send another packet from the client to the server.
AT_CHECK([printf "test\n" > /tmp/myfifo], [0], [dnl
])

# The traffic should be blocked. We'll check the "drop" ACL to see if it has
# been hit. We can't predict the number of packets that will be seen, but we know
# it will be non-zero.
lflow_table=$(ovn-debug lflow-stage-to-ltable ls_in_acl_eval)
drop_acl_lflow_uuid=$(fetch_column Logical_Flow _uuid pipeline=ingress table_id=$lflow_table priority=1000 match="\"reg0[[9]] == 1 && (1)\"")
drop_acl_cookie=$(ovn-debug uuid-to-cookie $drop_acl_lflow_uuid)

OVS_WAIT_FOR_OUTPUT([ovs-ofctl dump-flows br-int | grep "cookie=$drop_acl_cookie" | grep -c "n_packets=[[1-9]][[0-9]]*"], [0], [dnl
1
])

# And just to be safe, let's make sure the output file is still empty
AT_CHECK([cat output.txt], [0], [dnl
])

# Reset the client and server processes so that we create a new connection
client_pid=$(cat client.pid)
server_pid=$(cat server.pid)
kill $server_pid
kill $client_pid
OVS_WAIT_WHILE([kill -0 $server_pid 2>/dev/null])
OVS_WAIT_WHILE([kill -0 $client_pid 2>/dev/null])

NETNS_DAEMONIZE(swp2, [server.py -i 192.168.1.2 -p 20000], [server.pid])

# Ensure TCP server is ready for connections
OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
Server Ready
])
: > output.txt

NETNS_DAEMONIZE(swp1, [client.py -f "/tmp/myfifo" -i 192.168.1.2 -p 20000], [client.pid])

# Now we'll re-set the ACL to allow the traffic.
check ovn-nbctl set ACL $acl_uuid match="\"ip4.dst == 192.168.1.2\""

# We'll also enable persist-established.
check ovn-nbctl --wait=hv set ACL $acl_uuid options:persist-established=true

# Make sure traffic passes
AT_CHECK([printf "test\n" > /tmp/myfifo], [0], [dnl
])

OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
test
])

: > output.txt

# Get the ID for this ACL
acl_id=$(ovn-sbctl get ACL_ID $acl_uuid id)
acl_id=$(printf %x $acl_id)

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.1.2) | \
grep "labels=0x"$acl_id"00000000000000000000" | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | \
sed -e 's/labels=0x[[0-9a-f]]*/labels=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.1,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=<cleared>,protoinfo=(state=<cleared>)
])

# Adjust the ACL so that it no longer matches
check ovn-nbctl set ACL $acl_uuid match="\"ip4.dst == 192.168.1.3\""

# Traffic should still pass
AT_CHECK([printf "test\n" > /tmp/myfifo], [0], [dnl
])

OVS_WAIT_FOR_OUTPUT([cat output.txt], [0], [dnl
test
])

: > output.txt

# Now remove the ACL. This should remove the conntrack entry as well.
check ovn-nbctl --wait=hv acl-del sw from-lport 1000 'ip4.dst == 192.168.1.3'

OVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.1.2) | \
grep "labels=0x"$acl_id"00000000000000000000" | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Routing IPv4 to external network over IPv6 next-hop, Distributed and Centralized NAT])
# Logical network:
#  * R1 is distributed LR
#    * connected to "physical" router "ext1" via IPv6 network
#    * connected to alice via LS "sw0" and bob vial LS "sw1"
#    * provides distributed IPv4 dnat_and_snat for alice
#    * provides centralized IPv4 snat for bob
#  * ext1 acts as a "physical router" connected to R1 over IPv6 and to further
#    external networks via IPv4.
# This test ensures connectivity between hosts on internal IPv4 networks
# to the external IPv4 networks over IPv6 network connecting R1 and ext1.
# +------------+
# |    alice   |---+   +--------+
# +------------+   +---|   R1   |  IPv6 net. +------------+   |
#                      |        |------------|    ext1    |---| IPv4 net.
# +------------+   +---|        |            +------------+   |
# |     bob    |---+   +--------+
# +------------+

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-vsctl set-fail-mode br-ext standalone
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

# Start ovn-controller
start_daemon ovn-controller

# Create router and switch facilitating external connectivity
check ovn-nbctl \
        -- lr-add R1 \
        -- lrp-add R1 lrp-r1-public 00:00:02:ff:ff:01 2001:db8:ffff::1/64 \
        -- ls-add public \
        -- lsp-add public lsp-public-r1 \
        -- lsp-set-type lsp-public-r1 router \
        -- lsp-set-options lsp-public-r1 router-port=lrp-r1-public \
        -- lsp-set-addresses lsp-public-r1 router

# Create HA Distributed GW Port
check ovn-nbctl \
        -- ha-chassis-group-add G1 \
        -- ha-chassis-group-add-chassis G1 hv1 10

group_uuid=$(ovn-nbctl get ha_chassis_group G1 _uuid)
check ovn-nbctl set logical_router_port lrp-r1-public ha_chassis_group="$group_uuid"


# Interconnect external and internal bridges
check ovn-nbctl \
        -- lsp-add public  ext-patch \
        -- lsp-set-addresses ext-patch unknown \
        -- lsp-set-type ext-patch localnet \
        -- lsp-set-options ext-patch network_name=phynet

check ovn-nbctl --wait=hv sync

# Create "external host"
ADD_NAMESPACES(ext1)
ADD_VETH(ext1, ext1, br-ext, "2001:db8:ffff::2/64", "00:00:02:ff:ff:02", [], [nodad])
OVS_WAIT_UNTIL([NS_EXEC([ext1], [ip a show dev ext1 | grep "fe80::" | grep -v tentative])])

# Simulate external IPv4 network "behind" external host
NS_CHECK_EXEC([ext1], [ip link add dummy0 type dummy])
NS_CHECK_EXEC([ext1], [ip link set dummy0 up])
NS_CHECK_EXEC([ext1], [ip addr add 10.42.0.10/32 dev dummy0])

# Add IPv4 route over IPv6 next-hop to the router
check ovn-nbctl lr-route-add R1 10.42.0.10/24 2001:db8:ffff::2 lrp-r1-public

# Test Distributed NAT
# Create internal network and connect it to router
check ovn-nbctl \
        -- lrp-add R1 lrp-r1-sw0 00:00:03:00:00:01 192.168.100.1/24 \
        -- ls-add sw0 \
        -- lsp-add sw0 lsp-sw0-r1 \
        -- lsp-set-type lsp-sw0-r1 router \
        -- lsp-set-options lsp-sw0-r1 router-port=lrp-r1-sw0 \
        -- lsp-set-addresses lsp-sw0-r1 router

# Create "guest host" alice with distributed dnat_and_snat mapping
ADD_NAMESPACES(alice)
ADD_VETH(alice, alice, br-int, "192.168.100.10/24", "00:00:03:00:00:02", \
         "192.168.100.1")
check ovn-nbctl \
        -- lsp-add sw0 alice \
        -- lsp-set-addresses alice "00:00:03:00:00:02 192.168.100.10/24"

check ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.10.1 192.168.100.10 alice 00:00:04:00:00:01

# Add route for R1's external SNAT/DNAT address to external host
NS_EXEC([ext1], [ip route add 172.16.10.1/32 via inet6 2001:db8:ffff::1])

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ping external network from alice via NAT and IPv6 next-hop
NS_CHECK_EXEC([alice], [ping -q -c 3 -i 0.3 -w 2 10.42.0.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Ping alice's DNAT address from external network
NS_EXEC([ext1], [ip neighbor flush dev ext1])
NS_CHECK_EXEC([ext1], [ping -q -c 3 -i 0.3 -w 2 -I 10.42.0.10 172.16.10.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Test Centralized NAT
# Create internal network and connect it to router
check ovn-nbctl \
        -- lrp-add R1 lrp-r1-sw1 00:00:05:00:00:01 192.168.200.1/24 \
        -- ls-add sw1 \
        -- lsp-add sw1 lsp-sw1-r1 \
        -- lsp-set-type lsp-sw1-r1 router \
        -- lsp-set-options lsp-sw1-r1 router-port=lrp-r1-sw1 \
        -- lsp-set-addresses lsp-sw1-r1 router

# Create "guest host" bob with centralized SNAT
ADD_NAMESPACES(bob)
ADD_VETH(bob, bob, br-int, "192.168.200.10/24", "00:00:05:00:00:02", \
         "192.168.200.1")
check ovn-nbctl \
        -- lsp-add sw1 bob \
        -- lsp-set-addresses bob "00:00:05:00:00:02 192.168.200.10/24"
check ovn-nbctl lr-nat-add R1 snat 172.16.10.2 192.168.200.10

# Add route for R1's external SNAT address to external host
NS_EXEC([ext1], [ip route add 172.16.10.2/32 via inet6 2001:db8:ffff::1])

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ping external network from bob via NAT and IPv6 next-hop
NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 10.42.0.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Routing IPv4 to external network over IPv6 next-hop, Gateway router with NAT])
# Logical network:
#  * R1 is gateway LR
#    * connected to "physical" router "ext1" via IPv6 network
#    * connected to alice via LS "sw0" and bob vial LS "sw1"
#    * provides IPv4 dnat_and_snat for alice
#    * provides IPv4 snat for bob
#  * ext1 acts as a "physical router" connected to R1 over IPv6 and to further
#    external networks via IPv4.
# This test ensures connectivity between hosts on internal IPv4 networks
# to the external IPv4 networks over IPv6 network connecting R1 and ext1.
# +------------+
# |    alice   |---+   +--------+
# +------------+   +---|   R1   |  IPv6 net. +------------+   |
#                      |        |------------|    ext1    |---| IPv4 net.
# +------------+   +---|        |            +------------+   |
# |     bob    |---+   +--------+
# +------------+

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-vsctl set-fail-mode br-ext standalone
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

# Start ovn-controller
start_daemon ovn-controller

# Create gateway router and switch facilitating external connectivity
check ovn-nbctl \
        -- lr-add R1 \
        -- lrp-add R1 lrp-r1-public 00:00:02:ff:ff:01 2001:db8:ffff::1/64 \
        -- set Logical_Router R1 options:chassis=hv1 \
        -- ls-add public \
        -- lsp-add public lsp-public-r1 \
        -- lsp-set-type lsp-public-r1 router \
        -- lsp-set-options lsp-public-r1 router-port=lrp-r1-public \
        -- lsp-set-addresses lsp-public-r1 router


# Interconnect external and internal bridges
check ovn-nbctl \
        -- lsp-add public  ext-patch \
        -- lsp-set-addresses ext-patch unknown \
        -- lsp-set-type ext-patch localnet \
        -- lsp-set-options ext-patch network_name=phynet

check ovn-nbctl --wait=hv sync

# Create "external host"
ADD_NAMESPACES(ext1)
ADD_VETH(ext1, ext1, br-ext, "2001:db8:ffff::2/64", "00:00:02:ff:ff:02", [], [nodad])
OVS_WAIT_UNTIL([NS_EXEC([ext1], [ip a show dev ext1 | grep "fe80::" | grep -v tentative])])

# Simulate external IPv4 network "behind" external host
NS_CHECK_EXEC([ext1], [ip link add dummy0 type dummy])
NS_CHECK_EXEC([ext1], [ip link set dummy0 up])
NS_CHECK_EXEC([ext1], [ip addr add 10.42.0.10/32 dev dummy0])

# Add IPv4 route over IPv6 next-hop to the router
check ovn-nbctl lr-route-add R1 10.42.0.10/24 2001:db8:ffff::2 lrp-r1-public

# Test dnat_and_snat NAT type
# Create internal network and connect it to router
check ovn-nbctl \
        -- lrp-add R1 lrp-r1-sw0 00:00:03:00:00:01 192.168.100.1/24 \
        -- ls-add sw0 \
        -- lsp-add sw0 lsp-sw0-r1 \
        -- lsp-set-type lsp-sw0-r1 router \
        -- lsp-set-options lsp-sw0-r1 router-port=lrp-r1-sw0 \
        -- lsp-set-addresses lsp-sw0-r1 router

# Create "guest host" alice with dnat_and_snat mapping
ADD_NAMESPACES(alice)
ADD_VETH(alice, alice, br-int, "192.168.100.10/24", "00:00:03:00:00:02", \
         "192.168.100.1")
check ovn-nbctl \
        -- lsp-add sw0 alice \
        -- lsp-set-addresses alice "00:00:03:00:00:02 192.168.100.10/24"

check ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.10.1 192.168.100.10

# Add route for R1's external SNAT/DNAT address to external host
NS_EXEC([ext1], [ip route add 172.16.10.1/32 via inet6 2001:db8:ffff::1])

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ping external network from alice via NAT and IPv6 next-hop
NS_CHECK_EXEC([alice], [ping -q -c 3 -i 0.3 -w 2 10.42.0.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Ping alice's DNAT address from external network
NS_EXEC([ext1], [ip neighbor flush dev ext1])
NS_CHECK_EXEC([ext1], [ping -q -c 3 -i 0.3 -w 2 -I 10.42.0.10 172.16.10.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Test SNAT
# Create internal network and connect it to router
check ovn-nbctl \
        -- lrp-add R1 lrp-r1-sw1 00:00:05:00:00:01 192.168.200.1/24 \
        -- ls-add sw1 \
        -- lsp-add sw1 lsp-sw1-r1 \
        -- lsp-set-type lsp-sw1-r1 router \
        -- lsp-set-options lsp-sw1-r1 router-port=lrp-r1-sw1 \
        -- lsp-set-addresses lsp-sw1-r1 router

# Create "guest host" bob with SNAT
ADD_NAMESPACES(bob)
ADD_VETH(bob, bob, br-int, "192.168.200.10/24", "00:00:05:00:00:02", \
         "192.168.200.1")
check ovn-nbctl \
        -- lsp-add sw1 bob \
        -- lsp-set-addresses bob "00:00:05:00:00:02 192.168.200.10/24"

check ovn-nbctl lr-nat-add R1 snat 172.16.10.2 192.168.200.10

# Add route for R1's external SNAT address to external host
NS_EXEC([ext1], [ip route add 172.16.10.2/32 via inet6 2001:db8:ffff::1])

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ping external network from bob via NAT and IPv6 next-hop
NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 10.42.0.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Loadbalancer add-route option])
AT_KEYWORDS([ovnlb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# Logical network:
# Two VMs
#   * VM1 with IP address 192.168.100.5
#   * VM2 with IP address 192.168.200.5
#
# VM1 connects to logical switch ls1. ls1 connects to logical router lr1.
# VM2 connects to logical switch ls2. ls2 connects to logical router lr2.
# lr1 and lr2 both connect to logical switch ls-pub.
# * lr1's interface that connects to ls-pub has IP address 172.18.2.110/24
# * lr2's interface that connects to ls-pub has IP address 172.18.1.173/24
#
# lr1 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.11 to 192.168.100.5 (VM1)
#
# lr2 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.12 to 192.168.200.5 (VM2)
#
# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.12 reaches VM2.
# When the NAT rules are set up, there should be MAC_Bindings created that allow for traffic
# to exit lr1, go through ls-pub, and reach the NAT external IP configured on lr2.

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 "00:00:00:00:01:05 192.168.100.5"

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2 -- lsp-set-addresses vm2 "00:00:00:00:02:05 192.168.200.5"

check ovn-nbctl ls-add ls-pub

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:01:01 192.168.100.1/24
check ovn-nbctl lsp-add ls1 ls1-lr1                      \
    -- lsp-set-type ls1-lr1 router                 \
    -- lsp-set-addresses ls1-lr1 router            \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl lr-add lr2
check ovn-nbctl lrp-add lr2 lr2-ls2 00:00:00:00:02:01 192.168.200.1/24
check ovn-nbctl lsp-add ls2 ls2-lr2                      \
    -- lsp-set-type ls2-lr2 router                 \
    -- lsp-set-addresses ls2-lr2 router            \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2

check ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:03:01 172.18.2.110/24
check ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \
    -- lsp-set-type ls-pub-lr1 router                    \
    -- lsp-set-addresses ls-pub-lr1 router               \
    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub

check ovn-nbctl lrp-add lr2 lr2-ls-pub 00:00:00:00:03:02 172.18.1.173/24
check ovn-nbctl lrp-set-gateway-chassis lr2-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr2                      \
    -- lsp-set-type ls-pub-lr2 router                    \
    -- lsp-set-addresses ls-pub-lr2 router               \
    -- lsp-set-options ls-pub-lr2 router-port=lr2-ls-pub

# Putting --add-route on these NAT rules means there is no need to
# add any static routes.
check ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.18.2.11 192.168.100.5
check ovn-nbctl lb-add lb0 172.18.1.12 192.168.200.5
check ovn-nbctl lr-lb-add lr2 lb0

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "192.168.100.5/24", "00:00:00:00:01:05", \
         "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.200.5/24", "00:00:00:00:02:05", \
         "192.168.200.1")

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

AS_BOX([Testing a ping])

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.1.12 | FORMAT_PING], \
[0], [dnl
7 packets transmitted, 0 received, 100% packet loss, time 0ms
])

check ovn-nbctl --wait=hv set load_balancer lb0 options:add_route=true
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.1.12 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

check ovn-nbctl --wait=hv set load_balancer lb0 options:add_route=false
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.1.12 | FORMAT_PING], \
[0], [dnl
7 packets transmitted, 0 received, 100% packet loss, time 0ms
])

# Avoid checking flows on ls-pub due to different ct-zone allocation for cr-ports in I+P/recompute.
OVN_CLEANUP_CONTROLLER([hv1], [], [], [ls-pub])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([neighbor_responder for all])
AT_KEYWORDS([neighbor_responder])
AT_SKIP_IF([test "$HAVE_ARPING" = no])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check_uuid ovn-nbctl create Logical_Router name=lr options:chassis=hv1
check ovn-nbctl ls-add ls

# Connect alice to R2
check ovn-nbctl lrp-add lr lr-ls 00:00:02:01:02:03 192.168.1.254/24
check ovn-nbctl lsp-add ls ls-lr -- set Logical_Switch_Port ls-lr \
    type=router options:router-port=lr-ls addresses=\"00:00:02:01:02:03\"

# Logical port 'foo' in switch 'foo'.
ADD_NAMESPACES(foo)
ADD_VETH(foo, foo, br-int, "192.168.1.1/24", "f0:00:00:01:02:03", \
         "192.168.1.254")
check ovn-nbctl lsp-add ls foo \
-- lsp-set-addresses foo "f0:00:00:01:02:03 192.168.1.1"

check ovn-nbctl lb-add lb0 192.168.1.100 192.168.1.1
check ovn-nbctl lr-lb-add lr lb0
check ovn-nbctl lb-add lb1 172.16.1.100 192.168.1.1
check ovn-nbctl lr-lb-add lr lb1

NS_CHECK_EXEC([foo], [ip route add 172.16.1.100 dev foo])

check ovn-nbctl set load_balancer lb0 options:neighbor_responder=all
check ovn-nbctl set load_balancer lb1 options:neighbor_responder=all
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([foo], [arping -q -c 3 192.168.1.100])
NS_CHECK_EXEC([foo], [arping -q -c 3 172.16.1.100])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP Flush CT entries - IPv4])
AT_KEYWORDS([ecmp])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])
ADD_BR([br-ecmp])

check ovs-ofctl add-flow br-ext action=normal
check ovs-ofctl add-flow br-ecmp action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller
check ovs-vsctl set Open_vSwitch . external-ids:arp-nd-max-timeout-sec=1

check ovn-nbctl set nb_global . options:ecmp_nexthop_monitor_enable="true"

check ovn-nbctl lr-add R1
check ovn-nbctl set logical_router R1 options:chassis=hv1
check ovn-nbctl lr-add R2
check ovn-nbctl set logical_router R2 options:chassis=hv1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public1 00:00:02:01:02:03 172.16.1.1/24

check ovn-nbctl lrp-add R2 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl lrp-add R2 rp-public2 00:00:04:01:02:03 172.16.1.5/24

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl lsp-add public public-rp1 -- set Logical_Switch_Port public-rp1 \
    type=router options:router-port=rp-public1 \
    -- lsp-set-addresses public-rp1 router

check ovn-nbctl lsp-add public public-rp2 -- set Logical_Switch_Port public-rp2 \
    type=router options:router-port=rp-public2 \
    -- lsp-set-addresses public-rp2 router

ADD_NAMESPACES(alice)
ADD_VETH(alice, alice, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 alice \
    -- lsp-set-addresses alice "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(peter)
ADD_VETH(peter, peter, br-int, "192.168.2.2/24", "f0:00:02:01:02:03", \
         "192.168.2.1")
check ovn-nbctl lsp-add sw1 peter \
    -- lsp-set-addresses peter "f0:00:02:01:02:03 192.168.2.2"

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

ADD_NAMESPACES(ecmp-path0)
ADD_VETH(ecmp-p01, ecmp-path0, br-ext, "172.16.1.2/24", "f0:00:00:01:02:04", "172.16.1.1")
ADD_VETH(ecmp-p02, ecmp-path0, br-ecmp, "172.16.2.2/24", "f0:00:00:01:03:04")

ADD_NAMESPACES(ecmp-path1)
ADD_VETH(ecmp-p11, ecmp-path1, br-ext, "172.16.1.3/24", "f0:00:00:01:02:05", "172.16.1.1")
ADD_VETH(ecmp-p12, ecmp-path1, br-ecmp, "172.16.2.3/24", "f0:00:00:01:03:05")

NS_CHECK_EXEC([ecmp-path0], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl
net.ipv4.conf.all.forwarding = 1
])
NS_CHECK_EXEC([ecmp-path1], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl
net.ipv4.conf.all.forwarding = 1
])

ADD_NAMESPACES(bob)
ADD_VETH(bob, bob, br-ecmp, "172.16.2.10/24", "f0:00:00:01:02:06", "172.16.2.2")

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 172.16.2.0/24 172.16.1.2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 172.16.2.0/24 172.16.1.3

wait_for_ports_up
check ovn-nbctl --wait=hv sync
NETNS_DAEMONIZE([alice], [nc -l -k 80], [alice.pid])
NETNS_DAEMONIZE([peter], [nc -l -k 80], [peter.pid])

NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -z 192.168.1.2 80], [0])

wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='172.16.1.2'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.3'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000,protoinfo=(state=<cleared>)
])

# Change bob default IP address
NS_CHECK_EXEC([bob], [ip route del 0.0.0.0/0 via 172.16.2.2])
NS_CHECK_EXEC([bob], [ip route add 0.0.0.0/0 via 172.16.2.3])

NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -z 192.168.1.2 80], [0])

wait_row_count ECMP_Nexthop 2
check_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='172.16.1.2'
check_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.3'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

# Remove first ECMP route
check ovn-nbctl lr-route-del  R1 172.16.2.0/24 172.16.1.2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 1
check_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.3'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

# Add the route back and verify we do not flush if we have multiple next-hops with the same mac address
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 172.16.2.0/24 172.16.1.2
wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='172.16.1.2'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.3'

NS_CHECK_EXEC([ecmp-path0], [ip link set dev ecmp-p01 address f0:00:00:01:02:05])
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.2'

# Change bob default IP address
NS_CHECK_EXEC([bob], [ip route del 0.0.0.0/0 via 172.16.2.3])
NS_CHECK_EXEC([bob], [ip route add 0.0.0.0/0 via 172.16.2.2])

NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -z 192.168.1.2 80], [0])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

# Remove first ECMP route
check ovn-nbctl lr-route-del R1 172.16.2.0/24 172.16.1.2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 1

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
])

# Remove second ECMP route
check ovn-nbctl lr-route-del R1
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 0

NS_CHECK_EXEC([ecmp-path0], [ip link set dev ecmp-p01 address f0:00:00:01:02:06])

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 172.16.2.0/24 172.16.1.2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 172.16.2.0/24 172.16.1.3

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R2 172.16.2.0/24 172.16.1.2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R2 172.16.2.0/24 172.16.1.3

check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 4

NS_CHECK_EXEC([ecmp-path0], [ip route add 192.168.2.2/32 via 172.16.1.5])
NS_CHECK_EXEC([ecmp-path1], [ip route add 192.168.2.2/32 via 172.16.1.5])

NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -z 192.168.1.2 80], [0])

NS_CHECK_EXEC([bob], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -z 192.168.2.2 80], [0])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
icmp,orig=(src=172.16.2.10,dst=192.168.2.2,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
tcp,orig=(src=172.16.2.10,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.2.10,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
])

check ovn-nbctl lr-route-del R1
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:06' ECMP_Nexthop mac nexthop='172.16.1.2'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='172.16.1.3'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmp,orig=(src=172.16.2.10,dst=192.168.2.2,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.2.10,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
tcp,orig=(src=172.16.2.10,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.2.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
])

check ovn-nbctl lr-route-del R2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 0
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP Flush CT entries - IPv6])
AT_KEYWORDS([ecmp])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])
ADD_BR([br-ecmp])

check ovs-ofctl add-flow br-ext action=normal
check ovs-ofctl add-flow br-ecmp action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller
check ovs-vsctl set Open_vSwitch . external-ids:arp-nd-max-timeout-sec=1

check ovn-nbctl set nb_global . options:ecmp_nexthop_monitor_enable="true"

check ovn-nbctl lr-add R1
check ovn-nbctl set logical_router R1 options:chassis=hv1
check ovn-nbctl lr-add R2
check ovn-nbctl set logical_router R2 options:chassis=hv1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 fd11::1/64
check ovn-nbctl lrp-add R1 rp-public1 00:00:02:01:02:03 fd12::1/64

check ovn-nbctl lrp-add R2 rp-sw1 00:00:03:01:02:03 fd14::1/64
check ovn-nbctl lrp-add R2 rp-public2 00:00:04:01:02:03 fd12::5/64

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl lsp-add public public-rp1 -- set Logical_Switch_Port public-rp1 \
    type=router options:router-port=rp-public1 \
    -- lsp-set-addresses public-rp1 router

check ovn-nbctl lsp-add public public-rp2 -- set Logical_Switch_Port public-rp2 \
    type=router options:router-port=rp-public2 \
    -- lsp-set-addresses public-rp2 router

ADD_NAMESPACES(alice)
ADD_VETH(alice, alice, br-int, "fd11::2/64", "f0:00:00:01:02:03", "fd11::1", "nodad")
check ovn-nbctl lsp-add sw0 alice -- lsp-set-addresses alice "f0:00:00:01:02:03 fd11::2"

ADD_NAMESPACES(peter)
ADD_VETH(peter, peter, br-int, "fd14::2/64", "f0:00:02:01:02:03", "fd14::1", "nodad")
check ovn-nbctl lsp-add sw1 peter -- lsp-set-addresses peter "f0:00:02:01:02:03 fd14::2"

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

ADD_NAMESPACES(ecmp-path0)
ADD_VETH(ecmp-p01, ecmp-path0, br-ext, "fd12::2/64", "f0:00:00:01:02:04", "fd12::1", "nodad")
ADD_VETH(ecmp-p02, ecmp-path0, br-ecmp, "fd13::2/64", "f0:00:00:01:03:04")
OVS_WAIT_UNTIL([NS_EXEC([ecmp-path0], [ip a show dev ecmp-p02 | grep "fe80::" | grep -v tentative])])

ADD_NAMESPACES(ecmp-path1)
ADD_VETH(ecmp-p11, ecmp-path1, br-ext, "fd12::3/64", "f0:00:00:01:02:05", "fd12::1", "nodad")
ADD_VETH(ecmp-p12, ecmp-path1, br-ecmp, "fd13::3/64", "f0:00:00:01:03:05")
OVS_WAIT_UNTIL([NS_EXEC([ecmp-path1], [ip a show dev ecmp-p12 | grep "fe80::" | grep -v tentative])])

ADD_NAMESPACES(bob)
ADD_VETH(bob, bob, br-ecmp, "fd13::a/64", "f0:00:00:01:02:06", "fd13::2", "nodad")

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 fd13::/64 fd12::2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 fd13::/64 fd12::3

NS_CHECK_EXEC([ecmp-path0], [sysctl -w net.ipv6.conf.all.forwarding=1],[0], [dnl
net.ipv6.conf.all.forwarding = 1
])
NS_CHECK_EXEC([ecmp-path1], [sysctl -w net.ipv6.conf.all.forwarding=1],[0], [dnl
net.ipv6.conf.all.forwarding = 1
])

check ovn-nbctl --wait=hv sync
NETNS_DAEMONIZE([alice], [nc -6 -l -k 80], [alice.pid])
NETNS_DAEMONIZE([peter], [nc -6 -l -k 80], [peter.pid])

NS_CHECK_EXEC([bob], [ping6 -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

NS_CHECK_EXEC([bob], [nc -6 -z fd11::2 80], [0])

wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='"fd12::2"'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::3"'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000,protoinfo=(state=<cleared>)
])

# Change bob default IP address
NS_CHECK_EXEC([bob], [ip -6 route del ::/0 via fd13::2])
NS_CHECK_EXEC([bob], [ip -6 route add ::/0 via fd13::3])

NS_CHECK_EXEC([bob], [ping -6 -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -6 -z fd11::2 80], [0])

wait_row_count ECMP_Nexthop 2
check_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='"fd12::2"'
check_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::3"'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020400000000,protoinfo=(state=<cleared>)
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

# Remove first ECMP route
check ovn-nbctl lr-route-del R1 fd13::/64 fd12::2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 1
check_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::3"'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

 Add the route back and verify we do not flush if we have multiple next-hops with the same mac address
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 fd13::/64 fd12::2
wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:04' ECMP_Nexthop mac nexthop='"fd12::2"'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::3"'
#
NS_CHECK_EXEC([ecmp-path0], [ip link set dev ecmp-p01 address f0:00:00:01:02:05])
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::2"'

# Change bob default IP address
NS_CHECK_EXEC([bob], [ip -6 route del ::/0 via fd13::3])
NS_CHECK_EXEC([bob], [ip -6 route add ::/0 via fd13::2])

NS_CHECK_EXEC([bob], [ping -6 -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -6 -z fd11::2 80], [0])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020500000000,protoinfo=(state=<cleared>)
])

# Remove first ECMP route
check ovn-nbctl lr-route-del R1 fd13::/64 fd12::2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 1

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
])

# Remove second ECMP route
check ovn-nbctl lr-route-del R1
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 0

NS_CHECK_EXEC([ecmp-path0], [ip link set dev ecmp-p01 address f0:00:00:01:02:06])

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 fd13::/64 fd12::2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R1 fd13::/64 fd12::3

check ovn-nbctl --ecmp-symmetric-reply lr-route-add R2 fd13::/64 fd12::2
check ovn-nbctl --ecmp-symmetric-reply lr-route-add R2 fd13::/64 fd12::3

check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 4

NS_CHECK_EXEC([ecmp-path0], [ip route add fd14::2/128 via fd12::5])
NS_CHECK_EXEC([ecmp-path1], [ip route add fd14::2/128 via fd12::5])

NS_CHECK_EXEC([bob], [ping -6 -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -6 -z fd11::2 80], [0])

NS_CHECK_EXEC([bob], [ping -6 -q -c 3 -i 0.3 -w 2 fd14::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
NS_CHECK_EXEC([bob], [nc -6 -z fd14::2 80], [0])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
icmpv6,orig=(src=fd13::a,dst=fd14::2,id=<cleared>,type=128,code=0),reply=(src=fd14::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
tcp,orig=(src=fd13::a,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
tcp,orig=(src=fd13::a,dst=fd14::2,sport=<cleared>,dport=<cleared>),reply=(src=fd14::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
])

# Remove second ECMP route
check ovn-nbctl lr-route-del R1
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 2
wait_column 'f0:00:00:01:02:06' ECMP_Nexthop mac nexthop='"fd12::2"'
wait_column 'f0:00:00:01:02:05' ECMP_Nexthop mac nexthop='"fd12::3"'

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd13::a) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
icmpv6,orig=(src=fd13::a,dst=fd14::2,id=<cleared>,type=128,code=0),reply=(src=fd14::2,dst=fd13::a,id=<cleared>,type=129,code=0),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000
tcp,orig=(src=fd13::a,dst=fd14::2,sport=<cleared>,dport=<cleared>),reply=(src=fd14::2,dst=fd13::a,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0xf0000001020600000000,protoinfo=(state=<cleared>)
])

check ovn-nbctl lr-route-del R2
check ovn-nbctl --wait=hv sync
wait_row_count ECMP_Nexthop 0
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.2.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/' | sort], [0], [dnl
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - DGP])

VRF_RESERVE([1337])
VRF_RESERVE([1338])

# This test uses dynamic routing on a simulated multi-tenant internet
# connection.
# Tenant 1 (pr1, p1, vif1) is connected to the internet via NAT on pr1.
# Tenant 2 (pr2, p2, vif2) is connected to the internet via routing.
# The connections of pr1 and pr2 to public are using DGPs.
# The connection from internet to phys is also using a DGP.
# The LR internet is running dynamic-routing.
# The LS phys is assumed to be used for peering with a router outside OVN.
#
#
# +----+       +----+
# |vif1|       |vif2|
# +--+-+       +--+-+
#    |            |
# +--+--+      +--+--+
# |LS p1|      |LS p2|
# +--+--+      +--+--+
#    |            |
# +--+---+     +--+---+
# |LR pr1|     |LR pr2|
# +-----++     ++-----+
#       |       |
#      ++-------++
#      |LS public|
#      +-----+---+
#            |
#      +-----+-----+
#      |LR internet|
#      +-----+-----+
#            |
#        +---+---+
#        |LS phys|
#        +-------+

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

# LS setup.

check ovn-nbctl ls-add public
check ovn-nbctl ls-add phys
check ovn-nbctl ls-add p1
check ovn-nbctl ls-add p2

# LR internet setup.

check ovn-nbctl lr-add internet \
    -- set Logical_Router internet options:dynamic-routing=true \
                                   options:requested-tnl-key=1337

check ovn-nbctl lrp-add internet internet-public \
        00:00:02:01:02:03 192.0.2.1/24 \
    -- set Logical_Router_Port internet-public \
            options:dynamic-routing-redistribute="connected,static"
check ovn-nbctl lsp-add public public-internet \
    -- set Logical_Switch_Port public-internet type=router \
            options:router-port=internet-public \
    -- lsp-set-addresses public-internet router

check ovn-nbctl lrp-add internet internet-phys \
        00:00:ff:00:00:01 192.168.10.1/24 \
    -- set Logical_Router_Port internet-phys \
            options:dynamic-routing-maintain-vrf=true
check ovn-nbctl lrp-set-gateway-chassis internet-phys hv1
check ovn-nbctl lsp-add phys phys-internet \
    -- set Logical_Switch_Port phys-internet type=router \
            options:router-port=internet-phys \
    -- lsp-set-addresses phys-internet router

# LR pr1 setup.

check ovn-nbctl lr-add pr1 \
    -- set Logical_Router pr1 options:requested-tnl-key=1338

check ovn-nbctl lrp-add pr1 pr1-public \
        00:00:02:01:02:04 192.0.2.2/24
check ovn-nbctl lrp-set-gateway-chassis pr1-public hv1
check ovn-nbctl lsp-add public public-pr1 \
    -- set Logical_Switch_Port public-pr1 type=router \
            options:router-port=pr1-public \
    -- lsp-set-addresses public-pr1 router

check ovn-nbctl lrp-add pr1 pr1-p1 \
        00:00:03:00:00:01 10.0.0.1/24
check ovn-nbctl lsp-add p1 p1-pr1 \
    -- set Logical_Switch_Port p1-pr1 type=router \
            options:router-port=pr1-p1 \
    -- lsp-set-addresses p1-pr1 router

check ovn-nbctl lr-route-add pr1 0.0.0.0/0 192.0.2.1

# LR pr2 setup.

check ovn-nbctl lr-add pr2 \
    -- set Logical_Router pr2 options:requested-tnl-key=1339

check ovn-nbctl lrp-add pr2 pr2-public \
        00:00:02:01:02:05 192.0.2.3/24
check ovn-nbctl lrp-set-gateway-chassis pr2-public hv1
check ovn-nbctl lsp-add public public-pr2 \
    -- set Logical_Switch_Port public-pr2 type=router \
            options:router-port=pr2-public \
    -- lsp-set-addresses public-pr2 router

check ovn-nbctl lrp-add pr2 pr2-p2 \
        00:00:04:00:00:01 198.51.100.1/24
check ovn-nbctl lsp-add p2 p2-pr2 \
    -- set Logical_Switch_Port p2-pr2 type=router \
            options:router-port=pr2-p2 \
    -- lsp-set-addresses p2-pr2 router

check ovn-nbctl lr-route-add pr2 0.0.0.0/0 192.0.2.1

# Setup lsp "vif1" with NAT.
check ovn-nbctl lsp-add p1 vif1 \
    -- lsp-set-addresses vif1 "00:00:ff:ff:ff:01 10.0.0.2"
check ovn-nbctl lr-nat-add pr1 dnat_and_snat 192.0.2.10 10.0.0.2

# Setup lsp "vif2" with a static route on LR internet.
check ovn-nbctl lsp-add p2 vif2 \
    -- lsp-set-addresses vif2 "00:00:ff:ff:ff:02 198.51.100.10"
check ovn-nbctl lr-route-add internet 198.51.100.0/24 192.0.2.3

# Configure external connectivity.
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add phys phys1 \
    -- lsp-set-addresses phys1 unknown \
    -- lsp-set-type phys1 localnet \
    -- lsp-set-options phys1 network_name=phynet

check ovn-nbctl --wait=hv sync
wait_for_ports_up public-internet phys-internet public-pr1 p1-pr1 public-pr2 p2-pr2

# Now the ovn-controller should have setup a vrf named "ovnvrf1337".
# It should contain routes for:
# * 192.0.2.0/24
# * 198.51.100.0/24

AT_CHECK([ip vrf show ovnvrf1337], [0], [dnl
ovnvrf1337 1337
])

OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.0/24 proto ovn metric 1000
blackhole 198.51.100.0/24 proto ovn metric 1000])

# We now switch to announcing host routes and expect 192.0.2.0/24 to be gone
# and the following to be added:
# * 192.0.2.1/32
# * 192.0.2.2/32
# * 192.0.2.3/32
# * 192.0.2.10/32
# The last 3 of them are local to the current chassis so we expect a better
# prio.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-public \
    options:dynamic-routing-redistribute="connected-as-host,static"

OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000])

# If the pr1-public lrp is now removed from this hypervisor the route metric
# will go back to the default.
# For this we just schedule it on a non existing chassis.
check ovn-nbctl lrp-del-gateway-chassis pr1-public hv1
check ovn-nbctl --wait=hv lrp-set-gateway-chassis pr1-public hv123
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 1000
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 1000
blackhole 198.51.100.0/24 proto ovn metric 1000])

# Moving pr1-public back will also change the route metrics again.
check ovn-nbctl lrp-del-gateway-chassis pr1-public hv123
check ovn-nbctl --wait=hv lrp-set-gateway-chassis pr1-public hv1
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000])

# Disable maintaining the vrf as some tests below would cause the vrfs to be
# removed.
check ovn-nbctl set Logical_Router_Port internet-phys \
    options:dynamic-routing-maintain-vrf=false

# Now we test route learning.
check_row_count Learned_Route 0
check ip route add 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1
lp=$(fetch_column port_binding _uuid logical_port=internet-phys)
check_row_count Learned_Route 1 logical_port=$lp ip_prefix=233.252.0.0/24 nexthop=192.168.10.10

# If we remove the route it is also gone.
check ip route del 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 0

# By setting a learning interface filter will prevent us from learning the
# route again. The Port referenced by the name does not even exist.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
      options:dynamic-routing-port-name=thisportdoesnotexist
check ip route add 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 0

# Setting the local ovsdb to map this port to "lo" will make route learning
# work again.
check ovs-vsctl set Open_vSwitch . \
    external-ids:dynamic-routing-port-mapping="thisisirrelevant=andjustfortesting,thisportdoesnotexist=lo"
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1

# Now we try the interface filter with an existing port.
check ovn-nbctl lsp-add phys mylearninglsp
check ovs-vsctl -- add-port br-int hv1-mll -- \
    set interface hv1-mll type=internal external-ids:iface-id=mylearninglsp
check ip link set hv1-mll up
wait_for_ports_up mylearninglsp

check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
      options:dynamic-routing-port-name=mylearninglsp

check ip route add 233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1 ip_prefix=233.253.0.0/24 nexthop=192.168.20.20

# Stopping the ovn-controller will clean up the route entries created by it.
# We first need to unset dynamic-routing-maintain-vrf as otherwise it will
# delete the whole vrf.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
                             options:dynamic-routing-maintain-vrf=false
OVN_CLEANUP_CONTROLLER([hv1])
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Starting it again will add the routes again.
start_daemon ovn-controller
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" == "running"])
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Changing the vrf name will switch to the new one.
# The old vrf will be removed.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
    options:dynamic-routing-maintain-vrf=true
check ovn-nbctl --wait=hv set Logical_Router internet \
    options:dynamic-routing-vrf-name=ovnvrf1338
AT_CHECK([ip vrf | grep -q ovnvrf1337], [1], [])
OVN_ROUTE_EQUAL([ovnvrf1338], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Stoping with --restart will not touch the routes.
check ovn-appctl -t ovn-controller exit --restart
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" != "running"])
OVN_ROUTE_EQUAL([ovnvrf1338], [dnl
blackhole 192.0.2.1 proto ovn metric 1000
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# When we now stop the ovn-controller it will remove the VRF.
start_daemon ovn-controller
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" == "running"])
check ovn-nbctl --wait=hv sync
OVN_CLEANUP_CONTROLLER([hv1])
AT_CHECK([ip vrf | grep -q ovnvrf1338], [1], [])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - Gateway Router])

VRF_RESERVE([1337])

# This test uses dynamic routing on a simulated multi-tenant internet
# connection.
# Tenant 1 (pr1, p1, vif1) is connected to the internet via NAT on pr1.
# Tenant 2 (pr2, p2, vif2) is connected to the internet via routing.
# The connections of pr1 and pr2 to public are using DGPs.
# The LR internet is a gateway router.
# The LR internet is running dynamic-routing.
# The LS phys is assumed to be used for peering with a router outside OVN.
#
#
# +----+       +----+
# |vif1|       |vif2|
# +--+-+       +--+-+
#    |            |
# +--+--+      +--+--+
# |LS p1|      |LS p2|
# +--+--+      +--+--+
#    |            |
# +--+---+     +--+---+
# |LR pr1|     |LR pr2|
# +-----++     ++-----+
#       |       |
#      ++-------++
#      |LS public|
#      +-----+---+
#            |
#      +-----+-----+
#      |LR internet|
#      +-----+-----+
#            |
#        +---+---+
#        |LS phys|
#        +-------+

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

# LS setup.

check ovn-nbctl ls-add public
check ovn-nbctl ls-add phys
check ovn-nbctl ls-add p1
check ovn-nbctl ls-add p2

# LR internet setup.

check ovn-nbctl lr-add internet \
    -- set Logical_Router internet options:dynamic-routing=true \
                                   options:requested-tnl-key=1337 \
                                   options:chassis=hv1

check ovn-nbctl lrp-add internet internet-public \
        00:00:02:01:02:03 192.0.2.1/24 \
    -- set Logical_Router_Port internet-public \
            options:dynamic-routing-redistribute="connected,static" \
            options:dynamic-routing-port-name=wedontlearnstuffhere
check ovn-nbctl lsp-add public public-internet \
    -- set Logical_Switch_Port public-internet type=router \
            options:router-port=internet-public \
    -- lsp-set-addresses public-internet router

check ovn-nbctl lrp-add internet internet-phys \
        00:00:ff:00:00:01 192.168.10.1/24 \
    -- set Logical_Router_Port internet-phys \
            options:dynamic-routing-maintain-vrf=true
check ovn-nbctl lsp-add phys phys-internet \
    -- set Logical_Switch_Port phys-internet type=router \
            options:router-port=internet-phys \
    -- lsp-set-addresses phys-internet router

# LR pr1 setup.

check ovn-nbctl lr-add pr1 \
    -- set Logical_Router pr1 options:requested-tnl-key=1338

check ovn-nbctl lrp-add pr1 pr1-public \
        00:00:02:01:02:04 192.0.2.2/24
check ovn-nbctl lrp-set-gateway-chassis pr1-public hv1
check ovn-nbctl lsp-add public public-pr1 \
    -- set Logical_Switch_Port public-pr1 type=router \
            options:router-port=pr1-public \
    -- lsp-set-addresses public-pr1 router

check ovn-nbctl lrp-add pr1 pr1-p1 \
        00:00:03:00:00:01 10.0.0.1/24
check ovn-nbctl lsp-add p1 p1-pr1 \
    -- set Logical_Switch_Port p1-pr1 type=router \
            options:router-port=pr1-p1 \
    -- lsp-set-addresses p1-pr1 router

check ovn-nbctl lr-route-add pr1 0.0.0.0/0 192.0.2.1

# LR pr2 setup.

check ovn-nbctl lr-add pr2 \
    -- set Logical_Router pr2 options:requested-tnl-key=1339

check ovn-nbctl lrp-add pr2 pr2-public \
        00:00:02:01:02:05 192.0.2.3/24
check ovn-nbctl lrp-set-gateway-chassis pr2-public hv1
check ovn-nbctl lsp-add public public-pr2 \
    -- set Logical_Switch_Port public-pr2 type=router \
            options:router-port=pr2-public \
    -- lsp-set-addresses public-pr2 router

check ovn-nbctl lrp-add pr2 pr2-p2 \
        00:00:04:00:00:01 198.51.100.1/24
check ovn-nbctl lsp-add p2 p2-pr2 \
    -- set Logical_Switch_Port p2-pr2 type=router \
            options:router-port=pr2-p2 \
    -- lsp-set-addresses p2-pr2 router

check ovn-nbctl lr-route-add pr2 0.0.0.0/0 192.0.2.1

# Setup lsp "vif1" with NAT.
check ovn-nbctl lsp-add p1 vif1 \
    -- lsp-set-addresses vif1 "00:00:ff:ff:ff:01 10.0.0.2"
check ovn-nbctl lr-nat-add pr1 dnat_and_snat 192.0.2.10 10.0.0.2

# Setup lsp "vif2" with a static route on LR internet.
check ovn-nbctl lsp-add p2 vif2 \
    -- lsp-set-addresses vif2 "00:00:ff:ff:ff:02 198.51.100.10"
check ovn-nbctl lr-route-add internet 198.51.100.0/24 192.0.2.3

# Configure external connectivity.
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add phys phys1 \
    -- lsp-set-addresses phys1 unknown \
    -- lsp-set-type phys1 localnet \
    -- lsp-set-options phys1 network_name=phynet

check ovn-nbctl --wait=hv sync
wait_for_ports_up public-internet phys-internet public-pr1 p1-pr1 public-pr2 p2-pr2

# Now the ovn-controller should have setup a vrf named "ovnvrf1337".
# It should contain routes for:
# * 192.0.2.0/24
# * 198.51.100.0/24

AT_CHECK([ip vrf show ovnvrf1337], [0], [dnl
ovnvrf1337 1337
])

OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.0/24 proto ovn metric 1000
blackhole 198.51.100.0/24 proto ovn metric 1000])

# We now switch to announcing host routes and expect 192.0.2.0/24 to be gone
# and the following to be added:
# * 192.0.2.1/32
# * 192.0.2.2/32
# * 192.0.2.3/32
# * 192.0.2.10/32
# The last 3 of them are local to the current chassis so we expect a better
# prio.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-public \
    options:dynamic-routing-redistribute="connected-as-host,static"

OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 100
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000])

# If the pr1-public lrp is now removed from this hypervisor the route metric
# will go back to the default.
# For this we just schedule it on a non existing chassis.
check ovn-nbctl lrp-del-gateway-chassis pr1-public hv1
check ovn-nbctl --wait=hv lrp-set-gateway-chassis pr1-public hv123
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 100
blackhole 192.0.2.2 proto ovn metric 1000
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 1000
blackhole 198.51.100.0/24 proto ovn metric 1000])

# Moving pr1-public back will also change the route metrics again.
check ovn-nbctl lrp-del-gateway-chassis pr1-public hv123
check ovn-nbctl --wait=hv lrp-set-gateway-chassis pr1-public hv1
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 100
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000])

# Disable maintaining the vrf as some tests below would cause the vrfs to be
# removed.
check ovn-nbctl set Logical_Router_Port internet-phys \
    options:dynamic-routing-maintain-vrf=false

# Now we test route learning.
check_row_count Learned_Route 0
check ip route add 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1
lp=$(fetch_column port_binding _uuid logical_port=internet-phys)
check_row_count Learned_Route 1 logical_port=$lp ip_prefix=233.252.0.0/24 nexthop=192.168.10.10

# If we remove the route it is also gone.
check ip route del 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 0

# By setting a learning interface filter will prevent us from learning the
# route again. The Port referenced by the name does not even exist.
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
    options:dynamic-routing-port-name=thisportdoesnotexist
check ip route add 233.252.0.0/24 via 192.168.10.10 dev lo onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 0

# Setting the local ovsdb to map this port to "lo" will make route learning
# work again.
check ovs-vsctl set Open_vSwitch . \
    external-ids:dynamic-routing-port-mapping="thisisirrelevant=andjustfortesting,thisportdoesnotexist=lo"
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1

# Now we try the interface filter with an existing port.
check ovn-nbctl lsp-add phys mylearninglsp
check ovs-vsctl -- add-port br-int hv1-mll -- \
    set interface hv1-mll type=internal external-ids:iface-id=mylearninglsp
check ip link set hv1-mll up
wait_for_ports_up mylearninglsp

check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
    options:dynamic-routing-port-name=mylearninglsp

check ip route add 233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink vrf ovnvrf1337
check ovn-nbctl --wait=hv sync
check_row_count Learned_Route 1 ip_prefix=233.253.0.0/24 nexthop=192.168.20.20

# Stopping the ovn-controller will clean up the route entries created by it.
# We first need to unset dynamic-routing-maintain-vrf as otherwise it will
# delete the whole vrf
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
                             options:dynamic-routing-maintain-vrf=false
OVN_CLEANUP_CONTROLLER([hv1])
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Starting it again will add the routes again.
start_daemon ovn-controller
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" == "running"])
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 100
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Stoping with --restart will not touch the routes.
check ovn-appctl -t ovn-controller exit --restart
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" != "running"])
OVN_ROUTE_EQUAL([ovnvrf1337], [dnl
blackhole 192.0.2.1 proto ovn metric 100
blackhole 192.0.2.2 proto ovn metric 100
blackhole 192.0.2.3 proto ovn metric 100
blackhole 192.0.2.10 proto ovn metric 100
blackhole 198.51.100.0/24 proto ovn metric 1000
233.252.0.0/24 via 192.168.10.10 dev lo onlink
233.253.0.0/24 via 192.168.20.20 dev hv1-mll onlink])

# Now we set maintain-vrf again and stop the ovn-controller.
# It will then remove the VRF.
start_daemon ovn-controller
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" == "running"])
check ovn-nbctl --wait=hv set Logical_Router_Port internet-phys \
        options:dynamic-routing-maintain-vrf=true
OVN_CLEANUP_CONTROLLER([hv1])
AT_CHECK([ip vrf | grep -q ovnvrf1337], [1], [])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - LB VIPs on gateway router IPv4])
AT_KEYWORDS([dynamic-routing])

CHECK_VRF()
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

vrf=1000
VRF_RESERVE([$vrf])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

OVS_WAIT_WHILE([ip link | grep -q ovnvrf$vrf:.*UP])

check ovn-nbctl                                             \
    -- lr-add R1                                            \
    -- set Logical_Router R1                                \
            options:requested-tnl-key=$vrf                  \
            options:dynamic-routing=true                    \
    -- ls-add sw0                                           \
    -- ls-add public                                        \
    -- lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24   \
    -- lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-options rp-public                            \
            dynamic-routing-maintain-vrf=true               \
            dynamic-routing-redistribute=lb                 \
    -- set logical_router R1 options:chassis=hv1            \
    -- lsp-add sw0 sw0-rp                                   \
    -- set Logical_Switch_Port sw0-rp type=router           \
            options:router-port=rp-sw0                      \
    -- lsp-set-addresses sw0-rp router                      \
    -- lsp-add public public-rp                             \
    -- set Logical_Switch_Port public-rp type=router        \
            options:router-port=rp-public                   \
    -- lsp-set-addresses public-rp router                   \
    -- lsp-add public public1                               \
    -- lsp-set-addresses public1 unknown                    \
    -- lsp-set-type public1 localnet                        \
    -- lsp-set-options public1 network_name=phynet

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync
wait_for_ports_up

AT_CHECK([test `ip route show table $vrf | wc -l` -eq 1], [1])

# Create a load balancer and associate to R1.
check ovn-nbctl                                   \
    -- lb-add lb1 172.16.1.150:80 172.16.1.100:80 \
    -- lr-lb-add R1 lb1
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 172.16.1.150 proto ovn metric 1000])

# Add distributed router connected through "join" LS and ensure
# that its LB VIPs are redistributed by R1. LS join has no
# IP config, routers reach each other over IPv6 LLAs.
check ovn-nbctl \
    -- remove Logical_Router_Port rp-public                    \
            options dynamic-routing-redistribute               \
    -- lrp-add R1 r1-join 00:00:00:00:ff:02                    \
    -- lrp-set-options r1-join dynamic-routing-redistribute=lb \
    -- ls-add ls-join                                          \
    -- lsp-add ls-join lsp-join-to-r1                          \
    -- lsp-set-type lsp-join-to-r1 router                      \
    -- lsp-set-options lsp-join-to-r1 router-port=r1-join      \
    -- lsp-set-addresses lsp-join-to-r1 router                 \
    -- lr-add R2                                               \
    -- lrp-add R2 r2-join 00:00:00:00:fe:02                    \
    -- lsp-add ls-join lsp-join-to-r2                          \
    -- lsp-set-type lsp-join-to-r2 router                      \
    -- lsp-set-options lsp-join-to-r2 router-port=r2-join      \
    -- lrp-set-gateway-chassis r2-join hv1

# Create a load balancer and associate to R2.
check ovn-nbctl                                    \
    -- lb-add lb2 10.42.10.10:80 192.168.123.10:80 \
    -- lr-lb-add R2 lb2
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 10.42.10.10 proto ovn metric 100
blackhole 172.16.1.150 proto ovn metric 1000])

# Move DGW of R2 to another chassis to verify that route priority decreases.
check ovn-nbctl                              \
    -- lrp-del-gateway-chassis r2-join hv1   \
    -- lrp-set-gateway-chassis r2-join hv123
check ovn-nbctl --wait=hv sync

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 10.42.10.10 proto ovn metric 1000
blackhole 172.16.1.150 proto ovn metric 1000])

# Before cleanup of hv1 ovn-controller, trigger a recompute
# to cleanup the local datapaths. Otherwise, the test will fail.
# This is because we don't remove a datapath from
# the local_datapaths hmap while handling the port binding
# changes incrementally yet.
check ovn-appctl inc-engine/recompute

OVN_CLEANUP_CONTROLLER([hv1])

# Ensure system resources are cleaned up.
AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP], [1])
AT_CHECK([test `ip route show table $vrf | wc -l` -eq 1], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - LB VIPs on gateway router IPv6])
AT_KEYWORDS([dynamic-routing])

CHECK_VRF()
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

vrf=1001
VRF_RESERVE([$vrf])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

OVS_WAIT_WHILE([ip link | grep -q ovnvrf$vrf:.*UP])

check ovn-nbctl                                                   \
    -- lr-add R1                                                  \
    -- set Logical_Router R1                                      \
            options:requested-tnl-key=$vrf                        \
            options:dynamic-routing=true                          \
    -- ls-add sw0                                                 \
    -- ls-add public                                              \
    -- lrp-add R1 rp-sw0 00:00:01:01:02:03 2001:db8:100::1/64     \
    -- lrp-add R1 rp-public 00:00:02:01:02:03 2001:db8:1001::1/64 \
    -- lrp-set-options rp-public                                  \
            dynamic-routing-maintain-vrf=true                     \
            dynamic-routing-redistribute=lb                       \
    -- set logical_router R1 options:chassis=hv1                  \
    -- lsp-add sw0 sw0-rp                                         \
    -- set Logical_Switch_Port sw0-rp type=router                 \
            options:router-port=rp-sw0                            \
    -- lsp-set-addresses sw0-rp router                            \
    -- lsp-add public public-rp                                   \
    -- set Logical_Switch_Port public-rp type=router              \
            options:router-port=rp-public                         \
    -- lsp-set-addresses public-rp router                         \
    -- lsp-add public public1                                     \
    -- lsp-set-addresses public1 unknown                          \
    -- lsp-set-type public1 localnet                              \
    -- lsp-set-options public1 network_name=phynet

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync
wait_for_ports_up


AT_CHECK([test `ip -6 route show table $vrf | wc -l` -eq 1], [1])

# Create a load balancer and associate to R1.
check ovn-nbctl                                                       \
    -- lb-add lb1 [[2001:db8:1001::150]]:80 [[2001:db8:2001::100]]:80 \
    -- lr-lb-add R1 lb1
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf1001:.*UP])
AT_CHECK([test `ip -6 route show table 1001 | wc -l` -eq 1])

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1001::150 dev lo proto ovn metric 1000 pref medium])

# Add distributed router connected through "join" LS and ensure
# that its LB VIPs are redistributed by R1. LS join has no
# IP config, routers reach each other over IPv6 LLAs
check ovn-nbctl \
    -- remove Logical_Router_Port rp-public                    \
            options dynamic-routing-redistribute               \
    -- lrp-add R1 r1-join 00:00:00:00:ff:02                    \
    -- lrp-set-options r1-join dynamic-routing-redistribute=lb \
    -- ls-add ls-join                                          \
    -- lsp-add ls-join lsp-join-to-r1                          \
    -- lsp-set-type lsp-join-to-r1 router                      \
    -- lsp-set-options lsp-join-to-r1 router-port=r1-join      \
    -- lsp-set-addresses lsp-join-to-r1 router                 \
    -- lr-add R2                                               \
    -- lrp-add R2 r2-join 00:00:00:00:fe:02                    \
    -- lsp-add ls-join lsp-join-to-r2                          \
    -- lsp-set-type lsp-join-to-r2 router                      \
    -- lsp-set-options lsp-join-to-r2 router-port=r2-join      \
    -- lrp-set-gateway-chassis r2-join hv1

# Create a load balancer and associate to R2.
check ovn-nbctl                                                       \
    -- lb-add lb2 [[2001:db8:3001::150]]:80 [[2001:db8:4001::100]]:80 \
    -- lr-lb-add R2 lb2
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1001::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:3001::150 dev lo proto ovn metric 100 pref medium])

# Move DGW of R2 to another chassis to verify that route priority decreases.
check ovn-nbctl                              \
    -- lrp-del-gateway-chassis r2-join hv1   \
    -- lrp-set-gateway-chassis r2-join hv123
check ovn-nbctl --wait=hv sync

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1001::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:3001::150 dev lo proto ovn metric 1000 pref medium])

# Before cleanup of hv1 ovn-controller, trigger a recompute
# to cleanup the local datapaths. Otherwise, the test will fail.
# This is because we don't remove a datapath from
# the local_datapaths hmap while handling the port binding
# changes incrementally yet.
check ovn-appctl inc-engine/recompute

OVN_CLEANUP_CONTROLLER([hv1])

# Ensure system resources are cleaned up.
AT_CHECK([ip link | grep -q ovnvrf1001:.*UP], [1])
AT_CHECK([test `ip -6 route show table 1001 | wc -l` -eq 1], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - DNAT and DNAT_AND_SNAT on gateway router IPv4])
AT_KEYWORDS([dynamic-routing])

CHECK_VRF()
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

vrf=1002
VRF_RESERVE([$vrf])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

OVS_WAIT_WHILE([ip link | grep -q ovnvrf$vrf:.*UP])

check ovn-nbctl                                             \
    -- lr-add R1                                            \
    -- set Logical_Router R1                                \
            options:requested-tnl-key=$vrf                  \
            options:dynamic-routing=true                    \
    -- ls-add sw0                                           \
    -- ls-add public                                        \
    -- lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24   \
    -- lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-options rp-public                            \
           dynamic-routing-maintain-vrf=true                \
           dynamic-routing-redistribute=nat                 \
    -- set logical_router R1 options:chassis=hv1            \
    -- lsp-add sw0 sw0-rp                                   \
    -- set Logical_Switch_Port sw0-rp type=router           \
            options:router-port=rp-sw0                      \
    -- lsp-set-addresses sw0-rp router                      \
    -- lsp-add public public-rp                             \
    -- set Logical_Switch_Port public-rp type=router        \
            options:router-port=rp-public                   \
    -- lsp-set-addresses public-rp router                   \
    -- lsp-add public public1                               \
    -- lsp-set-addresses public1 unknown                    \
    -- lsp-set-type public1 localnet                        \
    -- lsp-set-options public1 network_name=phynet

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync
wait_for_ports_up

AT_CHECK([test `ip route show table $vrf | wc -l` -eq 2], [1])

# Create dnat_and_snat, dnat rules in R1.
check ovn-nbctl                                             \
    -- lr-nat-add R1 dnat_and_snat 172.16.1.10 192.168.1.10 \
    -- lr-nat-add R1 dnat 172.16.1.11 192.168.1.11
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 172.16.1.10 proto ovn metric 1000
blackhole 172.16.1.11 proto ovn metric 1000])

# Add distributed router connected through "join" LS and ensure
# that its external NAT IPs are redistributed by R1. LS join has no
# IP config, routers reach each other over IPv6 LLAs.
check ovn-nbctl                                                 \
    -- remove Logical_Router_Port rp-public                     \
            options dynamic-routing-redistribute                \
    -- lrp-add R1 r1-join 00:00:00:00:ff:02                     \
    -- lrp-set-options r1-join dynamic-routing-redistribute=nat \
    -- ls-add ls-join                                           \
    -- lsp-add ls-join lsp-join-to-r1                           \
    -- lsp-set-type lsp-join-to-r1 router                       \
    -- lsp-set-options lsp-join-to-r1 router-port=r1-join       \
    -- lsp-set-addresses lsp-join-to-r1 router                  \
    -- lr-add R2                                                \
    -- lrp-add R2 r2-join 00:00:00:00:fe:02                     \
    -- lsp-add ls-join lsp-join-to-r2                           \
    -- lsp-set-type lsp-join-to-r2 router                       \
    -- lsp-set-options lsp-join-to-r2 router-port=r2-join       \
    -- ha-chassis-group-add g1                                  \
    -- ha-chassis-group-add-chassis g1 hv1 10

group_uuid=$(fetch_column nb:HA_Chassis_Group _uuid name=g1)
check ovn-nbctl set logical_router_port r2-join ha_chassis_group="$group_uuid"

# Create valid NATs on R2 (these should be advertised).
check ovn-nbctl --gateway-port r2-join \
    lr-nat-add R2 dnat_and_snat 10.42.10.10 192.168.1.10
check ovn-nbctl --gateway-port r2-join \
    lr-nat-add R2 dnat_and_snat 10.42.10.11 192.168.1.11

# Create NATs without explicit gateway_port set on R2 (these should not be
# advertised when multiple DGPs are configured because the configuration is
# invalid / ambiguous in that case).
check ovn-nbctl \
    lr-nat-add R2 dnat_and_snat 10.42.10.12 192.168.1.12
check ovn-nbctl \
    lr-nat-add R2 dnat_and_snat 10.42.10.13 192.168.1.13
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 10.42.10.10 proto ovn metric 100
blackhole 10.42.10.11 proto ovn metric 100
blackhole 10.42.10.12 proto ovn metric 100
blackhole 10.42.10.13 proto ovn metric 100
blackhole 172.16.1.10 proto ovn metric 1000
blackhole 172.16.1.11 proto ovn metric 1000])

# Move DGW of R2 to another chassis to verify that route priority decreases.
check ovn-nbctl                             \
  -- ha-chassis-group-add-chassis g1 hv2 20 \
  -- ha-chassis-group-remove-chassis g1 hv1
check ovn-nbctl --wait=hv sync

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 10.42.10.10 proto ovn metric 1000
blackhole 10.42.10.11 proto ovn metric 1000
blackhole 10.42.10.12 proto ovn metric 1000
blackhole 10.42.10.13 proto ovn metric 1000
blackhole 172.16.1.10 proto ovn metric 1000
blackhole 172.16.1.11 proto ovn metric 1000])

# Add "guest" LS connected the distributed router R2 and one "VM" called
# guest1.
# Also, connect R2 to ls-join via another DGW.
check ovn-nbctl                                                     \
    -- lrp-add R2 r2-guest 00:00:00:00:fd:02 192.168.2.1/24         \
    -- lrp-add R2 r2-join-dgw2 00:00:00:00:fd:02                    \
    -- lsp-add ls-join lsp-join-to-r2-dgw2                          \
    -- lsp-set-type lsp-join-to-r2-dgw2 router                      \
    -- lsp-set-options lsp-join-to-r2-dgw2 router-port=r2-join-dgw2 \
    -- ls-add ls-guest                                              \
    -- lsp-add ls-guest lsp-guest-to-r2                             \
    -- lsp-set-type lsp-guest-to-r2 router                          \
    -- lsp-set-options lsp-guest-to-r2 router-port=r2-guest         \
    -- lsp-set-addresses lsp-guest-to-r2 router                     \
    -- lsp-add ls-guest guest1                                      \
    -- lsp-set-addresses guest1 '00:00:00:00:fc:03 192.168.2.10'

check ovn-nbctl \
    -- set logical_router_port r2-join-dgw2 ha_chassis_group="$group_uuid"
check ovn-nbctl --wait=hv sync

# Bind guest1 on hv1.
ADD_NAMESPACES(guest1)
ADD_VETH(guest1, guest1, br-int, "192.168.2.10/24", "00:00:00:00:fd:03", \
         "192.168.2.1")

# Add distributed NAT on R2 for guest1 and ensure that it's advertised
# with better metric on chassis hv1 even when DGP for R2 is elsewhere.
check ovn-nbctl                                              \
    --gateway-port r2-join-dgw2 --add-route                  \
        lr-nat-add R2 dnat_and_snat 10.42.20.11 192.168.2.10 \
        guest1 00:00:00:00:fc:04
check ovn-nbctl --wait=hv sync

# At this point, because R2 has multiple DGPs the NAT rules for
# 10.42.10.12 and 10.42.10.13 have become invalid so ovn shouldn't
# advertise them anymore.

OVN_ROUTE_EQUAL([ovnvrf$vrf], [dnl
blackhole 10.42.10.10 proto ovn metric 1000
blackhole 10.42.10.11 proto ovn metric 1000
blackhole 10.42.20.11 proto ovn metric 100
blackhole 172.16.1.10 proto ovn metric 1000
blackhole 172.16.1.11 proto ovn metric 1000])

# Before cleanup of hv1 ovn-controller, trigger a recompute
# to cleanup the local datapaths. Otherwise, the test will fail.
# This is because we don't remove a datapath from
# the local_datapaths hmap while handling the port binding
# changes incrementally yet.
check ovn-appctl inc-engine/recompute

# Skip ls-join in flows comparison between I+P and recompute, because R2 has multiple DGPs.
# This causes the following flows in sb
# table=xx(ls_in_l2_lkup      ), priority=80   , match=(flags[1] == 0 && arp.op == 1 && arp.tpa == 10.42.10.10), action=(outport = "lsp-join-to-r2"; output;)
# table=xx(ls_in_l2_lkup      ), priority=80   , match=(flags[1] == 0 && arp.op == 1 && arp.tpa == 10.42.10.10), action=(outport = "lsp-join-to-r2-dgw2"; output;)
OVN_CLEANUP_CONTROLLER([hv1], [], [], [ls-join])

# Ensure system resources are cleaned up.
AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP], [1])
AT_CHECK([test `ip route show table $vrf | wc -l` -eq 1], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dynamic-routing - DNAT and DNAT_AND_SNAT on gateway router IPv6])
AT_KEYWORDS([dynamic-routing])

CHECK_VRF()
CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()

vrf=1003
VRF_RESERVE([$vrf])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller.
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller.
start_daemon ovn-controller

OVS_WAIT_WHILE([ip link | grep -q ovnvrf$vrf:.*UP])

check ovn-nbctl                                                   \
    -- lr-add R1                                                  \
    -- set Logical_Router R1                                      \
            options:requested-tnl-key=$vrf                        \
            options:dynamic-routing=true                          \
    -- ls-add sw0                                                 \
    -- ls-add public                                              \
    -- lrp-add R1 rp-sw0 00:00:01:01:02:03 2001:db8:100::1/64     \
    -- lrp-add R1 rp-public 00:00:02:01:02:03 2001:db8:1003::1/64 \
    -- lrp-set-options rp-public                                  \
           dynamic-routing-maintain-vrf=true                      \
           dynamic-routing-redistribute=nat                       \
    -- set logical_router R1 options:chassis=hv1                  \
    -- lsp-add sw0 sw0-rp                                         \
    -- set Logical_Switch_Port sw0-rp type=router                 \
            options:router-port=rp-sw0                            \
    -- lsp-set-addresses sw0-rp router                            \
    -- lsp-add public public-rp                                   \
    -- set Logical_Switch_Port public-rp type=router              \
            options:router-port=rp-public                         \
    -- lsp-set-addresses public-rp router                         \
    -- lsp-add public public1                                     \
    -- lsp-set-addresses public1 unknown                          \
    -- lsp-set-type public1 localnet                              \
    -- lsp-set-options public1 network_name=phynet

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync
wait_for_ports_up

AT_CHECK([test `ip -6 route show table $vrf | wc -l` -eq 2], [1])

# Create dnat_and_snat, dnat rules in R1.
check ovn-nbctl                                                         \
    -- lr-nat-add R1 dnat_and_snat 2001:db8:1003::150 2001:db8:100::100 \
    -- lr-nat-add R1 dnat 2001:db8:1003::151 2001:db8:100::100

check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])
OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1003::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1003::151 dev lo proto ovn metric 1000 pref medium])

# Add distributed router connected through "join" LS and ensure
# that its external NAT IPs are redistributed by R1. LS join has no
# IP config, routers reach each other over IPv6 LLAs.
check ovn-nbctl                                                 \
    -- remove Logical_Router_Port rp-public                     \
            options dynamic-routing-redistribute                \
    -- lrp-add R1 r1-join 00:00:00:00:ff:02                     \
    -- lrp-set-options r1-join dynamic-routing-redistribute=nat \
    -- ls-add ls-join                                           \
    -- lsp-add ls-join lsp-join-to-r1                           \
    -- lsp-set-type lsp-join-to-r1 router                       \
    -- lsp-set-options lsp-join-to-r1 router-port=r1-join       \
    -- lsp-set-addresses lsp-join-to-r1 router                  \
    -- lr-add R2                                                \
    -- lrp-add R2 r2-join 00:00:00:00:fe:02                     \
    -- lsp-add ls-join lsp-join-to-r2                           \
    -- lsp-set-type lsp-join-to-r2 router                       \
    -- lsp-set-options lsp-join-to-r2 router-port=r2-join       \
    -- ha-chassis-group-add g1                                  \
    -- ha-chassis-group-add-chassis g1 hv1 10

group_uuid=$(fetch_column nb:HA_Chassis_Group _uuid name=g1)
check ovn-nbctl set logical_router_port r2-join ha_chassis_group="$group_uuid"

# Create valid NATs on R2 (these should be advertised).
check ovn-nbctl --gateway-port r2-join \
    lr-nat-add R2 dnat_and_snat 2001:db8:1004::150 2001:db8:201::100
check ovn-nbctl --gateway-port r2-join \
    lr-nat-add R2 dnat 2001:db8:1004::151 2001:db8:201::101

# Create NATs without explicit gateway_port set on R2 (these should not be
# advertised when multiple DGPs are configured because the configuration is
# invalid / ambiguous in that case).
check ovn-nbctl \
    lr-nat-add R2 dnat_and_snat 2001:db8:1004::152 2001:db8:201::102
check ovn-nbctl \
    lr-nat-add R2 dnat_and_snat 2001:db8:1004::153 2001:db8:201::103
check ovn-nbctl --wait=hv sync

AT_CHECK([ip link | grep -q ovnvrf$vrf:.*UP])

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1003::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1003::151 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::150 dev lo proto ovn metric 100 pref medium
blackhole 2001:db8:1004::151 dev lo proto ovn metric 100 pref medium
blackhole 2001:db8:1004::152 dev lo proto ovn metric 100 pref medium
blackhole 2001:db8:1004::153 dev lo proto ovn metric 100 pref medium])

# Move DGW of R2 to another chassis to verify that route priority decreases.
check ovn-nbctl                             \
  -- ha-chassis-group-add-chassis g1 hv2 20 \
  -- ha-chassis-group-remove-chassis g1 hv1
check ovn-nbctl --wait=hv sync

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1003::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1003::151 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::151 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::152 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::153 dev lo proto ovn metric 1000 pref medium])

# Add "guest" LS connected the distributed router R2 and one "VM" called
# guest1.
# Also, connect R2 to ls-join via another DGW.
check ovn-nbctl                                                       \
    -- lrp-add R2 r2-guest 00:00:00:00:fd:02 2001:db9:2000::1/64      \
    -- lrp-add R2 r2-join-dgw2 00:00:00:00:fd:02                      \
    -- lsp-add ls-join lsp-join-to-r2-dgw2                            \
    -- lsp-set-type lsp-join-to-r2-dgw2 router                        \
    -- lsp-set-options lsp-join-to-r2-dgw2 router-port=r2-join-dgw2   \
    -- ls-add ls-guest                                                \
    -- lsp-add ls-guest lsp-guest-to-r2                               \
    -- lsp-set-type lsp-guest-to-r2 router                            \
    -- lsp-set-options lsp-guest-to-r2 router-port=r2-guest           \
    -- lsp-set-addresses lsp-guest-to-r2 router                       \
    -- lsp-add ls-guest guest1                                        \
    -- lsp-set-addresses guest1 '00:00:00:00:fc:03 2001:db9:2000::10'

check ovn-nbctl \
    -- set logical_router_port r2-join-dgw2 ha_chassis_group="$group_uuid"
check ovn-nbctl --wait=hv sync

# Bind guest1 on hv1.
ADD_NAMESPACES(guest1)
ADD_VETH(guest1, guest1, br-int, "2001:db9:2000::10/64", "00:00:00:00:fd:03", \
         "2001:db9:2000::1", "nodad")

# Add distributed NAT on R2 for guest1 and ensure that it's advertised
# with better metric on chassis hv1 even when DGP for R2 is elsewhere.
check ovn-nbctl                                                          \
    --gateway-port r2-join-dgw2 --add-route                              \
        lr-nat-add R2 dnat_and_snat 2001:db8:1005::150 2001:db9:2000::10 \
        guest1 00:00:00:00:fc:04
check ovn-nbctl --wait=hv sync

# At this point, because R2 has multiple DGPs the NAT rules for
# 2001:db8:1004::152 and 2001:db8:1004::153 have become invalid so ovn
# shouldn't advertise them anymore.

OVN_ROUTE_V6_EQUAL([ovnvrf$vrf], [dnl
blackhole 2001:db8:1003::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1003::151 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::150 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1004::151 dev lo proto ovn metric 1000 pref medium
blackhole 2001:db8:1005::150 dev lo proto ovn metric 100 pref medium])

# Before cleanup of hv1 ovn-controller, trigger a recompute
# to cleanup the local datapaths. Otherwise, the test will fail.
# This is because we don't remove a datapath from
# the local_datapaths hmap while handling the port binding
# changes incrementally yet.
check ovn-appctl inc-engine/recompute

OVN_CLEANUP_CONTROLLER([hv1], [], [], [ls-join])
# Ensure system resources are cleaned up.
AT_CHECK([ip link | grep -q ovnvrf1003:.*UP], [1])
AT_CHECK([test `ip -6 route show table 1003 | wc -l` -eq 2], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Mac binding aging - Probing])
AT_KEYWORDS([mac_binding_probing])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])
ADD_BR([br-gw])

check ovs-ofctl add-flow br-ext action=normal
check ovs-ofctl add-flow br-gw action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-appctl -t ovn-controller vlog/set mac_cache:file:dbg pinctrl:file:dbg
check ovn-nbctl lr-add lr
check ovn-nbctl set logical_router lr options:chassis=hv1
check ovn-nbctl set logical_router lr options:mac_binding_age_threshold=5

check ovn-nbctl ls-add sw
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add lr rp-sw 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64
check ovn-nbctl lrp-add lr rp-public 00:00:02:01:02:03 172.16.1.1/24 fd12::1/64

check ovn-nbctl lsp-add sw sw-rp -- set Logical_Switch_Port sw-rp \
    type=router options:router-port=rp-sw \
    -- lsp-set-addresses sw-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ADD_NAMESPACES(alice)
ADD_VETH(alice, alice, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1", "nodad", "192.168.1.2/24", "192.168.1.1")
check ovn-nbctl lsp-add sw alice -- lsp-set-addresses alice "f0:00:00:01:02:03 192.168.1.2 fd11::2"

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext
check ovn-nbctl lsp-add public public \
        -- lsp-set-addresses public unknown \
        -- lsp-set-type public localnet \
        -- lsp-set-options public network_name=phynet

ADD_NAMESPACES(gw)
ADD_VETH(gw0, gw, br-ext, "fd12::2/64", "f0:00:00:01:02:04", \
         "fd12::1", "nodad", "172.16.1.2/24", "172.16.1.1")
ADD_VETH(gw1, gw, br-gw, "172.16.2.2/24", "f0:00:00:01:03:04")
NS_CHECK_EXEC([gw], [ip a a fd13::2/64 dev gw1 nodad])

NS_CHECK_EXEC([gw], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl
net.ipv4.conf.all.forwarding = 1
])
NS_CHECK_EXEC([gw], [sysctl -w net.ipv6.conf.all.forwarding=1],[0], [dnl
net.ipv6.conf.all.forwarding = 1
])

ADD_NAMESPACES(bob)
ADD_VETH(bob, bob, br-gw, "fd13::a/64", "f0:00:00:01:02:06", \
         "fd13::2", "nodad", "172.16.2.10/24", "172.16.2.2")

check ovn-nbctl lr-route-add lr 0.0.0.0/0 172.16.1.2
check ovn-nbctl lr-route-add lr ::/0 fd12::2
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([alice], [ping -q -c 3 -i 0.3 -w 2 172.16.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
check_row_count mac_binding 1 mac=\"f0:00:00:01:02:04\"
mac_binding_uuid=$(fetch_column mac_binding _uuid logical_port=rp-public ip=172.16.1.2)

NETNS_START_TCPDUMP([gw], [-n -c 2 -i gw0 arp[[6:2]] == 0x1 and arp[[24:4]] == 0xac100102], [gw])
NS_CHECK_EXEC([alice], [ping -q -c 30 -i 0.5 172.16.2.10 | FORMAT_PING], \
[0], [dnl
30 packets transmitted, 30 received, 0% packet loss, time 0ms
])

# Check mac binding entry is still active.
check_row_count mac_binding 1 mac=\"f0:00:00:01:02:04\"
# Check mac binding entry has not been removed.
AT_CHECK([test "$(fetch_column mac_binding _uuid logical_port=rp-public ip=172.16.1.2)" = "$mac_binding_uuid"])
OVS_WAIT_UNTIL([
    n_arp=$(cat gw.tcpdump | wc -l)
    test ${n_arp} -ge 2
])

# Wait for the mac binding entry to expire.
wait_row_count MAC_Binding 0

NS_CHECK_EXEC([alice], [ping -6 -q -c 3 -i 0.3 -w 2 fd13::a | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

check_row_count mac_binding 1 mac=\"f0:00:00:01:02:04\" ip=\"fd12::2\"
mac_binding_uuid=$(fetch_column mac_binding _uuid mac=\"f0:00:00:01:02:04\" ip=\"fd12::2\")
NETNS_START_TCPDUMP([gw], [-n -c 2 -i gw0 icmp6 and ip6[[40]] == 0x87], [gw6])

NS_CHECK_EXEC([alice], [ping -6 -q -c 30 -i 0.5 fd13::a | FORMAT_PING], \
[0], [dnl
30 packets transmitted, 30 received, 0% packet loss, time 0ms
])

AT_CHECK([test "$(fetch_column mac_binding _uuid mac=\"f0:00:00:01:02:04\" ip=\"fd12::2\")" = "$mac_binding_uuid"])
OVS_WAIT_UNTIL([
    n_ns=$(cat gw6.tcpdump | wc -l)
    test ${n_ns} -ge 2
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([bfd induced recomputes])
ovn_start --use-tcp-to-sb
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-phys])

dnl Set external-ids in br-int needed for ovn-controller
PARSE_LISTENING_PORT([$ovs_base/ovn-sb/ovsdb-server.log], [TCP_PORT])

check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=tcp:127.0.0.1:$TCP_PORT \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp1 -- lsp-set-addresses lsp1 "00:00:10:01:02:01 10.0.0.1"
check ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lsp1 -- set Interface vif1 type=internal

check ovn-nbctl --wait=hv sync
wait_for_ports_up

# Stop updates from ovn-controller to sb
stop_ovsdb_controller_updates $TCP_PORT

# Change sb_global:options:nb_cfg; this will trigger updates to (Chassis_Private in ) sb by ovn-controller.
check ovn-nbctl --wait=sb sync
# sb should now be read-only.

lflow_run=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

# Change again nb_cfg.
check ovn-nbctl --wait=sb sync

# Re-enable notifications from sb.
restart_ovsdb_controller_updates $TCP_PORT

# Make sure ovn-controller run.
check ovn-nbctl --wait=hv sync

lflow_run_end=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

n_recomputes=`expr $lflow_run_end - $lflow_run`
echo "$n_recomputes recomputes"

AT_CHECK([test $lflow_run_end == $lflow_run])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP()

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing lb_force_snat_ip with template])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

check_uuid ovn-nbctl create Logical_Router name=R1
check_uuid ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add bar
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add join

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
check ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
check ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
check ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
check ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
check ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
check ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
check ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
check ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

check ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.5"

AT_CHECK([ovn-nbctl -- create chassis_template_var chassis="hv1" \
          variables="{vip=172.16.1.1,vport1=8000,backends1=\"192.168.1.2:80,192.168.2.2:80\"}"],
          [0], [ignore])

# Config OVN load-balancer with a VIP.
check ovn-nbctl --template lb-add lb1 "^vip:^vport1" "^backends1" tcp
check ovn-nbctl lr-lb-add R2 lb1
# Wait for ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

NETNS_START_TCPDUMP([foo1], [-neei foo1 src 20.0.0.5 and tcp], [foo1])
NETNS_START_TCPDUMP([bar1], [-neei bar1 src 20.0.0.5 and tcp], [bar1])

check ovs-appctl dpctl/flush-conntrack
for i in $(seq 10); do
    NS_EXEC([alice1], [wget 172.16.1.1:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

OVS_WAIT_UNTIL([
    n_pkt=$(cat foo1.tcpdump | wc -l)
    test "${n_pkt}" -ge 1
])
OVS_WAIT_UNTIL([
    n_pkt=$(cat bar1.tcpdump | wc -l)
    test "${n_pkt}" -ge 1
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.5) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.5,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.5,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

OVN_CLEANUP_CONTROLLER([hv1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])
